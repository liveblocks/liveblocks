---
meta:
  title: "@liveblocks/emails"
  parentTitle: "API Reference"
  description: "API Reference for the @liveblocks/emails package"
alwaysShowAllNavigationLevels: false
---

`@liveblocks/emails` provides a set of functions that simplifies sending styled
emails with [Notifications](/docs/ready-made-features/notifications) and
[webhooks](/docs/platform/webhooks). This library is only intended for use in
your Node.js back end.

## Requirements

`@liveblocks/emails` requires the
[`@liveblocks/node`](/docs/api-reference/liveblocks-node) package to be
installed and for [`react`](https://react.dev/) to be a peer dependency in your
project.

## Setup

This package exposes functions that enable easy creation of styled emails with
React and HTML. Each method is designed to be used with our
[webhooks](/docs/platform/webhooks) which means you must
[set them up](/docs/guides/how-to-test-webhooks-on-localhost) first. Webhooks
require an API endpoint in your application, and this is typically what they
will look like.

```tsx title="Next.js route handler for webhooks"
import { isThreadNotificationEvent, WebhookHandler } from "@liveblocks/node";
import { Liveblocks } from "@liveblocks/node";
// +++
import { prepareThreadNotificationEmailAsReact } from "@liveblocks/emails";
// +++

const liveblocks = new Liveblocks({
  secret: "{{SECRET_KEY}}",
});

const webhookHandler = new WebhookHandler(
  process.env.LIVEBLOCKS_WEBHOOK_SECRET_KEY as string
);

export async function POST(request: Request) {
  const body = await request.json();
  const headers = request.headers;

  // Verify if this is a real webhook request
  let event;
  try {
    event = webhookHandler.verifyRequest({
      headers: headers,
      rawBody: JSON.stringify(body),
    });
  } catch (err) {
    console.error(err);
    return new Response("Could not verify webhook call", { status: 400 });
  }

  // +++
  // Using `@liveblocks/emails` to create an email
  if (isThreadNotificationEvent(event)) {
    const emailData = await prepareThreadNotificationEmailAsReact(
      liveblocks,
      event
    );

    if (emailData.type === "unreadMention") {
      const email = (
        <div>
          <div>
            @{emailData.comment.author.id} at {emailData.comment.createdAt}
          </div>
          <div>{emailData.comment.body}</div>
        </div>
      );

      // Send unread mention email
      // ...
    }
  }
  // +++

  return new Response(null, { status: 200 });
}
```

**We’ll only show the highlighted part below**, as it’s assumed you’ve set this
already, and your file contains `liveblocks` and `event`.

### End-to-end guides

We have two guides that take you through every step of setting up your email
notifications, including setting up webhooks:

- [How to send email notifications of unread comments](/docs/guides/how-to-send-email-notifications-of-unread-comments).
- [How to send email notifications for unread text editor mentions ](/docs/guides/how-to-send-email-notifications-for-unread-text-editor-mentions).

### Ready-made email templates

We have a number of examples that show you how to set up emails with your
Comments or Text Editor application. Each [Resend](https://resend.com) example
has full ready-made email templates inside, which are a great starting point for
your application.

- [Comments + Resend](/examples/comments-emails/nextjs-comments-emails-resend).
- [Comments + SendGrid](/examples/comments-emails/nextjs-comments-emails-sendgrid).
- [Text Editor/Tiptap + Resend](/examples/collaborative-text-editor-emails/nextjs-tiptap-emails-resend).
- [Text Editor/Lexical + Resend](/examples/collaborative-text-editor-emails/nextjs-lexical-emails-resend).

## Thread notification emails [#thread-notification-emails]

These functions help you create emails to notify users of _unread comments_ in
threads. They fetch each relevant comment, filtering out any that have already
been read, and help you style each comment’s body with either
[React](#prepare-thread-notification-email-as-react) or
[HTML](#prepare-thread-notification-email-as-html).

<Figure>
  <Image
    src="/assets/emails/new-comments-email.png"
    alt="An email showing 7 new comments, with comment bodies and links to each comment"
    width={1567}
    height={830}
  />
</Figure>

<Banner>

This screenshot shows a ready-made template from our
[Comments + Resend](/examples/comments-emails/nextjs-comments-emails-resend)
example.

</Banner>

These functions also help you distinguish between _unread mentions_ and _unread
replies_.

A thread has _unread replies_ if a comment was created after the `readAt` date
on the notification, and created before or at the same time as the `notifiedAt`
date. All unread replies are returned in an array.

```js
{
  type: "unreadReplies",
  roomId: "my-room-id",
  comments: [
    {/* Comment data */},
    // ...
  ],
}
```

A thread has an _unread mention_ if it has unread replies, and one of the
replies mentions the user. A single comment with the latest mention is returned.

```js
{
  type: "unreadMention",
  roomId: "my-room-id",
  comment: {/* Comment data */},
}
```

### prepareThreadNotificationEmailAsReact [#prepare-thread-notification-email-as-react]

Takes a
[thread notification webhook event](/docs/platform/webhooks#Thread-notification)
and returns unread comment body(s) related to the notification, as React nodes.
It can return one of three formats, an `unreadMention` type containing one
comment, an `unreadReplies` type returning multiple comments, or `null` if there
are no unread mentions/replies. You can also
[resolve public data](#prepare-thread-notification-email-as-react-resolving-data)
and
[customize the components](#prepare-thread-notification-email-as-react-customizing-components).

```tsx
import { prepareThreadNotificationEmailAsReact } from "@liveblocks/emails";
import { isThreadNotificationEvent } from "@liveblocks/node";

// Get `liveblocks` and `event` (see "Setup" section)
// ...

if (isThreadNotificationEvent(event)) {
  // +++
  const emailData = await prepareThreadNotificationEmailAsReact(
    liveblocks,
    event
  );
  // +++
  let email;

  switch (emailData.type) {
    case "unreadMention": {
      email = (
        <div>
          <div>
            @{emailData.comment.author.id} at {emailData.comment.createdAt}
          </div>
          <div>{emailData.comment.body}</div>
        </div>
      );
      break;
    }

    case "unreadReplies": {
      email = (
        <div>
          {emailData.comments.map((comment) => (
            <div key={comment.id}>
              <div>
                @{comment.author.id} at {comment.createdAt}
              </div>
              <div>{comment.body}</div>
            </div>
          ))}
        </div>
      );
      break;
    }
  }
}

// Send your email
// ...
```

It’s designed to be used in a webhook event, which requires a
[`Liveblocks`](/docs/api-reference/liveblocks-node#Liveblocks-client) Node.js
client and a
[`WebhookHandler`](/docs/api-reference/liveblocks-node#WebhookHandler). Check
for the correct webhook event using
[`isThreadNotificationEvent`](/docs/api-reference/liveblocks-node#isThreadNotificationEvent)
before running the function, such as in this Next.js route handler.

```tsx title="Full Next.js route handler example" isCollapsed isCollapsable
import { isThreadNotificationEvent, WebhookHandler } from "@liveblocks/node";
import { Liveblocks } from "@liveblocks/node";
// +++
import { prepareThreadNotificationEmailAsReact } from "@liveblocks/emails";
// +++

const liveblocks = new Liveblocks({
  secret: "{{SECRET_KEY}}",
});

const webhookHandler = new WebhookHandler(
  process.env.LIVEBLOCKS_WEBHOOK_SECRET_KEY as string
);

export async function POST(request: Request) {
  const body = await request.json();
  const headers = request.headers;

  // Verify if this is a real webhook request
  let event;
  try {
    event = webhookHandler.verifyRequest({
      headers: headers,
      rawBody: JSON.stringify(body),
    });
  } catch (err) {
    console.error(err);
    return new Response("Could not verify webhook call", { status: 400 });
  }

  // +++
  if (isThreadNotificationEvent(event)) {
    const emailData = await prepareThreadNotificationEmailAsReact(
      liveblocks,
      event
    );
    let email;

    switch (emailData.type) {
      case "unreadMention": {
        email = (
          <div>
            <div>
              @{emailData.comment.author.id} at {emailData.comment.createdAt}
            </div>
            <div>{emailData.comment.body}</div>
          </div>
        );
        break;
      }

      case "unreadReplies": {
        email = (
          <div>
            {emailData.comments.map((comment) => (
              <div key={comment.id}>
                <div>
                  @{comment.author.id} at {comment.createdAt}
                </div>
                <div>{comment.body}</div>
              </div>
            ))}
          </div>
        );
        break;
      }
    }

    // Send your email
    // ...
  }
  // +++

  return new Response(null, { status: 200 });
}
```

<PropertiesList title="Returns">
  <PropertiesListItem
    name="value"
    type="ThreadNotificationEmailDataAsReact | null"
  >
    Returns comment information, and a formatted React body, ready for use in emails. Returns `null` if there are no unread mentions or replies. The result has two formats depending on whether this notification is for a *single unread mention*, or for *multiple unread replies*:

    ```js title="Unread mention" isCollapsable isCollapsed
    {
      type: "unreadMention",
      roomId: "my-room-id",

      // An unread mention has just one comment
      comment: {
        id: "cm_asfs8f...",
        threadId: "th_sj30as..."
        createdAt: Date <Fri Dec 15 2023 14:15:22 GMT+0000 (Greenwich Mean Time)>,

        // The formatted comment, pass it to React `children`
        body: { /* ... */},

        author: {
          id: "aurélien@example.com",
          info: { /* Custom user info you have resolved */ },
        },
      },
    }
    ```

    <div className="-mt-2">

    ```js title="Unread replies" isCollapsable isCollapsed
    {
      type: "unreadReplies",
      roomId: "my-room-id",

      // Unread replies means multiple comments
      comments: [
        {
          id: "cm_asfs8f...",
          threadId: "th_sj30as..."
          createdAt: Date <Fri Dec 15 2023 14:15:22 GMT+0000 (Greenwich Mean Time)>,

          // The formatted comment, pass it to React `children`
          body: { /* ... */},

          author: {
            id: "aurélien@example.com",
            info: { /* Custom user info you have resolved */ },
          },
        },

        // More comments
        //...
      ],
    }
    ```

    </div>

  </PropertiesListItem>
</PropertiesList>

<PropertiesList title="Arguments">
  <PropertiesListItem name="client" type="Liveblocks" required>
    A [`Liveblocks`](/docs/api-reference/liveblocks-node#Liveblocks-client)
    Node.js client.
  </PropertiesListItem>
  <PropertiesListItem name="event" type="ThreadNotificationEvent" required>
    An object passed from a webhook event, specifically the
    [`ThreadNotificationEvent`](/docs/platform/webhooks#Thread-notification).
    [Learn more about setting this up](#Setup).
  </PropertiesListItem>
  <PropertiesListItem name="options" type="object">
    A number of options to customize the format of the comments, adding user
    info, room info, and styles.
  </PropertiesListItem>
  <PropertiesListItem
    name="options.resolveUsers"
    detailedType='async? (args: ResolveUsersArgs) => (UserMeta["info"] | undefined)[] | undefined'
  >
    A function that resolves user information. Return an array of
    `UserMeta["info"]` objects in the same order they arrived. Works similarly
    to the [resolver on the
    client](/docs/api-reference/liveblocks-react#LiveblocksProviderResolveUsers).
    [Learn more](#prepare-thread-notification-email-as-react-resolving-data).
  </PropertiesListItem>
  <PropertiesListItem
    name="options.resolveGroupsInfo"
    detailedType="async? (args: ResolveGroupsInfoArgs) => (GroupInfo | undefined)[] | undefined"
  >
    A function that resolves group information. Return an array of `GroupInfo`
    objects in the same order they arrived. Works similarly to the [resolver on
    the
    client](/docs/api-reference/liveblocks-react#LiveblocksProviderResolveGroupsInfo).
    [Learn more](#prepare-thread-notification-email-as-react-resolving-data).
  </PropertiesListItem>
  <PropertiesListItem
    name="options.resolveRoomInfo"
    detailedType="async? (args: ResolveRoomInfoArgs) => RoomInfo | undefined"
  >
    A function that resolves room information. Return a `RoomInfo` object, as
    matching your types. Works similarly to the [resolver on the
    client](/docs/api-reference/liveblocks-react#LiveblocksProviderResolveRoomsInfo)
    but for one room. [Learn
    more](#prepare-thread-notification-email-as-react-resolving-data).
  </PropertiesListItem>
  <PropertiesListItem name="options.components" type="object">
    Pass different React components to customize the elements in the comment
    bodies. Five components can be passed to the object: `Container`,
    `Paragraph`, `Text`, `Link`, `Mention`. [Learn
    more](#prepare-thread-notification-email-as-react-customizing-components).
  </PropertiesListItem>
  <PropertiesListItem
    name="options.components.Container"
    type="({ children: ReactNode }) => ReactNode"
  >
    The comment body container.
  </PropertiesListItem>
  <PropertiesListItem
    name="options.components.Paragraph"
    type="({ children: ReactNode }) => ReactNode"
  >
    The paragraph block.
  </PropertiesListItem>
  <PropertiesListItem
    name="options.components.Text"
    type="({ children: ReactNode }) => ReactNode"
  >
    The text element.
  </PropertiesListItem>
  <PropertiesListItem
    name="options.components.Link"
    detailedType="({ element: CommentBodyLink, href: string }) => ReactNode"
  >
    The link element.
  </PropertiesListItem>
  <PropertiesListItem
    name="options.components.Mention"
    detailedType={`({ element: CommentBodyMention, user?: UserInfo["info"], group?: GroupInfo }) => ReactNode`}
  >
    The mention element.
  </PropertiesListItem>
</PropertiesList>

#### Resolving data [#prepare-thread-notification-email-as-react-resolving-data]

Similarly to on the client, you can resolve
[users](/docs/api-reference/liveblocks-react#LiveblocksProviderResolveUsers),
[group info](/docs/api-reference/liveblocks-react#LiveblocksProviderResolveGroupsInfo),
and
[room info](/docs/api-reference/liveblocks-react#LiveblocksProviderResolveRoomsInfo),
making it easier to render your emails. For example, you can resolve a user’s ID
into their name, and show their name in the email.

<Banner title="Resolving users and groups" type="info">
  When resolving users and groups, the function receives a list of IDs and you
  should return a list of objects of the same size, in the same order.
</Banner>

```tsx
const emailData = await prepareThreadNotificationEmailAsReact(
  liveblocks,
  webhookEvent,
  {
    // +++
    resolveUsers: async ({ userIds }) => {
      const usersData = await __getUsersFromDB__(userIds);

      return usersData.map((userData) => ({
        name: userData.name, // "Nimesh"
        avatar: userData.avatar.src, // "https://..."
      }));
    },
    resolveGroupsInfo: async ({ groupIds }) => {
      const groupsData = await __getGroupsFromDB__(groupIds);

      return groupsData.map((groupData) => ({
        name: groupData.name, // "Engineering"
        avatar: groupData.avatar.src, // "https://..."
      }));
    },
    resolveRoomInfo({ roomId }) {
      return {
        name: roomId, // "my-room-name"
        url: `https://example.com/${roomId}`,
      };
    },
    // +++
  }
);

// { type: "unreadMention", comment: { ... }, ... }
console.log(emailData);

// { name: "Nimesh", avatar: "https://..." }
console.log(emailData.comment.author.info);

// { name: "my-room-name", url: "https://example.com/my-room-name" }
console.log(emailData.roomInfo);
```

#### Customizing components [#prepare-thread-notification-email-as-react-customizing-components]

Each React component in the comment body can be replaced with a custom React
component, if you wish to apply different styles. Five components are available:
`Container`, `Paragraph`, `Text`, `Link`, `Mention`.

```tsx
const emailData = await prepareThreadNotificationEmailAsReact(
  liveblocks,
  webhookEvent,
  {
    // +++
    components: {
      Paragraph: ({ children }) => <p>{children}</p>,

      // `react-email` components are supported
      Text: ({ children }) => (
        <Text className="text-sm text-black m-0 mb-4">{children}</Text>
      ),

      // `user` and `group` are the optional data returned from `resolveUsers` and `resolveGroupsInfo`
      Mention: ({ element, user, group }) => (
        <span style={{ color: "red" }}>
          @{user?.name ?? group?.name ?? element.id}
        </span>
      ),

      // If the link is rich-text render it, otherwise use the URL
      Link: ({ element, href }) => <a href={href}>{element?.text ?? href}</a>,
    },
    // +++
  }
);

// { type: "unreadMention", comment: { ... }, ... }
console.log(emailData);

// The previously defined components are used in the body property, now formatted as React nodes.
console.log(emailData.comment.body);
```

### prepareThreadNotificationEmailAsHtml [#prepare-thread-notification-email-as-html]

Takes a
[thread notification webhook event](/docs/platform/webhooks#Thread-notification)
and returns unread comment body(s) related to the notification, as an HTML-safe
string. It can return one of three formats, an `unreadMention` type containing
one comment, an `unreadReplies` type returning multiple comments, or `null` if
there are no unread mentions/replies. You can also
[resolve public data](#prepare-thread-notification-email-as-html-resolving-data)
and
[customize the styles](#prepare-thread-notification-email-as-html-styling-elements).

```ts
import { prepareThreadNotificationEmailAsHtml } from "@liveblocks/emails";
import { isThreadNotificationEvent } from "@liveblocks/node";

// Get `liveblocks` and `event` (see "Setup" section)
// ...

if (isThreadNotificationEvent(event)) {
  // +++
  const emailData = await prepareThreadNotificationEmailAsHtml(
    liveblocks,
    event
  );
  // +++
  let email;

  switch (emailData.type) {
    case "unreadMention": {
      email = `
        <div>
          <div>
            @${emailData.comment.author.id} at ${emailData.comment.createdAt}
          </div>
          <div>${emailData.comment.body}</div>
        </div>
      `;
      break;
    }

    case "unreadReplies": {
      email = `
        <div>
          ${emailData.comments
            .map(
              (comment) => `
                <div>
                  <div>
                    @${comment.author.id} at ${comment.createdAt}
                  </div>
                  <div>${comment.body}</div>
                </div>
              `
            )
            .join("")}
        </div>
      `;
      break;
    }
  }
}

// Send your email
// ...
```

It’s designed to be used in a webhook event, which requires a
[`Liveblocks`](/docs/api-reference/liveblocks-node#Liveblocks-client) Node.js
client, a
[`WebhookHandler`](/docs/api-reference/liveblocks-node#WebhookHandler). Check
for the correct webhook event using
[`isThreadNotificationEvent`](/docs/api-reference/liveblocks-node#isThreadNotificationEvent)
before running the function, such as in this Next.js route handler.

```tsx title="Full Next.js route handler example" isCollapsed isCollapsable
import { isThreadNotificationEvent, WebhookHandler } from "@liveblocks/node";
import { Liveblocks } from "@liveblocks/node";
// +++
import { prepareThreadNotificationEmailAsHtml } from "@liveblocks/emails";
// +++

const liveblocks = new Liveblocks({
  secret: "{{SECRET_KEY}}",
});

const webhookHandler = new WebhookHandler(
  process.env.LIVEBLOCKS_WEBHOOK_SECRET_KEY as string
);

export async function POST(request: Request) {
  const body = await request.json();
  const headers = request.headers;

  // Verify if this is a real webhook request
  let event;
  try {
    event = webhookHandler.verifyRequest({
      headers: headers,
      rawBody: JSON.stringify(body),
    });
  } catch (err) {
    console.error(err);
    return new Response("Could not verify webhook call", { status: 400 });
  }

  // +++
  if (isThreadNotificationEvent(event)) {
    const emailData = await prepareThreadNotificationEmailAsHtml(
      liveblocks,
      event
    );
    let email;

    switch (emailData.type) {
      case "unreadMention": {
        email = `
        <div>
          <div>
            @${emailData.comment.author.id} at ${emailData.comment.createdAt}
          </div>
          <div>${emailData.comment.body}</div>
        </div>
      `;
        break;
      }

      case "unreadReplies": {
        email = `
        <div>
          ${emailData.comments
            .map(
              (comment) => `
                <div>
                  <div>
                    @${comment.author.id} at ${comment.createdAt}
                  </div>
                  <div>${comment.body}</div>
                </div>
              `
            )
            .join("")}
        </div>
      `;
        break;
      }
    }

    // Send your email
    // ...
  }
  // +++

  return new Response(null, { status: 200 });
}
```

<PropertiesList title="Returns">
  <PropertiesListItem
    name="value"
    type="ThreadNotificationEmailDataAsHtml | null"
  >
    Returns comment information, and a formatted HTML body, ready for use in emails. Returns `null` if there are no unread mentions or comments. The result has two formats depending on whether this notification is for a *single unread mention*, or for *multiple unread replies*:

    ```js title="Unread mention" isCollapsable isCollapsed
    {
      type: "unreadMention",
      roomId: "my-room-id",

      // An unread mention has just one comment
      comment: {
        id: "cm_asfs8f...",
        threadId: "th_sj30as..."
        createdAt: Date <Fri Dec 15 2023 14:15:22 GMT+0000 (Greenwich Mean Time)>,

        // The formatted comment, as an HTML string
        body: "<div>...</div>",

        author: {
          id: "aurélien@example.com",
          info: { /* Custom user info you have resolved */ },
        },
      },
    }
    ```

    <div className="-mt-2">

      ```js title="Unread replies" isCollapsable isCollapsed
      {
        type: "unreadReplies",
        roomId: "my-room-id",

        // Unread replies means multiple comments
        comments: [
          {
            id: "cm_asfs8f...",
            threadId: "th_sj30as..."
            createdAt: Date <Fri Dec 15 2023 14:15:22 GMT+0000 (Greenwich Mean Time)>,

            // The formatted comment, as an HTML string
            body: "<div>...</div>",

            author: {
              id: "aurélien@example.com",
              info: { /* Custom user info you have resolved */ },
            },
          },

        // More comments
        //...
        ],
      }
      ```

    </div>

  </PropertiesListItem>
</PropertiesList>

<PropertiesList title="Arguments">
  <PropertiesListItem name="client" type="Liveblocks" required>
    A [`Liveblocks`](/docs/api-reference/liveblocks-node#Liveblocks-client)
    Node.js client.
  </PropertiesListItem>
  <PropertiesListItem name="event" type="ThreadNotificationEvent" required>
    An object passed from a webhook event, specifically the
    [`ThreadNotificationEvent`](/docs/platform/webhooks#Thread-notification).
    [Learn more about setting this up](#Setup).
  </PropertiesListItem>
  <PropertiesListItem name="options" type="object">
    A number of options to customize the format of the comments, adding user
    info, room info, and styles.
  </PropertiesListItem>
  <PropertiesListItem
    name="options.resolveUsers"
    detailedType='async? (args: ResolveUsersArgs) => (UserMeta["info"] | undefined)[] | undefined'
  >
    A function that resolves user information in
    [Comments](/docs/ready-made-features/comments). Return an array of
    `UserMeta["info"]` objects in the same order they arrived. Works similarly
    to the [resolver on the
    client](/docs/api-reference/liveblocks-react#LiveblocksProviderResolveUsers).
    [Learn more](#prepare-thread-notification-email-as-html-resolving-data).
  </PropertiesListItem>
  <PropertiesListItem
    name="options.resolveGroupsInfo"
    detailedType="async? (args: ResolveGroupsInfoArgs) => (GroupInfo | undefined)[] | undefined"
  >
    A function that resolves group information. Return an array of `GroupInfo`
    objects in the same order they arrived. Works similarly to the [resolver on
    the
    client](/docs/api-reference/liveblocks-react#LiveblocksProviderResolveGroupsInfo).
    [Learn more](#prepare-thread-notification-email-as-react-resolving-data).
  </PropertiesListItem>
  <PropertiesListItem
    name="options.resolveRoomInfo"
    detailedType="async? (args: ResolveRoomInfoArgs) => RoomInfo | undefined"
  >
    A function that resolves room information. Return a `RoomInfo` object, as
    matching your types. Works similarly to the [resolver on the
    client](/docs/api-reference/liveblocks-react#LiveblocksProviderResolveRoomsInfo)
    but for one room. [Learn
    more](#prepare-thread-notification-email-as-html-resolving-data).
  </PropertiesListItem>
  <PropertiesListItem name="options.styles" type="object">
    Pass CSS properties to style the different HTML elements in the comment
    bodies. Five elements can be styled: `paragraph`, `code`, `strong`, `link`,
    `mention`. [Learn
    more](#prepare-thread-notification-email-as-html-styling-elements).
  </PropertiesListItem>
  <PropertiesListItem name="options.styles.container" type="CSSProperties">
    Inline styles to apply to the comment body container.
  </PropertiesListItem>
  <PropertiesListItem name="options.styles.paragraph" type="CSSProperties">
    Inline styles to apply to the paragraph block.
  </PropertiesListItem>
  <PropertiesListItem name="options.styles.code" type="CSSProperties">
    Inline styles to apply to the code element.
  </PropertiesListItem>
  <PropertiesListItem name="options.styles.strong" type="CSSProperties">
    Inline styles to apply to the strong element.
  </PropertiesListItem>
  <PropertiesListItem name="options.styles.mention" type="CSSProperties">
    Inline styles to apply to the mention element.
  </PropertiesListItem>
  <PropertiesListItem name="options.styles.link" type="CSSProperties">
    Inline styles to apply to the link element.
  </PropertiesListItem>
</PropertiesList>

#### Resolving data [#prepare-thread-notification-email-as-html-resolving-data]

Similarly to on the client, you can resolve
[users](/docs/api-reference/liveblocks-react#LiveblocksProviderResolveUsers),
[group info](/docs/api-reference/liveblocks-react#LiveblocksProviderResolveGroupsInfo),
and
[room info](/docs/api-reference/liveblocks-react#LiveblocksProviderResolveRoomsInfo),
making it easier to render your emails. For example, you can resolve a user’s ID
into their name, and show their name in the email.

<Banner title="Resolving users and groups" type="info">
  When resolving users and groups, the function receives a list of IDs and you
  should return a list of objects of the same size, in the same order.
</Banner>

```tsx
const emailData = await prepareThreadNotificationEmailAsHtml(
  liveblocks,
  webhookEvent,
  {
    // +++
    resolveUsers: async ({ userIds }) => {
      const usersData = await __getUsersFromDB__(userIds);

      return usersData.map((userData) => ({
        name: userData.name, // "Nimesh"
        avatar: userData.avatar.src, // "https://..."
      }));
    },
    resolveGroupsInfo: async ({ groupIds }) => {
      const groupsData = await __getGroupsFromDB__(groupIds);

      return groupsData.map((groupData) => ({
        name: groupData.name, // "Engineering"
        avatar: groupData.avatar.src, // "https://..."
      }));
    },
    resolveRoomInfo({ roomId }) {
      return {
        name: roomId, // "my-room-name"
        url: `https://example.com/${roomId}`,
      };
    },
    // +++
  }
);

// { type: "unreadMention", comment: { ... }, ... }
console.log(emailData);

// { name: "Nimesh", avatar: "https://..." }
console.log(emailData.comment.author.info);

// { name: "my-room-name", url: "https://example.com/my-room-name" }
console.log(emailData.roomInfo);
```

#### Styling elements [#prepare-thread-notification-email-as-html-styling-elements]

Each element in the comment body can be styled with custom CSS properties, if
you would like to change the appearance. Five elements are available:
`paragraph`, `code`, `strong`, `mention`, `link`.

```tsx
const emailData = await prepareThreadNotificationEmailAsHtml(
  liveblocks,
  webhookEvent,
  {
    // +++
    styles: {
      paragraph: { margin: "12px 0" },

      mention: {
        fontWeight: "bold",
        color: "red",
      },

      link: {
        textDecoration: "underline",
      },
    },
    // +++
  }
);

// { type: "unreadMention", comment: { ... }, ... }
console.log(emailData);

// The elements in the comment body are now styled
console.log(emailData.comment.body);
```

## Text Mention notification emails [#text-mention-notification-emails]

These functions help you create emails to notify users when they have an _unread
mention_ in a [Text Editor](/docs/ready-made-features/text-editor) document. In
this case, a mention is not related to comments, but is instead an inline
mention inside the text editor itself. If the mention has not been read, the
functions fetch a text mention and its surrounding text, giving you more
context, and helping you style the mention content with either
[React](#prepare-text-mention-notification-email-as-react) or
[HTML](#prepare-text-mention-notification-email-as-html).

<Figure>
  <Image
    src="/assets/emails/new-text-mention-email.png"
    alt="An email showing a text mention in a text editor document"
    width={1126}
    height={470}
  />
</Figure>

<Banner>

This screenshot shows a ready-made template from our
[Text Editor + Resend](/examples/collaborative-text-editor-emails/nextjs-tiptap-emails-resend)
examples.

</Banner>

The functions helps to determine if the mention still exists in the document and
will indicate that there’s no email to send in this case. Currently, only
mentions in paragraph blocks create notifications, as there are limitations
around retrieving mentions in plugins.

### Limitations

Before you get started, there are some limitations with text mentions that you
should be aware of.

#### Mentions in plugins

If a user is mentioned in a plugin or extension, a text mention notification is
not sent. This is because Liveblocks doesn’t know the exact schema of your
editor and all its plugins, and we can’t extract the data correctly. This means
that _only mentions in paragraph blocks are sent_, and mentions in lists,
checkboxes, etc., are not, as they are all powered by plugins. We’re
investigating solutions for this, and we’d like to
[hear from you](/contact/support) if you have any thoughts.

#### Multiple Tiptap editors

Tiptap optionally allows you to
[render multiple editors per page](/docs/ready-made-features/text-editor/tiptap#Multiple-editors),
instead of just one. For now, these functions only support one editor per room,
but we’ll be looking to add support for more later.

#### BlockNote

This package does not yet support our
[collaborative BlockNote text editor](/docs/api-reference/liveblocks-react-blocknote)
integration. Support of BlockNote is planned for a future release and is
currently on our development roadmap. Users requiring BlockNote compatibility
should monitor package updates for this upcoming feature.

### prepareTextMentionNotificationEmailAsReact [#prepare-text-mention-notification-email-as-react]

Takes a
[text mention notification webhook event](/docs/platform/webhooks#TextMention-notification)
and returns an unread text mention with its surrounding text as React nodes. It
can also return `null` if the text mention does not exist anymore or has been
already been read. You can also
[resolve public data](#prepare-text-mention-notification-email-as-react-resolving-data)
and
[customize the components](#prepare-text-mention-notification-email-as-react-customizing-components).

```tsx
import { prepareTextMentionNotificationEmailAsReact } from "@liveblocks/emails";
import { isTextMentionNotificationEvent } from "@liveblocks/node";

// Get `liveblocks` and `event` (see "Setup" section)
// ...

if (isTextMentionNotificationEvent(event)) {
  // +++
  const emailData = await prepareTextMentionNotificationEmailAsReact(
    liveblocks,
    event
  );
  // +++

  const email = (
    <div>
      <div>
        @{emailData.mention.author.id} at {emailData.mention.createdAt}
      </div>
      <div>{emailData.mention.content}</div>
    </div>
  );
}

// Send your email
// ...
```

It’s designed to be used in a webhook event, which requires a
[`Liveblocks`](/docs/api-reference/liveblocks-node#Liveblocks-client) Node.js
client and a
[`WebhookHandler`](/docs/api-reference/liveblocks-node#WebhookHandler). Check
for the correct webhook event using
[`isTextMentionNotificationEvent`](/docs/api-reference/liveblocks-node#isTextMentionNotificationEvent)
before running the function, such as in this Next.js route handler.

```tsx title="Full Next.js route handler example" isCollapsed isCollapsable
import {
  isTextMentionNotificationEvent,
  WebhookHandler,
} from "@liveblocks/node";
import { Liveblocks } from "@liveblocks/node";
// +++
import { prepareTextMentionNotificationEmailAsReact } from "@liveblocks/emails";
// +++

const liveblocks = new Liveblocks({
  secret: "{{SECRET_KEY}}",
});

const webhookHandler = new WebhookHandler(
  process.env.LIVEBLOCKS_WEBHOOK_SECRET_KEY as string
);

export async function POST(request: Request) {
  const body = await request.json();
  const headers = request.headers;

  // Verify if this is a real webhook request
  let event;
  try {
    event = webhookHandler.verifyRequest({
      headers: headers,
      rawBody: JSON.stringify(body),
    });
  } catch (err) {
    console.error(err);
    return new Response("Could not verify webhook call", { status: 400 });
  }

  // +++
  if (isTextMentionNotificationEvent(event)) {
    const emailData = await prepareTextMentionNotificationEmailAsReact(
      liveblocks,
      event
    );

    const email = (
      <div>
        <div>
          @{emailData.mention.author.id} at {emailData.mention.createdAt}
        </div>
        <div>{emailData.mention.content}</div>
      </div>
    );

    // Send your email
    // ...
  }
  // +++

  return new Response(null, { status: 200 });
}
```

<PropertiesList title="Returns">
  <PropertiesListItem
    name="value"
    type="TextMentionNotificationEmailDataAsReact | null"
  >
    Returns text mention information, and a formatted React content ready for
    use in emails. Returns `null` if the text mention does not exist anymore or
    has been already been read.

    ```js title="Unread text mention"
    {
      roomInfo: {
        name: "my room name"
        url: "https://my-room-url.io"
      },
      mention: {
        kind: "user",
        textMentionId: "in_oiujhdg...",
        id: "user-0",
        roomId: "my-room-id",
        createdAt: Date <Fri Dec 15 2023 14:15:22 GMT+0000 (Greenwich Mean Time)>,

        // The formatted content, pass it to React `children`
        content: { /* ... */}

        author: {
          id: "vincent@example.com",
          info: { /* Custom user info you have resolved */ }
        }
      },
    }
    ```

  </PropertiesListItem>
</PropertiesList>

<PropertiesList title="Arguments">
  <PropertiesListItem name="client" type="Liveblocks" required>
    A [`Liveblocks`](/docs/api-reference/liveblocks-node#Liveblocks-client)
    Node.js client.
  </PropertiesListItem>
  <PropertiesListItem name="event" type="TextMentionNotificationEvent" required>
    An object passed from a webhook event, specifically the
    [`TextMentionNotificationEvent`](/docs/platform/webhooks#TextMention-notification).
    [Learn more about setting this up](#Setup).
  </PropertiesListItem>
  <PropertiesListItem name="options" type="object">
    A number of options to customize the format of the content, adding user
    info, room info, and styles.
  </PropertiesListItem>
  <PropertiesListItem
    name="options.resolveUsers"
    detailedType='async? (args: ResolveUsersArgs) => (UserMeta["info"] | undefined)[] | undefined'
  >
    A function that resolves user information in
    [Comments](/docs/ready-made-features/comments). Return an array of
    `UserMeta["info"]` objects in the same order they arrived. Works similarly
    to the [resolver on the
    client](/docs/ready-made-features/text-editor/lexical#Users-and-mentions).
    [Learn
    more](#prepare-text-mention-notification-email-as-react-resolving-data).
  </PropertiesListItem>
  <PropertiesListItem
    name="options.resolveGroupsInfo"
    detailedType="async? (args: ResolveGroupsInfoArgs) => (GroupInfo | undefined)[] | undefined"
  >
    A function that resolves group information. Return an array of `GroupInfo`
    objects in the same order they arrived. Works similarly to the [resolver on
    the
    client](/docs/api-reference/liveblocks-react#LiveblocksProviderResolveGroupsInfo).
    [Learn more](#prepare-thread-notification-email-as-react-resolving-data).
  </PropertiesListItem>
  <PropertiesListItem
    name="options.resolveRoomInfo"
    detailedType="async? (args: ResolveRoomInfoArgs) => RoomInfo | undefined"
  >
    A function that resolves room information. Return a `RoomInfo` object, as
    matching your types. Works similarly to the [resolver on the
    client](/docs/api-reference/liveblocks-react#LiveblocksProviderResolveRoomsInfo)
    but for one room. [Learn
    more](#prepare-text-mention-notification-email-as-react-resolving-data).
  </PropertiesListItem>
  <PropertiesListItem name="options.components" type="object">
    Pass different React components to customize the elements in the mention
    content. Three components can be passed to the object: `Container`, `Text`,
    and `Mention`. [Learn
    more](#prepare-text-mention-notification-email-as-react-customizing-components).
  </PropertiesListItem>
  <PropertiesListItem
    name="options.components.Container"
    type="({ children: ReactNode }) => ReactNode"
  >
    The mention and its surrounding text container
  </PropertiesListItem>
  <PropertiesListItem
    name="options.components.Text"
    type="({ children: ReactNode }) => ReactNode"
  >
    The text element.
  </PropertiesListItem>
  <PropertiesListItem
    name="options.components.Mention"
    detailedType={`({ element: LiveblocksTextEditorMentionNode, user?: UserInfo["info"], group?: GroupInfo }) => ReactNode`}
  >
    The mention element.
  </PropertiesListItem>
</PropertiesList>

#### Resolving data [#prepare-text-mention-notification-email-as-react-resolving-data]

Similarly to on the client, you can resolve
[users](/docs/api-reference/liveblocks-react#LiveblocksProviderResolveUsers),
[group info](/docs/api-reference/liveblocks-react#LiveblocksProviderResolveGroupsInfo),
and
[room info](/docs/api-reference/liveblocks-react#LiveblocksProviderResolveRoomsInfo),
making it easier to render your emails. For example, you can resolve a user’s ID
into their name, and show their name in the email.

<Banner title="Resolving users and groups" type="info">
  When resolving users and groups, the function receives a list of IDs and you
  should return a list of objects of the same size, in the same order.
</Banner>

```tsx
const emailData = await prepareTextMentionNotificationEmailAsReact(
  liveblocks,
  webhookEvent,
  {
    // +++
    resolveUsers: async ({ userIds }) => {
      const usersData = await __getUsersFromDB__(userIds);

      return usersData.map((userData) => ({
        name: userData.name, // "Nimesh"
        avatar: userData.avatar.src, // "https://..."
      }));
    },
    resolveGroupsInfo: async ({ groupIds }) => {
      const groupsData = await __getGroupsFromDB__(groupIds);

      return groupsData.map((groupData) => ({
        name: groupData.name, // "Engineering"
        avatar: groupData.avatar.src, // "https://..."
      }));
    },
    resolveRoomInfo({ roomId }) {
      return {
        name: roomId, // "my-room-name"
        url: `https://example.com/${roomId}`,
      };
    },
    // +++
  }
);

// { mention: { ... }, ... }
console.log(emailData);

// { name: "Nimesh", avatar: "https://..." }
console.log(emailData.mention.author.info);

// { name: "my-room-name", url: "https://example.com/my-room-name" }
console.log(emailData.roomInfo);
```

#### Customizing components [#prepare-text-mention-notification-email-as-react-customizing-components]

Each React component in the mention context can be replaced with a custom React
component, if you wish to apply different styles. Three components are
available: `Container`, `Text`, and `Mention`.

```tsx
const emailData = await prepareThreadNotificationEmailAsReact(
  liveblocks,
  webhookEvent,
  {
    // +++
    components: {
      // `react-email` components are supported
      Container: ({ children }) => <Section>{children}</Section>,

      Text: ({ children }) => (
        <Text className="text-sm text-black m-0 mb-4">{children}</Text>
      ),

      // `user` and `group` are the optional data returned from `resolveUsers` and `resolveGroupsInfo`
      Mention: ({ element, user, group }) => (
        <span style={{ color: "red" }}>
          @{user?.name ?? group?.name ?? element.id}
        </span>
      ),
    },
    // +++
  }
);

// { mention: { ... }, ... }
console.log(emailData);

// The components are now used in this React content
console.log(emailData.mention.content);
``;
```

### prepareTextMentionNotificationEmailAsHtml [#prepare-text-mention-notification-email-as-html]

Takes a
[text mention notification webhook event](/docs/platform/webhooks#TextMention-notification)
and returns an unread text mention with its surrounding text as an HTML string.
It can also return `null` if the text mention does not exist anymore or has been
already been read. You can also
[resolve public data](#prepare-text-mention-notification-email-as-html-resolving-data)
and
[customize the styles](#prepare-text-mention-notification-email-as-html-styling-elements).

```tsx
import { prepareTextMentionNotificationEmailAsHtml } from "@liveblocks/emails";
import { isTextMentionNotificationEvent } from "@liveblocks/node";

// Get `liveblocks` and `event` (see "Setup" section)
// ...

if (isTextMentionNotificationEvent(event)) {
  // +++
  const emailData = await prepareTextMentionNotificationEmailAsHtml(
    liveblocks,
    event
  );
  // +++

  const email = (
    <div>
      <div>
        @{emailData.mention.author.id} at {emailData.mention.createdAt}
      </div>
      <div>{emailData.mention.content}</div>
    </div>
  );
}

// Send your email
// ...
```

It’s designed to be used in a webhook event, which requires a
[`Liveblocks`](/docs/api-reference/liveblocks-node#Liveblocks-client) Node.js
client and a
[`WebhookHandler`](/docs/api-reference/liveblocks-node#WebhookHandler). Check
for the correct webhook event using
[`isTextMentionNotificationEvent`](/docs/api-reference/liveblocks-node#isTextMentionNotificationEvent)
before running the function, such as in this Next.js route handler.

```tsx title="Full Next.js route handler example" isCollapsed isCollapsable
import {
  isTextMentionNotificationEvent,
  WebhookHandler,
} from "@liveblocks/node";
import { Liveblocks } from "@liveblocks/node";
// +++
import { prepareTextMentionNotificationEmailAsHtml } from "@liveblocks/emails";
// +++

const liveblocks = new Liveblocks({
  secret: "{{SECRET_KEY}}",
});

const webhookHandler = new WebhookHandler(
  process.env.LIVEBLOCKS_WEBHOOK_SECRET_KEY as string
);

export async function POST(request: Request) {
  const body = await request.json();
  const headers = request.headers;

  // Verify if this is a real webhook request
  let event;
  try {
    event = webhookHandler.verifyRequest({
      headers: headers,
      rawBody: JSON.stringify(body),
    });
  } catch (err) {
    console.error(err);
    return new Response("Could not verify webhook call", { status: 400 });
  }

  // +++
  if (isTextMentionNotificationEvent(event)) {
    const emailData = await prepareTextMentionNotificationEmailAsHtml(
      liveblocks,
      event
    );

    const email = `
    <div>
      <div>
        @${emailData.mention.author.id} at ${emailData.mention.createdAt}
      </div>
      <div>${emailData.mention.content}</div>
    </div>
    `;

    // Send your email
    // ...
  }
  // +++

  return new Response(null, { status: 200 });
}
```

<PropertiesList title="Returns">
  <PropertiesListItem
    name="value"
    type="TextMentionNotificationEmailDataAsHtml | null"
  >
    Returns text mention information, and formatted HTML content ready for
    use in emails. Returns `null` if the text mention does not exist anymore or
    has already been read.

    ```js title="Unread text mention"
    {
      roomInfo: {
        name: "my room name"
        url: "https://my-room-url.io"
      },
      mention: {
        kind: "user",
        textMentionId: "in_oiujhdg...",
        id: "user-0",
        roomId: "my-room-id",
        createdAt: Date <Fri Dec 15 2023 14:15:22 GMT+0000 (Greenwich Mean Time)>,

        // The formatted content, as an HTML string
        content: { /* ... */}

        author: {
          id: "vincent@example.com",
          info: { /* Custom user info you have resolved */ }
        }
      },
    }
    ```

  </PropertiesListItem>
</PropertiesList>

<PropertiesList title="Arguments">
  <PropertiesListItem name="client" type="Liveblocks" required>
    A [`Liveblocks`](/docs/api-reference/liveblocks-node#Liveblocks-client)
    Node.js client.
  </PropertiesListItem>
  <PropertiesListItem name="event" type="TextMentionNotificationEvent" required>
    An object passed from a webhook event, specifically the
    [`TextMentionNotificationEvent`](/docs/platform/webhooks#TextMention-notification).
    [Learn more about setting this up](#Setup).
  </PropertiesListItem>
  <PropertiesListItem name="options" type="object">
    A number of options to customize the format of the content, adding user
    info, room info, and styles.
  </PropertiesListItem>
  <PropertiesListItem
    name="options.resolveUsers"
    detailedType='async? (args: ResolveUsersArgs) => (UserMeta["info"] | undefined)[] | undefined'
  >
    A function that resolves user information in
    [Comments](/docs/ready-made-features/comments). Return an array of
    `UserMeta["info"]` objects in the same order they arrived. Works similarly
    to the [resolver on the
    client](/docs/ready-made-features/text-editor/lexical#Users-and-mentions).
    [Learn
    more](#prepare-text-mention-notification-email-as-html-resolving-data).
  </PropertiesListItem>
  <PropertiesListItem
    name="options.resolveGroupsInfo"
    detailedType="async? (args: ResolveGroupsInfoArgs) => (GroupInfo | undefined)[] | undefined"
  >
    A function that resolves group information. Return an array of `GroupInfo`
    objects in the same order they arrived. Works similarly to the [resolver on
    the
    client](/docs/api-reference/liveblocks-react#LiveblocksProviderResolveGroupsInfo).
    [Learn more](#prepare-thread-notification-email-as-react-resolving-data).
  </PropertiesListItem>
  <PropertiesListItem
    name="options.resolveRoomInfo"
    detailedType="async? (args: ResolveRoomInfoArgs) => RoomInfo | undefined"
  >
    A function that resolves room information. Return a `RoomInfo` object, as
    matching your types. Works similarly to the [resolver on the
    client](/docs/api-reference/liveblocks-react#LiveblocksProviderResolveRoomsInfo)
    but for one room. [Learn
    more](#prepare-text-mention-notification-email-as-html-resolving-data).
  </PropertiesListItem>
  <PropertiesListItem name="options.styles" type="object">
    Pass CSS properties to style the different HTML elements in the mention
    content. Four elements can be styled: `paragraph`, `code`, `strong`,
    `mention`, and, `link`. [Learn
    more](#prepare-text-mention-notification-email-as-html-styling-elements).
  </PropertiesListItem>
  <PropertiesListItem name="options.styles.paragraph" type="CSSProperties">
    Inline styles to apply to the mention container container. It's a `<div />`
    element under the hood.
  </PropertiesListItem>
  <PropertiesListItem name="options.styles.code" type="CSSProperties">
    Inline styles to apply to the code element.
  </PropertiesListItem>
  <PropertiesListItem name="options.styles.strong" type="CSSProperties">
    Inline styles to apply to the strong element.
  </PropertiesListItem>
  <PropertiesListItem name="options.styles.mention" type="CSSProperties">
    Inline styles to apply to the mention element.
  </PropertiesListItem>
  <PropertiesListItem name="options.styles.link" type="CSSProperties">
    Inline styles to apply to the link element.
  </PropertiesListItem>
</PropertiesList>

#### Resolving data [#prepare-text-mention-notification-email-as-html-resolving-data]

Similarly to on the client, you can resolve
[users](/docs/api-reference/liveblocks-react#LiveblocksProviderResolveUsers),
[group info](/docs/api-reference/liveblocks-react#LiveblocksProviderResolveGroupsInfo),
and
[room info](/docs/api-reference/liveblocks-react#LiveblocksProviderResolveRoomsInfo),
making it easier to render your emails. For example, you can resolve a user’s ID
into their name, and show their name in the email.

<Banner title="Resolving users and groups" type="info">
  When resolving users and groups, the function receives a list of IDs and you
  should return a list of objects of the same size, in the same order.
</Banner>

```tsx
const emailData = await prepareTextMentionNotificationEmailAsHtml(
  liveblocks,
  webhookEvent,
  {
    // +++
    resolveUsers: async ({ userIds }) => {
      const usersData = await __getUsersFromDB__(userIds);

      return usersData.map((userData) => ({
        name: userData.name, // "Nimesh"
        avatar: userData.avatar.src, // "https://..."
      }));
    },
    resolveGroupsInfo: async ({ groupIds }) => {
      const groupsData = await __getGroupsFromDB__(groupIds);

      return groupsData.map((groupData) => ({
        name: groupData.name, // "Engineering"
        avatar: groupData.avatar.src, // "https://..."
      }));
    },
    resolveRoomInfo({ roomId }) {
      return {
        name: roomId, // "my-room-name"
        url: `https://example.com/${roomId}`,
      };
    },
    // +++
  }
);

// { mention: { ... }, ... }
console.log(emailData);

// { name: "Nimesh", avatar: "https://..." }
console.log(emailData.mention.author.info);

// { name: "my-room-name", url: "https://example.com/my-room-name" }
console.log(emailData.roomInfo);
```

#### Styling elements [#prepare-text-mention-notification-email-as-html-styling-elements]

Each element in the comment body can be styled with custom CSS properties, if
you would like to change the appearance. Five elements are available:
`paragraph`, `code`, `strong`, `mention`, and `link`.

```tsx
const emailData = await prepareTextMentionNotificationEmailAsHtml(
  liveblocks,
  webhookEvent,
  {
    // +++
    styles: {
      paragraph: { margin: "12px 0" },

      mention: {
        fontWeight: "bold",
        color: "red",
      },
    },
    // +++
  }
);

// { mention: { ... }, ... }
console.log(emailData);

// The elements in the mention content are now styled
console.log(emailData.mention.content);
```
