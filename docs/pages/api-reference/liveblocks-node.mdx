---
meta:
  title: "@liveblocks/node"
  parentTitle: "API Reference"
  description: "API Reference for the @liveblocks/node package"
alwaysShowAllNavigationLevels: false
---

Note that this library offers Node.js APIs only. It’s only supposed to be used
in your back end.

The main APIs offered by `@liveblocks/node`:

1. [The `Liveblocks` client](#Liveblocks-class), which is a Node.js client for
   safely authenticating your clients with Liveblocks.
1. [The `WebhookHandler` class](#WebhookHandler), which helps you implement
   webhook handlers.
1. **Deprecated.** [The `authorize` function](#authorize), which helps you
   implement single-room token based authentication in your back end.

## The `Liveblocks` client [#Liveblocks-class]

The `Liveblocks` class is new in 1.2, and offers access to our REST API.

```ts showLineNumbers={false}
const liveblocks = new Liveblocks({
  // Replace this key with your secret key provided at https://liveblocks.io/dashboard/apikeys
  secret: "{{SECRET_KEY}}",
});
```

To authorize your users with Liveblocks, you have the choice between two
different APIs.

- [`Liveblocks.prepareSession`](#access-tokens); or
- [`Liveblocks.identifyUser`](#id-tokens) API.

### `Liveblocks.prepareSession` [#access-tokens]

The purpose of this API is to help you implement your custom authentication back
end, i.e. the "server" part of this diagram. You use the
`liveblocks.prepareSession()` API if you want to issue
[access tokens](/docs/rooms/permissions/access-token) from your back end.

<Banner title="What are access tokens?">
  Access tokens are like issuing a “hotel room key card” from a hotel’s front
  desk (your back end). Any client with that key card can enter any room that
  the card gives access to. It’s easy to give out those key cards right from
  your back end.
</Banner>

<Figure>
  <Image
    src="/assets/access-token-auth-diagram.png"
    alt="Auth diagram"
    width={768}
    height={576}
  />
</Figure>

To implement your back end, follow these steps:

<Steps>
  <Step>
    <StepTitle>Create a `Session`</StepTitle>

    <StepContent>
      ```ts showLineNumbers={false}
      const session = liveblocks.prepareSession(
        "marie@example.com",   // Required, user ID from your DB
        {
          // Optional, custom static metadata for the session
          userInfo: {
            name: "Marie",
            avatar: "https://example.com/avatar/marie.jpg",
          },
        }
      );
      ```

      The `userId` (required) is an identifier to uniquely identifies
      your user with Liveblocks. This value will be used when counting
      unique MAUs in your Liveblocks dashboard.

      The `userInfo` (optional) is any custom JSON value, which can be
      attached to static metadata to this user’s session. This will be
      publicly visible to all other people in the room. Useful for
      metadata like the user’s full name, or their avatar URL.

      </StepContent>

    </Step>

    <Step>
      <StepTitle>Decide which permissions to allow this session</StepTitle>
      <StepContent>
        ```ts showLineNumbers={false}
        session.allow("my-room-1", session.FULL_ACCESS);
        session.allow("my-room-2", session.FULL_ACCESS);
        session.allow("my-room-3", session.FULL_ACCESS);
        session.allow("my-team:*", session.READ_ACCESS);
        ```

        <Banner title="Be diligent" type="warning">
          You’re specifying what’s going to be allowed so be careful what
          permissions you’re giving your users. You’re responsible for this
          part.
        </Banner>
      </StepContent>
    </Step>

  <Step lastStep>
    <StepTitle>Authorize the session</StepTitle>
    <StepContent>
      Finally, authorize the session. This step makes the HTTP call to the
      Liveblocks servers. Liveblocks will return a signed **access token** that
      you can return to your client.

      ```ts showLineNumbers={false}
      // Requests the Liveblocks servers to authorize this session
      const { body, status } = await session.authorize();
      return new Response(body, { status });
      ```
    </StepContent>

    </Step>

</Steps>

#### Full example using Next.js

```ts
import { Liveblocks } from "@liveblocks/node";

const liveblocks = new Liveblocks({
  // Replace this key with your secret key provided at https://liveblocks.io/dashboard/apikeys
  secret: "{{SECRET_KEY}}",
});

export async function POST(request: Request) {
  /**
   * Implement your own security here.
   *
   * It's your responsibility to ensure that the caller of this endpoint
   * is a valid user by validating the cookies or authentication headers
   * and that it has access to the requested room.
   */

  // Get the current user from your database
  const user = __getUserFromDB__(request);

  // Start an auth session inside your endpoint
  const session = liveblocks.prepareSession(
    user.id,
    { userInfo: user.metadata } // Optional
  );

  // Implement your own security, and give the user access to the room
  const { room } = await request.json();
  if (room && __shouldUserHaveAccess__(user, room)) {
    session.allow(room, session.FULL_ACCESS);
  }

  // Retrieve a token from the Liveblocks servers and pass it to the
  // requesting client
  const { body, status } = await session.authorize();
  return new Response(body, { status });
}
```

#### Full example using Express.js

```ts
const express = require("express");
const { Liveblocks } = require("@liveblocks/node");

const liveblocks = new Liveblocks({
  // Replace this key with your secret key provided at https://liveblocks.io/dashboard/apikeys
  secret: "{{SECRET_KEY}}",
});

const app = express();

app.use(express.json());

app.post("/api/liveblocks-auth", async (req, res) => {
  /**
   * Implement your own security here.
   *
   * It's your responsibility to ensure that the caller of this endpoint
   * is a valid user by validating the cookies or authentication headers
   * and that it has access to the requested room.
   */
  const user = __getUserFromDB__(req);

  const session = await liveblocks.prepareSession("123", {
    userInfo: {
      name: user.fullName,
      color: user.favoriteColor,
    },
  });

  // Check if the user should have access to the room requested by the
  // client. If so, allow it.
  if (__shouldUserHaveAccess__(user, req.body.room)) {
    session.allow(req.body.room, session.FULL_ACCESS);
  }

  // Finally, get a token from the Liveblocks servers and pass it to the
  // requesting client
  const { status, body } = await session.authorize();
  return res.status(status).end(body);
});
```

### `Liveblocks.identifyUser` [#id-tokens]

The purpose of this API is to help you implement your custom authentication back
end, i.e. the "server" part of this diagram. You use the
`liveblocks.identifyUser()` API if you want to issue
[ID tokens](/docs/rooms/permissions/id-token) from your back end. An ID token
does not grant any permissions in the token directly. Instead, it only securely
identifies your user, and then uses any permissions set via the [Permissions
REST API][] to decide whether to allow the user on a room-by-room basis.

Use this approach if you’d like Liveblocks to be the source of truth for your
user’s permissions.

<Banner title="What are ID tokens?">
  Issuing identity tokens is like issuing "membership cards". Anyone with such
  membership card can try to enter a room, but their permissions will be checked
  at the door every time. The Liveblocks servers perform this authorization, so
  your permissions need to be set upfront using the Liveblocks REST API.
</Banner>

<Figure>
  <Image
    src="/assets/id-token-auth-diagram.png"
    alt="Auth diagram"
    width={768}
    height={576}
  />
</Figure>

Implement your back end endpoint as follows:

```ts showLineNumbers={false}
const { body, status } = await liveblocks.identifyUser(
  {
    userId: "marie@example.com", // Required, user ID from your DB
    groupIds: ["marketing", "engineering"],
  },

  // Optional
  {
    userInfo: {
      name: "Marie",
      avatar: "https://example.com/avatar/marie.jpg",
    },
  }
);

return new Response(body, { status });
```

The `userId` (required) is an identifier to uniquely identifies your user with
Liveblocks. This value will be used when counting unique MAUs in your Liveblocks
dashboard. You can refer to these user IDs in the [Permissions REST API][] when
assigning group permissions.

The `groupIds` (optional) can be used to specify which groups this user belongs
to. These are arbitrary identifiers that make sense to your app, and that you
can refer to in the [Permissions REST API][] when assigning group permissions.

The `userInfo` (optional) is any custom JSON value, which you can use to attach
static metadata to this user’s session. This will be publicly visible to all
other people in the room. Useful for metadata like the user’s full name, or
their avatar URL.

#### Full example using Next.js

```ts
import { Liveblocks } from "@liveblocks/node";

const liveblocks = new Liveblocks({
  // Replace this key with your secret key provided at https://liveblocks.io/dashboard/apikeys
  secret: "{{SECRET_KEY}}",
});

export default async function auth(req, res) {
  /**
   * Implement your own security here.
   *
   * It's your responsibility to ensure that the caller of this endpoint
   * is a valid user by validating the cookies or authentication headers
   * and that it has access to the requested room.
   */

  // Get the current user from your database
  const user = __getUserFromDB__(req);

  // Create an ID token for the user
  const { body, status } = await liveblocks.identifyUser(user.id, {
    userInfo: {
      name: user.fullName,
      color: user.favoriteColor,
    },
  });

  return new Response(body, { status });
}
```

#### Full example using Express.js

```ts
const express = require("express");
const { Liveblocks } = require("@liveblocks/node");

const liveblocks = new Liveblocks({
  // Replace this key with your secret key provided at https://liveblocks.io/dashboard/apikeys
  secret: "{{SECRET_KEY}}",
});

const app = express();

app.use(express.json());

app.post("/api/liveblocks-auth", async (req, res) => {
  /**
   * Implement your own security here.
   *
   * It's your responsibility to ensure that the caller of this endpoint
   * is a valid user by validating the cookies or authentication headers
   * and that it has access to the requested room.
   */

  // Get the current user from your database
  const user = __getUserFromDB__(req);

  const { status, body } = await liveblocks.identifyUser(user.id, {
    userInfo: {
      name: user.fullName,
      color: user.favoriteColor,
    },
  });

  return res.status(status).end(body);
});
```

---

## WebhookHandler [#WebhookHandler]

<Banner title="Need help implementing webhooks?">

Read the [Webhooks guide](/docs/platform/webhooks) to learn how to use them
within your product, allowing you to react to Liveblocks events as they happen.

</Banner>

The `WebhookHandler` class is a helper to handle webhook requests from
Liveblocks.

It’s initialized with a signing secret that you can find in your project’s
webhook page.

```js
const webhookHandler = new WebhookHandler(process.env.WEBHOOK_SECRET);
```

### verifyRequest [#verifyRequest]

Verifies the request and returns the event.

```js
const event = webhookHandler.verifyRequest({
  headers: req.headers,
  rawBody: req.body,
});
```

#### Full example using Next.js [#webhook-example]

```js
import { WebhookHandler } from "@liveblocks/node";

// Will fail if not properly initialized with a secret
// Obtained from the Webhooks section of your project dashboard
// https://liveblocks.io/dashboard
const webhookHandler = new WebhookHandler(process.env.WEBHOOK_SECRET);

export function POST(request) {
  try {
    const event = webhookHandler.verifyRequest({
      headers: req.headers,
      rawBody: req.body,
    });

    // Handle `WebhookEvent`

    if (event.type === "storageUpdated") {
      // Handle `StorageUpdatedEvent`
    } else if (event.type === "userEntered") {
      // Handle `UserEnteredEvent`
    } else if (event.type === "userLeft") {
      // Handle `UserLeftEvent`
    }
  } catch (error) {
    console.error(error);
    return new Response(error, { status: 400 });
  }
}
```

---

## authorize (deprecated) [#authorize]

<Banner title="Deprecated" type="error">
  For now, it’s still supported, but this way of authorizing will eventually get
  deprecated.
</Banner>

The purpose of `authorize()` was to help you implement your custom
authentication back end. It generates old-style single-room tokens.

Please refer to [our upgrade guide](/docs/platform/upgrading/1.2) if you're
using the `authorize` function in your back end. You should adopt
[`Liveblocks.prepareSession`](#access-tokens) or
[`Liveblocks.identifyUser`](#id-tokens) APIs instead.

[`room.getothers`]: /docs/api-reference/liveblocks-client#Room.getOthers
[Permissions REST API]: /docs/rooms/permissions/id-token
