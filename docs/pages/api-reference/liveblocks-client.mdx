---
meta:
  title: "@liveblocks/client"
  parentTitle: "API Reference"
  description: "API Reference for the @liveblocks/client package"
alwaysShowAllNavigationLevels: false
---

`@liveblocks/client` provides you with JavaScript bindings for our real-time
collaboration APIs, built on top of WebSockets. Read our
[getting started](/docs/get-started) guides to learn more.

## createClient

Creates a [client](#Client) that allows you to connect to Liveblocks servers.

```tsx
import { createClient } from "@liveblocks/client";

const client = createClient({
  authEndpoint: "/api/liveblocks-auth",

  // Other options
  // ...
});
```

```tsx title="Every createClient option" isCollapsable isCollapsed
import { createClient } from "@liveblocks/client";

const client = createClient({
  // Connect with authEndpoint
  authEndpoint: "/api/liveblocks-auth",

  // Alternatively, use an authEndpoint callback
  // authEndpoint: async (room) => {
  //   const response = await fetch("/api/liveblocks-auth", {
  //   method: "POST",
  //   headers: {
  //     Authentication: "<your own headers here>",
  //     "Content-Type": "application/json",
  //   },
  //   body: JSON.stringify({ room }),
  // });
  // return await response.json();
  // },

  // Alternatively, use a public key
  // publicApiKey: "pk_...",

  // Throttle time (ms) between WebSocket updates
  throttle: 100,

  // Throw lost-connection event after 5 seconds offline
  lostConnectionTimeout: 5000,

  // Disconnect users after X (ms) of inactivity, disabled by default
  backgroundKeepAliveTimeout: undefined,

  // Resolve user info for Comments and Notifications
  resolveUsers: async ({ userIds }) => {
    const usersData = await __getUsersFromDB__(userIds);

    return usersData.map((userData) => ({
      name: userData.name,
      avatar: userData.avatar.src,
    }));
  },

  // Resolve room info for Notifications
  resolveRoomsInfo: async ({ roomIds }) => {
    const documentsData = await __getDocumentsFromDB__(roomIds);

    return documentsData.map((documentData) => ({
      name: documentData.name,
      // url: documentData.url,
    }));
  },

  // Resolve mention suggestions for Comments
  resolveMentionSuggestions: async ({ text, roomId }) => {
    const workspaceUsers = await __getWorkspaceUsersFromDB__(roomId);

    if (!text) {
      // Show all workspace users by default
      return __getUserIds__(workspaceUsers);
    } else {
      const matchingUsers = __findUsers__(workspaceUsers, text);
      return __getUserIds__(matchingUsers);
    }
  },

  // Polyfill options for non-browser environments
  polyfills: {
    // atob,
    // fetch,
    // WebSocket,
  },
});
```

### Returns

<PropertiesList>
  <PropertiesListItem name="client" type="Client">
    Returns a [Client](#Client), used for connecting to Liveblocks.
  </PropertiesListItem>
</PropertiesList>

### Options

<PropertiesList>
  <PropertiesListItem
    name="authEndpoint"
    detailedType="string | async ((room?: string) => CustomAuthenticationResult)"
  >
    The URL of your authentication endpoint as a string, or an async callback
    function that returns a Liveblocks token result. Either `authEndpoint` or
    `publicApikey` are required. Learn more about [using a URL
    string](#createClientAuthEndpoint) and [using a
    callback](#createClientCallback).
  </PropertiesListItem>
  <PropertiesListItem name="publicApiKey" type="string">
    The public API key taken from your project‚Äôs
    [dashboard](/dashboard/apikeys). Generally not recommended for production
    use. Either `authEndpoint` or `publicApikey` are required. [Learn
    more](#createClientPublicKey).
  </PropertiesListItem>
  <PropertiesListItem name="throttle" type="number" defaultValue="100">
    The throttle time between WebSocket messages in milliseconds, a number
    between `16` and `1000` is allowed. Using `16` means your app will update 60
    times per second. [Learn more](#createClientThrottle).
  </PropertiesListItem>
  <PropertiesListItem
    name="lostConnectionTimeout"
    type="number"
    defaultValue="5000"
  >
    After a user disconnects, the time in milliseconds before a
    [`"lost-connection"`](/docs/api-reference/liveblocks-client#Room.subscribe.lost-connection)
    event is fired. [Learn more](#createClientLostConnectionTimeout).
  </PropertiesListItem>
  <PropertiesListItem name="backgroundKeepAliveTimeout" type="number">
    The time before an inactive WebSocket connection is disconnected. This is
    disabled by default, but setting a number will activate it. [Learn
    more](#createClientBackgroundKeepAliveTimeout).
  </PropertiesListItem>
  <PropertiesListItem
    name="resolveUsers"
    detailedType='async? (args: ResolveUsersArgs) => (TUserMeta["info"] | undefined)[] | undefined'
  >
    A function that resolves user information in
    [Comments](/docs/products/comments). Return an array of `TUserMeta["info"]`
    objects in the same order they arrived. [Learn
    more](#createClientResolveUsers).
  </PropertiesListItem>
  <PropertiesListItem
    name="resolveRoomsInfo"
    detailedType="async? (args: ResolveRoomsInfoArgs) => (RoomInfo | undefined)[] | undefined"
  >
    A function that resolves room information in
    [Comments](/docs/products/comments). Return an array of `RoomInfo` objects
    in the same order they arrived. [Learn more](#createClientResolveRoomsInfo).
  </PropertiesListItem>
  <PropertiesListItem
    name="resolveMentionSuggestions"
    detailedType="async? (args: ResolveMentionSuggestionsArgs) => string[]"
  >
    A function that resolves mention suggestions in
    [Comments](/docs/products/comments). Return an array of user IDs. [Learn
    more](#createClientResolveMentionSuggestions).
  </PropertiesListItem>
  <PropertiesListItem name="polyfills" type="Polyfills">
    Place polyfills for `atob`, `fetch`, and `WebSocket` inside here. Useful
    when using a non-browser environment, such as [Node.js](#createClientNode)
    or [React Native](#createClientReactNative).
  </PropertiesListItem>
  <PropertiesListItem
    name="unstable_fallbackToHTTP"
    type="boolean"
    defaultValue="false"
  >
    Automatically fall back to HTTP when a message is too large for WebSockets.
  </PropertiesListItem>
  <PropertiesListItem
    name="unstable_streamData"
    type="boolean"
    defaultValue="false"
  >
    help???
  </PropertiesListItem>
</PropertiesList>

### createClient with public key [#createClientPublicKey]

When creating a client with a public key, you don‚Äôt need to set up an
authorization endpoint. We only recommend using a public key when prototyping,
or on public landing pages, as it makes it possible for end users to access any
room‚Äôs data. You should instead use an
[auth endpoint](#createClientAuthEndpoint).

```ts
import { createClient } from "@liveblocks/client";

const client = createClient({
  publicApiKey: "{{PUBLIC_KEY}}",
});
```

### createClient with auth endpoint [#createClientAuthEndpoint]

If you are not using a public key, you need to set up your own `authEndpoint`.
Refer to our [authentication guide](/docs/rooms/authentication) for more
information.

```ts
import { createClient } from "@liveblocks/client";

const client = createClient({ authEndpoint: "/api/liveblocks-auth" });
```

### createClient with auth endpoint callback [#createClientCallback]

If you need to add additional headers or use your own function to call your
endpoint, `authEndpoint` can be provided as a custom callback. You should return
the token created with
[`Liveblocks.prepareSession`](/docs/api-reference/liveblocks-node#access-tokens)
or [`liveblocks.identifyUser`](/docs/api-reference/liveblocks-node#id-tokens),
learn more in [authentication guide](/docs/rooms/authentication).

```ts
import { createClient } from "@liveblocks/client";

const client = createClient({
  authEndpoint: async (room) => {
    // Fetch your authentication endpoint and retrieve your access or ID token
    // ...

    return '{ "token": "..." }';
  },
});
```

`room` is the room ID that the user is connecting to. When using
[Notifications](/docs/products/comments/notifications), `room` can be
`undefined`, as the client is requesting a token that grants access to multiple
rooms, rather than a specific room.

#### Fetch your endpoint

Here‚Äôs an example of fetching your API endpoint at `/api/liveblocks-auth` within
the callback.

```ts
import { createClient } from "@liveblocks/client";

const client = createClient({
  authEndpoint: async (room) => {
    const response = await fetch("/api/liveblocks-auth", {
      method: "POST",
      headers: {
        Authentication: "<your own headers here>",
        "Content-Type": "application/json",
      },
      // Don't forget to pass `room` down. Note that it
      // can be undefined when using Notifications.
      body: JSON.stringify({ room }),
    });
    return await response.json();
  },
});
```

#### Token details

You should return the token created with
[`Liveblocks.prepareSession`](/docs/api-reference/liveblocks-node#access-tokens)
or [`liveblocks.identifyUser`](/docs/api-reference/liveblocks-node#id-tokens).
These are the values the functions can return.

1. A valid token, it returns a `'{ "token": "..." }'` shaped response.
1. A token that explicitly forbids access, it returns an
   `'{ "error": "forbidden", "reason": "..." }'` shaped response. If this is
   returned, the client will disconnect and won't keep trying to authorize.

Any other error will be treated as an unexpected error, after which the client
will retry the request until it receives either 1. or 2.

### WebSocket throttle [#createClientThrottle]

By default, the client throttles the WebSocket messages sent to one every 100
milliseconds, which translates to 10 updates per second. It‚Äôs possible to
override that configuration with the `throttle` option with a value between `16`
and `1000` milliseconds.

```ts
import { createClient } from "@liveblocks/client";

const client = createClient({
  throttle: 16,

  // Other options
  // ...
});
```

This option is helpful for smoothing out real-time animations in your
application, as you can effectively increase the framerate without using any
interpolation. Here are some examples with their approximate frames per second
(FPS) values.

```ts
throttle:  16, // 60 FPS
throttle:  32, // 30 FPS
throttle: 200, //  5 FPS
```

### Lost connection timeout [#createClientLostConnectionTimeout]

If you‚Äôre connected to a room and briefly lose connection, Liveblocks will
reconnect automatically and quickly. However, if reconnecting takes longer than
usual, for example if your network is offline, then the room will emit an event
informing you about this.

How quickly this event is triggered can be configured with the
`lostConnectionTimeout` setting, and it takes a number in milliseconds.
`lostConnectionTimeout` can be set between `1000` and `30000` milliseconds. The
default is `5000`, or 5 seconds.

```ts
import { createClient } from "@liveblocks/client";

const client = createClient({
  lostConnectionTimeout: 5000,

  // Other options
  // ...
});
```

You can listen to the event with [`room.subscribe("lost-connection")`][]. Note
that this also affects when `others` are reset to an empty array after a
disconnection. This helps prevent temporary flashes in your application as a
user quickly disconnects and reconnects. For a demonstration of this behavior,
see our [connection status example][].

### Background keep-alive timeout [#createClientBackgroundKeepAliveTimeout]

By default, Liveblocks applications will maintain an active WebSocket connection
to the Liveblocks servers, even when running in a browser tab that‚Äôs in the
background. However, if you‚Äôd prefer for background tabs to disconnect after a
period of inactivity, then you can use `backgroundKeepAliveTimeout`.

When `backgroundKeepAliveTimeout` is specified, the client will automatically
disconnect applications that have been in an unfocused background tab for _at
least_ the specified time. When the browser tab is refocused, the client will
immediately reconnect to the room and synchronize the document.

```ts
import { createClient } from "@liveblocks/client";

const client = createClient({
  // Disconnect users after 15 minutes of inactivity
  backgroundKeepAliveTimeout: 15 * 60 * 1000,

  // Other options
  // ...
});
```

`backgroundKeepAliveTimeout` accepts a number in milliseconds‚Äîwe advise using a
value of at least a few minutes, to avoid unnecessary disconnections.

### resolveUsers [#createClientResolveUsers]

<Banner title="Public beta">

Comments is currently in beta. If you have any questions or feedback, please
reach out to us via the dedicated Discord channel,
[#comments-beta](https://discord.com/channels/913109211746009108/1126614905160749097).
We‚Äôd love to hear from you.

</Banner>

[Comments](/docs/products/comments) stores user IDs in its system, but no other
user information. To display user information in Comments components, such as a
user‚Äôs name or avatar, you need to resolve these IDs into user objects. This
function receives a list of user IDs and you should return a list of user
objects of the same size, in the same order.

```tsx
import { createClient } from "@liveblocks/client";

const client = createClient({
  resolveUsers: async ({ userIds }) => {
    const usersData = await __getUsersFromDB__(userIds);

    return usersData.map((userData) => ({
      name: userData.name,
      avatar: userData.avatar.src,
    }));
  },

  // Other options
  // ...
});
```

#### User objects

The user objects returned by the resolver function take the shape of
`UserMeta["info"]`, which contains `name` and `avatar` by default. These two
values are optional, though if you‚Äôre using the
[Comments default components](/docs/api-reference/liveblocks-react-comments#Components),
they are necessary. Here‚Äôs an example of `userIds` and the exact values
returned.

```ts
resolveUsers: async ({ userIds }) => {
  // ["marc@example.com", "nimesh@example.com"];
  console.log(userIds);

  return [
    { name: "Marc", avatar: "https://example.com/marc.png" },
    { name: "Nimesh", avatar: "https://example.com/nimesh.png" },
  ];
};
```

You can also return custom information, for example, a user‚Äôs `color`:

```ts highlight="9"
resolveUsers: async ({ userIds }) => {
  // ["marc@example.com"];
  console.log(userIds);

  return [
    {
      name: "Marc",
      avatar: "https://example.com/marc.png",
      color: "purple",
    },
  ];
};
```

#### Acessing user data in React

You can access any values set within `resolveUsers` with the
[`useUser`](/docs/api-reference/liveblocks-react#useUser) hook.

```tsx
import { useUser } from "../liveblocks.config";

function Component() {
  const user = useUser("marc@example.com");

  // { name: "Marc", avatar: "https://...", ... }
  console.log(user);
}
```

### resolveRoomsInfo [#createClientResolveRoomsInfo]

<Banner title="Public beta">

Comments is currently in beta. If you have any questions or feedback, please
reach out to us via the dedicated Discord channel,
[#comments-beta](https://discord.com/channels/913109211746009108/1126614905160749097).
We‚Äôd love to hear from you.

</Banner>

When using [Notifications](/docs/products/comments/notifications) with
[Comments](/docs/products/comments), room IDs will be used to contextualize
notifications (e.g. "Chris mentioned you in room-id"). To replace room IDs with
more fitting names (e.g. document names, "Chris mentioned you in Document A"),
you can provide a resolver function to the `resolveRoomsInfo` option in
[`createClient`](#createClient).

This resolver function will receive a list of room IDs and should return a list
of room info objects of the same size and in the same order.

```tsx
import { createClient } from "@liveblocks/client";

const client = createClient({
  /* ... other options ... */
  resolveRoomsInfo: async ({ roomIds }) => {
    const documentsData = await __getDocumentsFromDB__(roomIds);

    return documentsData.map((documentData) => ({
      name: documentData.name,
      // url: documentData.url,
    }));
  },
});
```

In addition to the room‚Äôs name, you can also provide a room‚Äôs URL as the `url`
property. If you do so, the
[`InboxNotification`](/docs/api-reference/liveblocks-react-comments#InboxNotification)
component will automatically use it. It‚Äôs possible to use an inbox
notification‚Äôs `roomId` property to construct a room‚Äôs URL directly in React and
set it on
[`InboxNotification`](/docs/api-reference/liveblocks-react-comments#InboxNotification)
via `href`, but the room ID might not be enough for you to construct the URL ,
you might need to call your backend for example. In that case, providing it via
`resolveRoomsInfo` is the preferred way.

### resolveMentionSuggestions [#createClientResolveMentionSuggestions]

<Banner title="Public beta">

Comments is currently in beta. If you have any questions or feedback, please
reach out to us via the dedicated Discord channel,
[#comments-beta](https://discord.com/channels/913109211746009108/1126614905160749097).
We‚Äôd love to hear from you.

</Banner>

To enable creating mentions in [Comments](/docs/products/comments), you can
provide a resolver function to the `resolveMentionSuggestions` option in
[`createClient`](#createClient).

This resolver function will receive the mention currently being written (e.g.
when writing ‚Äú@jane‚Äù, `text` will be `jane`) and should return a list of user
IDs matching that text. This function will be called every time the text changes
but with some debouncing.

```tsx
import { createClient } from "@liveblocks/client";

const client = createClient({
  /* ... other options ... */
  resolveMentionSuggestions: async ({ text, roomId }) => {
    const workspaceUsers = await __getWorkspaceUsersFromDB__(roomId);

    if (!text) {
      // Show all workspace users by default

      return __getUserIds__(workspaceUsers);
    } else {
      const matchingUsers = __findUsers__(workspaceUsers, text);

      return __getUserIds__(matchingUsers);
    }
  },
});
```

### createClient for Node.js [#createClientNode]

To use `@liveblocks/client` in Node.js, you need to provide [`WebSocket`][] and
[`fetch`][] polyfills. As polyfills, we recommend installing [`ws`][] and
[`node-fetch`][].

```bash
npm install ws node-fetch
```

Then, pass them to the `createClient` polyfill option as below.

```ts
import { createClient } from "@liveblocks/client";
import fetch from "node-fetch";
import WebSocket from "ws";

const client = createClient({
  polyfills: {
    fetch,
    WebSocket,
  },

  // Other options
  // ...
});
```

Note that `node-fetch` v3+
[does not support CommonJS](https://github.com/node-fetch/node-fetch/blob/main/docs/v3-UPGRADE-GUIDE.md#converted-to-es-module).
If you are using CommonJS, downgrade `node-fetch` to v2.

### createClient for React Native [#createClientReactNative]

To use `@liveblocks/client` with [React Native](https://reactnative.dev/), you
need to add an [`atob`][] polyfill. As a polyfill, we recommend installing
[`base-64`][].

```bash
npm install base-64
```

Then you can pass the `decode` function to our `atob` polyfill option when you
create the client.

```ts
import { createClient } from "@liveblocks/client";
import { decode } from "base-64";

const client = createClient({
  polyfills: {
    atob: decode,
  },

  // Other options
  // ...
});
```

## Client

Client returned by [`createClient`][].

### Client.enterRoom

Enters a room and returns both the local `Room` instance, and a ‚Äúleave‚Äù function
(unsubscribe function). The authentication endpoint is called as soon as you
call this function.

The second argument is a configuration for the presence and storage.

- `initialPresence` - The initial Presence to use for the User currently
  entering the Room. Presence data belongs to the current User and is readable
  to all other Users in the room while the current User is connected to the
  Room. Must be serializable to JSON.
- `initialStorage` (optional) - The initial Storage structure to create when a
  new Room is entered for the first time. Storage data is shared and belongs to
  the Room itself. It persists even after all Users leave the room, and is
  mutable by every client. Must either contain Live structures (e.g.
  `new LiveList()`, `new LiveObject({ a: 1 })`, etc.) or be serializable to
  JSON.
- `autoConnect` (optional) - Whether or not the room immediately connects to
  Liveblocks servers. Default is `true`. Usually set to `false` when the client
  is used from the server to not call the authentication endpoint or connect via
  WebSocket.

```ts
const { room, leave } = client.enterRoom("my-room", {
  initialPresence: { cursor: null },
  initialStorage: { todos: new LiveList() },
});

// Don‚Äôt forget to call `leave()` when you‚Äôre done with the room
leave();
```

### Client.enter

Enters a room and returns its local `Room` instance.

<Banner title="Deprecated since 1.5" type="warning">

We no longer recommend this API, because issues will occur if you simultaneously
connect to the same room with multiple instances. We recommend using
[`client.enterRoom`][] instead.

</Banner>

```ts
// ‚ùå This API was recommended before 1.5
const room = client.enter("my-room", {
  initialPresence: { cursor: null },
  initialStorage: { todos: new LiveList() },
});
client.leave(roomId);

// ‚úÖ Prefer this instead
const { room, leave } = client.enterRoom("my-room", {
  initialPresence: { cursor: null },
  initialStorage: { todos: new LiveList() },
});
leave();
```

### Client.leave

Leaves a room.

<Banner title="Deprecated since 1.5" type="warning">

We no longer recommend this API, because issues will occur if you simultaneously
connect to the same room with multiple instances. We recommend using
[`client.enterRoom`][] instead.

</Banner>

```ts
// ‚ùå This API was recommended before 1.5
client.leave("my-room");

// ‚úÖ Prefer this instead
const { room, leave } = client.enterRoom("my-room" /* options */);
leave();
```

### Client.getRoom

Gets a room by its ID. Returns `null` if [`client.enterRoom`][] has not been
called previously.

```ts
const room = client.getRoom("my-room");
```

You‚Äôll likely not need this API if you‚Äôre using the newer [`client.enterRoom`][]
API.

### Client.logout

Purges any auth tokens from the client‚Äôs memory. If there are any rooms that are
still connected, they will be forced to reauthorize.

```ts
client.logout();
```

Call this API if you have a single page application (SPA) and you want to log
your user out.

## Room

Room returned by [`client.enterRoom`][] (or [`client.getRoom`][]).

### Room.getPresence

Gets the presence of the current user.

```ts
const presence = room.getPresence();
```

### Room.updatePresence

Updates the presence of the current user. You need only pass the properties you
wish to update‚Äîany changes will be merged into the current presence. The entire
presence object will not be replaced.

```ts
room.updatePresence({ x: 0 });
room.updatePresence({ y: 0 });

const presence = room.getPresence();
// presence is equivalent to { x: 0, y: 0 }
```

`updatePresence` accepts an optional argument to add a new item to the undo/redo
stack. See [`room.history`][] for more information.

```ts
room.updatePresence({ selectedId: "xxx" }, { addToHistory: true });
room.updatePresence({ selectedId: "yyy" }, { addToHistory: true });
room.history.undo();
// room.getPresence() equals { selectedId: "xxx" }
```

### Room.getOthers

Gets all the other `User`s in the Room.

```ts
const others = room.getOthers();

for (const { connectionId, id, info, presence, isReadOnly } of others) {
  // Do things
}
```

### Room.broadcastEvent

Broadcast an event to other users in the Room. Events broadcast to the room can
be listened to with [`Room.subscribe("event")`][]. Takes a payload as first
argument. Should be serializable to JSON.

By default, broadcasting an event is a ‚Äúfire and forget‚Äù action. If the sending
client is not currently connected to a room, the event is simply discarded. When
passing the `shouldQueueEventIfNotReady` option, the client will queue up the
event, and only send it once the connection to the room is (re)established.

<Banner title="Notice">

We‚Äôre not sure if we want to support `shouldQueueEventIfNotReady` in the future,
so it may be deprecated and replaced with something else.

</Banner>

```ts highlight="1-2"
// On client A
room.broadcastEvent({ type: "EMOJI", emoji: "üî•" });

// On client B
room.subscribe("event", ({ event, user, connectionId }) => {
  //                              ^^^^ Will be Client A
  if (event.type === "EMOJI") {
    // Do something
  }
});
```

The `user` property will indicate which User instance sent the message. This
will typically be equal to one of the others in the room, but it can also be
`null` in case this event was broadcasted from the server, using the
[Broadcast Event API](https://liveblocks.io/docs/api-reference/rest-api-endpoints#post-broadcast-event).

### Room.getSelf

Gets the current `User`. Returns `null` if it is not yet connected to the room.

```ts
const { connectionId, presence, id, info, isReadOnly } = room.getSelf();
```

### Room.getStatus

Gets the current WebSocket connection status of the room.

```ts
const status = room.getStatus();
```

The possible value are: `initial`, `connecting`, `connected`, `reconnecting`, or
`disconnected`.

### Room.subscribe(storageItem)

Subscribe to updates for a particular storage item.

Takes a callback that is called when the storage item is updated.

Returns an unsubscribe function.

```ts
const { root } = await room.getStorage();
const unsubscribe = room.subscribe(root, (root) => {
  // Do something
});
```

It‚Äôs also possible to subscribe to a storage item and its children by passing an
optional `isDeep` parameter. In that case, the callback will get called with a
list of updates instead. Each such update is a `{ type, node, updates }` object.

```ts
const { root } = await room.getStorage();
const unsubscribe = room.subscribe(
  root,
  (storageUpdates) => {
    for (const update of storageUpdates) {
      const {
        type, // "LiveObject", "LiveList", or "LiveMap"
        node,
        updates,
      } = update;
      switch (type) {
        case "LiveObject": {
          // updates["property"]?.type; is "update" or "delete"
          // update.node is the LiveObject that has been updated/deleted
          break;
        }
        case "LiveMap": {
          // updates["key"]?.type; is "update" or "delete"
          // update.node is the LiveMap that has been updated/deleted
          break;
        }
        case "LiveList": {
          // updates[0]?.type; is "delete", "insert", "move", or "set"
          // update.node is the LiveList that has been updated, deleted, or modified
          break;
        }
      }
    }
  },
  { isDeep: true }
);
```

### Room.subscribe("event") [#Room.subscribe.event]

Subscribe to events broadcast by [`Room.broadcastEvent`][].

Takes a callback that is called when a user calls [`Room.broadcastEvent`][].
Provides the `event` along with the `user` and their `connectionId` of the user
that sent the message. If this event was sent via the
[Broadcast to a room](/docs/api-reference/rest-api-endpoints#post-broadcast-event)
REST API, `user` will be `null` and `connectionId` will be `-1`.

Returns an unsubscribe function.

```ts highlight="4-10"
// On client A
room.broadcastEvent({ type: "EMOJI", emoji: "üî•" });

// On client B
const unsubscribe = room.subscribe("event", ({ event, user, connectionId }) => {
  //                                                  ^^^^ Will be Client A
  if (event.type === "EMOJI") {
    // Do something
  }
});
```

### Room.subscribe("my-presence") [#Room.subscribe.my-presence]

Subscribe to the current user presence updates.

Takes a callback that is called every time the current user presence is updated
with [`Room.updatePresence`][].

Returns an unsubscribe function.

```ts
const unsubscribe = room.subscribe("my-presence", (presence) => {
  // Do something
});
```

### Room.subscribe("others") [#Room.subscribe.others]

Subscribe to the other users updates.

Takes a callback that is called when a user enters or leaves the room or when a
user update its presence.

Returns an unsubscribe function.

```ts
const unsubscribe = room.subscribe("others", (others, event) => {
  // Do something

  if (event.type === "leave") {
    // A user has left the room
    // event.user;
  }

  if (event.type === "enter") {
    // A user has entered the room
    // event.user;
  }

  if (event.type === "update") {
    // A user has updated
    // event.user;
    // event.updates;
  }

  if (event.type === "reset") {
    // A disconnection has occurred and others has reset
  }
});
```

### Room.subscribe("status") [#Room.subscribe.status]

Subscribe to WebSocket connection status updates.

Takes a callback that is called whenever the connection status changes. Possible
value are: `initial`, `connecting`, `connected`, `reconnecting`, or
`disconnected`.

Returns an unsubscribe function.

```ts
const unsubscribe = room.subscribe("status", (status) => {
  // Do something
});
```

This is a low-level API that exposes the WebSocket‚Äôs connectivity status. You
can use this, for example, to update a connection status indicator in your UI.
It would be normal for a client to briefly lose the connection and restore it,
using quick `connected` ‚Üí `reconnecting` ‚Üí `connected` status jumps.

If you want to let users know that there may be connectivity issues, don‚Äôt use
this API, but instead refer to [`Room.subscribe("lost-connection")`][].

<Banner title="Notice">

Do not use this API to detect when Storage or Presence are initialized or
loaded. "Connected" does not guarantee that Storage or Presence are ready. To
detect when Storage is loaded, rely on awaiting the [`Room.getStorage`][]
promise or using the [`Room.subscribe("storage-status")`][] event.

</Banner>

### Room.subscribe("lost-connection") [#Room.subscribe.lost-connection]

A special-purpose event that will fire in the exceptional case where a
previously connected Liveblocks client has lost its connection (e.g. due to a
network outage) and was unable to recover quickly.

This event allows you to build high-quality UIs by warning your users that the
app is still trying to re-establish the connection, for example through a toast
notification. You may want to take extra care in the mean time to ensure their
changes won‚Äôt go unsaved, or to help them understand why they‚Äôre not seeing
updates made by others yet.

When this happens, this callback is called with the event `lost`. Then, once the
connection restores, the callback will be called with the value `restored`. If
the connection could definitively not be restored, it will be called with
`failed` (uncommon).

The [`lostConnectionTimeout`][] configuration option will determine how quickly
this event will fire after a connection loss (default: 5 seconds).

```ts
import { toast } from "my-preferred-toast-library";

const unsubscribe = room.subscribe("lost-connection", (event) => {
  switch (event) {
    case "lost":
      toast.warn("Still trying to reconnect...");
      break;

    case "restored":
      toast.success("Successfully reconnected again!");
      break;

    case "failed":
      toast.error("Could not restore the connection");
      break;
  }
});
```

### Room.subscribe("connection") [#Room.subscribe.connection]

<Banner title="Deprecated since 1.1" type="warning">

Support for this subscription overload will be removed in a future version. We
recommend switching to [`Room.subscribe("status")`][] instead.

</Banner>

Subscribe to our legacy WebSocket connection status updates.

Takes a callback that is called when the connection status changes.

Returns an unsubscribe function.

```ts
const unsubscribe = room.subscribe("connection", (status) => {
  // Do something
});
```

### Room.subscribe("error") [#Room.subscribe.error]

Subscribe to unrecoverable room connection errors. This event will be emitted
right before the client disconnects and won‚Äôt try reconnecting again.

Returns an unsubscribe function.

```ts
const unsubscribe = room.subscribe("error", (error) => {
  switch (error.code) {
    case -1:
      // Authentication error
      break;

    case 4001:
      // Could not connect because you don't have access to this room
      break;

    case 4005:
      // Could not connect because room was full
      break;

    default:
      // Unexpected error
      break;
  }
});
```

You can use this event to trigger a ‚ÄúNot allowed‚Äù screen/dialog. If you‚Äôd like
to retry connecting, call `room.reconnect()`.

### Room.subscribe("history") [#Room.subscribe.history]

Subscribe to the current user‚Äôs history changes.

Returns an unsubscribe function.

```ts
const unsubscribe = room.subscribe("history", ({ canUndo, canRedo }) => {
  // Do something
});
```

### Room.subscribe("storage-status") [#Room.subscribe.storage-status]

Subscribe to storage status changes.

Returns an unsubscribe function.

```typescript
const unsubscribe = room.subscribe("storage-status", (status) => {
  switch (status) {
    case "not-loaded":
      break;
    case "loading":
      break;
    case "synchronizing":
      break;
    case "synchronized":
      break;
    default:
      break;
  }
});
```

### Room.batch

Batches Storage and Presence modifications made during the given function. Each
modification is grouped together, which means that other clients receive the
changes as a single message after the batch function has run. Every modification
made during the batch is merged into a single history item (undo/redo).

```ts
const { root } = await room.getStorage();
room.batch(() => {
  root.set("x", 0);
  room.updatePresence({ cursor: { x: 100, y: 100 } });
});
```

Note that `room.batch` cannot take an `async` function.

```tsx
// ‚ùå Won't work
room.batch(async () => /* ... */);

// ‚úÖ Will work
room.batch(() => /*... */);
```

### Room.history

Room‚Äôs history contains functions that let you undo and redo operation made on
by the current client on the presence and storage.

```ts
const { undo, redo, pause, resume } = room.history;
```

### Room.history.undo

Undoes the last operation executed by the current client. It does not impact
operations made by other clients.

```ts
room.updatePresence({ selectedId: "xxx" }, { addToHistory: true });
room.updatePresence({ selectedId: "yyy" }, { addToHistory: true });
room.history.undo();
// room.getPresence() equals { selectedId: "xxx" }
```

### Room.history.redo

Redoes the last operation executed by the current client. It does not impact
operations made by other clients.

```ts
room.updatePresence({ selectedId: "xxx" }, { addToHistory: true });
room.updatePresence({ selectedId: "yyy" }, { addToHistory: true });
room.history.undo();
// room.getPresence() equals { selectedId: "xxx" }
room.history.redo();
// room.getPresence() equals { selectedId: "yyy" }
```

### Room.history.canUndo

Returns whether there are any operations to undo.

```ts
room.updatePresence({ selectedId: "xx" }, { addToHistory: true });
// room.history.canUndo() is true
room.history.undo();
// room.history.canUndo() is false
```

### Room.history.canRedo

Returns whether there are any operations to redo.

```ts
room.updatePresence({ selectedId: "xx" }, { addToHistory: true });
room.history.undo();
// room.history.canRedo() is true
room.history.redo();
// room.history.canRedo() is false
```

### Room.history.clear

Clears the undo and redo stacks for the current client. Explicitly clearing
history resets the ability to undo beyond the current document state. Other
clients‚Äô histories are unaffected.

```ts
room.updatePresence({ selectedId: "xx" }, { addToHistory: true });
// room.history.canUndo() is true
room.history.clear();
// room.history.canUndo() is false
```

### Room.history.pause

All future modifications made on the Room will be merged together to create a
single history item until resume is called.

```ts
room.updatePresence({ cursor: { x: 0, y: 0 } }, { addToHistory: true });
room.history.pause();
room.updatePresence({ cursor: { x: 1, y: 1 } }, { addToHistory: true });
room.updatePresence({ cursor: { x: 2, y: 2 } }, { addToHistory: true });
room.history.resume();
room.history.undo();
// room.getPresence() equals { cursor: { x: 0, y: 0 } }
```

### Room.history.resume

Resumes history. Modifications made on the Room are not merged into a single
history item anymore.

```ts
room.updatePresence({ cursor: { x: 0, y: 0 } }, { addToHistory: true });
room.history.pause();
room.updatePresence({ cursor: { x: 1, y: 1 } }, { addToHistory: true });
room.updatePresence({ cursor: { x: 2, y: 2 } }, { addToHistory: true });
room.history.resume();
room.history.undo();
// room.getPresence() equals { cursor: { x: 0, y: 0 } }
```

### Room.getStorageStatus

Get the storage status.

- `not-loaded`: Initial state when entering the room.
- `loading`: Once the storage has been requested via room.getStorage().
- `synchronizing`: When some local updates have not been acknowledged by
  Liveblocks servers.
- `synchronized`: Storage is in sync with Liveblocks servers.

```ts
const status = room.getStorageStatus();
```

### Room.connect

Connect the local room instance to the Liveblocks server. Does nothing if the
room is already connecting, reconnecting or connected.

```ts
room.connect();
```

We don‚Äôt recommend using this API directly.

### Room.reconnect

Reconnect the local room instance to the Liveblocks server, using a new
WebSocket connection.

```ts
room.reconnect();
```

### Room.disconnect

Disconnect the local room instance from the Liveblocks server. The room instance
will remain functional (for example, it will still allow local presence or
storage mutations), but since it‚Äôs no longer connected, changes will not be
persisted or synchronized until the room instance is reconnected again.

```ts
room.disconnect();
```

We don‚Äôt recommend using this API directly.

## Storage

<Banner title="Need help troubleshooting storage?">

Try the [Liveblocks DevTools extension](/devtools) to visualize your
collaborative experiences as you build them, in real-time.

</Banner>

The room‚Äôs storage is a conflicts-free state that multiple users can edit at the
same time. It persists even after everyone leaves the room. Liveblocks provides
3 data structures that can be nested to create the state that you want.

- [`LiveObject`][] - Similar to JavaScript object. Use this for storing records
  with fixed key names and where the values don‚Äôt necessarily have the same
  types. For example, a `Person` with a `name` (string) and an `age` (number)
  field.

  If multiple clients update the same property simultaneously, the last
  modification received by the Liveblocks servers is the winner.

- [`LiveList`][] - An ordered collection of items synchronized across clients.
  Even if multiple users add/remove/move elements simultaneously, LiveList will
  solve the conflicts to ensure everyone sees the same collection of items.

- [`LiveMap`][] - Similar to a JavaScript Map. Use this for indexing values that
  all have the same structure. For example, to store an index of `Person` values
  by their name. If multiple users update the same property simultaneously, the
  last modification received by the Liveblocks servers is the winner.

### Room.getStorage

Get the room‚Äôs storage asynchronously (returns a Promise). The promise will
resolve once the storage‚Äôs root is loaded and available.

The storage‚Äôs root will always be a [`LiveObject`][].

```ts
const { root } = await room.getStorage();
```

## LiveObject

The `LiveObject` class is similar to a JavaScript object that is synchronized on
all clients. Use this for storing records with fixed key names and where the
values don‚Äôt necessarily have the same types. For example, a Person with a
`name` (string) and an `age` (number) field.

Keys should be strings, and values should be serializable to JSON.

If multiple clients update the same property simultaneously, the last
modification received by the Liveblocks servers is the winner.

### new LiveObject [#LiveObject.constructor]

Create an empty `LiveObject`

```ts
const object = new LiveObject();
```

Create a `LiveObject` with initial data.

```ts
const object = new LiveObject({ firstName: "Margaret", lastName: "Hamilton" });
```

### delete [#LiveObject.delete]

Delete a property from the `LiveObject`

```ts
const object = new LiveObject({ firstName: "Ada", lastName: "Lovelace" });
object.delete("lastName");
object.toObject(); // equals to { firstName: "Ada" }
```

### get [#LiveObject.get]

Get a property from the `LiveObject`

```ts
const object = new LiveObject({ firstName: "Ada", lastName: "Lovelace" });
object.get("firstName"); // equals to "Ada"
```

### set [#LiveObject.set]

Adds or updates a property with the specified key and a value.

```ts
const object = new LiveObject({ firstName: "Marie" });
object.set("lastName", "Curie");
```

### update [#LiveObject.update]

Adds or updates multiple properties at once.

```ts
const object = new LiveObject({ firstName: "Grace", lastName: "Hopper" });
object.update({ job: "Computer Scientist", birthDate: "December 9, 1906" });
```

### toObject [#LiveObject.toObject]

<Banner title="Will be deprecated in the future">

Starting with 0.18, we recommend [`toImmutable`][] instead. It‚Äôs faster, cached,
and leads to fewer surprises.

</Banner>

Transform the `LiveObject` into a normal JavaScript object.

```ts
const liveObject = new LiveObject({ firstName: "Grace", lastName: "Hopper" });
liveObject.toObject();
// { firstName: "Grace", lastName: "Hopper" }
```

Please note that this method won‚Äôt recursively convert Live structures, which
may be surprising:

```ts
const liveObject = new LiveObject({
  animals: new LiveList(["ü¶Å", "ü¶ä", "üêµ"]),
});
liveObject.toObject();
// { animals: <LiveList instance> } // ‚ùóÔ∏è
```

### toImmutable [#LiveObject.toImmutable]

Returns an immutable JavaScript object that is equivalent to the `LiveObject`.
Nested values will also be immutable.

```ts
const liveObject = new LiveObject({
  firstName: "Grace",
  lastName: "Hopper",
  hobbies: new LiveList(["needlepoint", "reading", "playing piano"]),
});
liveObject.toImmutable();
// {
//   firstName: "Grace",
//   lastName: "Hopper",
//   hobbies: ["needlepoint", "reading", "playing piano"]
// }
```

### clone [#LiveObject.clone]

Returns a deep copy of the `LiveObject` that can be inserted elsewhere in the
Storage tree.

```ts
const obj = new LiveObject(/* ... */);
root.set("a", obj);
root.set("b", obj.clone());
```

## LiveMap

The `LiveMap` class is similar to a
[JavaScript Map](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Map)
that is synchronized on all clients.

Use this for indexing values that all have the same structure. For example, to
store an index of `Person` values by their name. Keys should be strings, and
values should be serializable to JSON. If multiple clients update the same
property simultaneously, the last modification received by the Liveblocks
servers is the winner.

### new LiveMap [#LiveMap.constructor]

Create an empty `LiveMap`.

```ts
const map = new LiveMap();
```

Create a `LiveMap` with initial data.

```ts
const map = new LiveMap([
  ["keyA", "valueA"],
  ["keyB", "valueB"],
]);
```

### delete [#LiveMap.delete]

Removes the specified element by key. Returns true if an element existed and has
been removed, or false if the element does not exist.

```ts
const map = new LiveMap([
  ["keyA", "valueA"],
  ["keyB", "valueB"],
]);
map.delete("keyA"); // equals true
map.get("keyA"); // equals undefined
map.delete("unknownKey"); // equals false
```

### entries [#LiveMap.entries]

Returns a new
[Iterator](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Guide/Iterators_and_Generators)
object that contains the `[key, value]` pairs for each element.

```ts
for (const [key, value] of map.entries()) {
  // Iterate over all the keys and values of the map
}
```

<Banner title="Iteration with TypeScript">

If your TypeScript project targets <code>es5</code> or lower, you‚Äôll need to
enable the <code>--downlevelIteration</code> option to use this API.

</Banner>

### forEach [#LiveMap.forEach]

Executes a provided function once per each key/value pair in the Map object.

```ts
const map = new LiveMap([
  ["keyA", "valueA"],
  ["keyB", "valueB"],
]);
map.forEach((value, key) => console.log(value));
// prints to the console "valueA", "valueB"
```

### get [#LiveMap.get]

Returns a specified element from the LiveMap or undefined if the key can‚Äôt be
found.

```ts
const map = new LiveMap([
  ["keyA", "valueA"],
  ["keyB", "valueB"],
]);
map.get("keyA"); // equals "valueA"
map.get("unknownKey"); // equals undefined
```

### has [#LiveMap.has]

Returns a boolean indicating whether an element with the specified key exists or
not.

```ts
const map = new LiveMap([
  ["keyA", "valueA"],
  ["keyB", "valueB"],
]);
map.has("keyA"); // equals true
map.has("unknownKey"); // equals false
```

### keys [#LiveMap.keys]

Returns a new
[Iterator](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Guide/Iterators_and_Generators)
object that contains the keys for each element.

```ts
for (const key of map.keys()) {
  // Iterate over all the keys and values of the map
}
```

<Banner title="Iteration with TypeScript">

If your TypeScript project targets <code>es5</code> or lower, you‚Äôll need to
enable the <code>--downlevelIteration</code> option to use this API.

</Banner>

### set [#LiveMap.set]

Adds or updates an element with a specified key and a value.

```ts
const map = new LiveMap();
map.set("keyA", "valueA");
```

### size [#LiveMap.size]

Returns the number of elements in the `LiveMap`.

```ts
const map = new LiveMap([
  ["keyA", "valueA"],
  ["keyB", "valueB"],
]);
map.size; // equals 2
```

### values [#LiveMap.values]

Returns a new
[Iterator](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Guide/Iterators_and_Generators)
object that contains the the values for each element.

```ts
for (const value of map.values()) {
  // Iterate over all the values of the map
}
```

<Banner title="Iteration with TypeScript">

If your TypeScript project targets <code>es5</code> or lower, you‚Äôll need to
enable the <code>--downlevelIteration</code> option to use this API.

</Banner>

### toImmutable [#LiveMap.toImmutable]

Returns an immutable ES6 Map that is equivalent to the `LiveMap`. Nested values
will also be immutable.

```ts
const map = new LiveMap([
  ["abc", new LiveObject({ firstName: "Grace", lastName: "Hopper" })],
  ["pqr", new LiveObject({ firstName: "Ada", lastName: "Lovelace" })],
]);
map.toImmutable();
// equal to:
// Map(2) {
//   'abc' => { firstName: 'Grace', lastName: 'Hopper' },
//   'pqr' => { firstName: 'Ada', lastName: 'Lovelace' }
// }
```

### clone [#LiveMap.clone]

Returns a deep copy of the `LiveMap` that can be inserted elsewhere in the
Storage tree.

```ts
const map = new LiveMap(/* ... */);
root.set("a", map);
root.set("b", map.clone());
```

## LiveList

The `LiveList` class represents an ordered collection of items that is
synchorinized across clients. Items should be serializable to JSON or another
Live data type.

### new LiveList [#LiveList.constructor]

Create an empty `LiveList`.

```ts
const list = new LiveList();
```

Create a `LiveList` with initial data.

```ts
const list = new LiveList(["ü¶Å", "ü¶ä", "üêµ"]);
```

### clear [#LiveList.clear]

Removes all the elements.

```ts
const list = new LiveList(["ü¶Å", "ü¶ä", "üêµ"]);
list.clear();
list.toArray(); // equals []
```

### delete [#LiveList.delete]

Deletes an element at the specified index.

```ts
const list = new LiveList(["ü¶Å", "ü¶ä", "üêµ"]);
list.delete(1);
list.toArray(); // equals ["ü¶Å", "üêµ"]
```

### every [#LiveList.every]

Tests whether all elements pass the test implemented by the provided function.
Returns true if the predicate function returns a truthy value for every element.
Otherwise, false.

```ts
const list = new LiveList([0, 2, 4]);
list.every((i) => i % 2 === 0); // equals true
list.push(5);
list.every((i) => i % 2 === 0); // equals false
```

### filter [#LiveList.filter]

Creates an array with all elements that pass the test implemented by the
provided function.

```ts
const list = new LiveList([0, 1, 2, 3, 4]);
list.filter((i) => i % 2 === 0); // equals [0, 2, 4]
```

### find [#LiveList.find]

Returns the first element that satisfies the provided testing function.

```ts
const list = new LiveList(["apple", "lemon", "tomato"]);
list.find((fruit) => fruit.startsWith("l")); // equals "lemon"
```

### findIndex [#LiveList.findIndex]

Returns the index of the first element in the `LiveList` that satisfies the
provided testing function.

```ts
const list = new LiveList(["apple", "lemon", "tomato"]);
list.findIndex((fruit) => fruit.startsWith("l")); // equals 1
```

### forEach [#LiveList.forEach]

Executes a provided function once for each element.

```ts
const list = new LiveList(["ü¶Å", "ü¶ä", "üêµ"]);
list.forEach((item) => console.log(item)); // prints to the console "ü¶Å", "ü¶ä", "üêµ"
```

### get [#LiveList.get]

Get the element at the specified index.

```ts
const list = new LiveList(["ü¶Å", "ü¶ä", "üêµ"]);
list.get(2); // equals "üêµ"
```

### indexOf [#LiveList.indexOf]

Returns the first index at which a given element can be found in the `LiveList`,
or -1 if it is not present.

```ts
const list = new LiveList(["ü¶Å", "ü¶ä", "üêµ"]);
list.indexOf("üêµ"); // equals 2
list.indexOf("üê∫"); // equals -1
```

### insert [#LiveList.insert]

Inserts one element at a specified index.

```ts
const list = new LiveList(["ü¶Å", "ü¶ä", "üêµ"]);
list.insert("üê∫", 1);
list.toArray(); // equals ["ü¶Å", "üê∫", "ü¶ä", "üêµ"]
```

### lastIndexOf [#LiveList.lastIndexOf]

Returns the last index at which a given element can be found in the `LiveList`,
or -1 if it is not present. The `LiveList` is searched backwards, starting at
fromIndex.

```ts
const list = new LiveList(["ü¶Å", "ü¶ä", "üêµ", "ü¶ä"]);
list.lastIndexOf("ü¶ä"); // equals 3
list.lastIndexOf("üê∫"); // equals -1
```

### length [#LiveList.length]

Returns the number of elements.

```ts
const list = new LiveList(["ü¶Å", "ü¶ä", "üêµ"]);
list.length; // equals 3
```

### map [#LiveList.map]

Creates an array populated with the results of calling a provided function on
every element.

```ts
const list = new LiveList(["apple", "lemon", "tomato"]);
list.map((fruit) => fruit.toUpperCase()); // equals ["APPLE", "LEMON", "TOMATO"]
```

### move [#LiveList.move]

Moves one element at a specified index.

```ts
const list = new LiveList(["ü¶Å", "ü¶ä", "üêµ"]);
list.move(2, 0); // move the "üêµ" at index 0
list.toArray(); // equals ["üêµ", "ü¶Å", "ü¶ä"]
```

### push [#LiveList.push]

Adds one element to the end of the `LiveList`.

```ts
const list = new LiveList(["ü¶Å", "ü¶ä", "üêµ"]);
list.push("üê∫");
list.toArray(); // equals ["ü¶Å", "ü¶ä", "üêµ", "üê∫"]
```

### set [#LiveList.set]

Replace one element at the specified index.

```ts
const list = new LiveList(["ü¶Å", "ü¶ä", "üêµ"]);
list.set(1, "üê∫");
list.toArray(); // equals ["ü¶Å", "üê∫", "üêµ"]
```

### some [#LiveList.some]

Tests whether at least one element in the `LiveList` passes the test implemented
by the provided function.

```ts
const list = new LiveList(["apple", "lemon", "tomato"]);
list.some((fruit) => fruit.startsWith("l")); // equals true
list.some((fruit) => fruit.startsWith("x")); // equals false
```

### toArray [#LiveList.toArray]

<Banner title="Will be deprecated in the future">

Starting with 0.18, we recommend [`toImmutable`][] instead. It‚Äôs faster, cached,
and leads to fewer surprises.

</Banner>

Transforms the `LiveList` into a normal JavaScript array.

```ts
const list = new LiveList(["ü¶Å", "ü¶ä", "üêµ"]);
list.toArray();
// ["ü¶Å", "ü¶ä", "üêµ"]
```

Please note that this method won‚Äôt recursively convert Live structures, which
may be surprising:

```ts
const list = new LiveList([
  new LiveObject({ firstName: "Grace", lastName: "Hopper" }),
]);
list.toArray();
// [ <LiveObject instance> ]  // ‚ùóÔ∏è
```

### toImmutable [#LiveList.toImmutable]

Returns an immutable JavaScript array that is equivalent to the `LiveList`.
Nested values will also be immutable.

```ts
const list = new LiveList([
  new LiveObject({ firstName: "Grace", lastName: "Hopper" }),
]);
list.toImmutable();
// [ { firstName: "Grace", lastName: "Hopper" } ]
```

### clone [#LiveList.clone]

Returns a deep copy of the `LiveList` that can be inserted elsewhere in the
Storage tree.

```ts
const list = new LiveList(/* ... */);
root.set("a", list);
root.set("b", list.clone());
```

## Utilities

### getMentionedIdsFromCommentBody [#get-mentioned-ids-from-comment-body]

Returns an array of each user‚Äôs ID that has been mentioned in a `CommentBody`
(found under `comment.body`).

```ts
import { getMentionedIdsFromCommentBody } from "@liveblocks/client";

const mentionedIds = getMentionedIdsFromCommentBody(comment.body);
```

Here‚Äôs an example with a custom `CommentBody`.

```ts
import {
  CommentBody,
  getMentionedIdsFromCommentBody,
} from "@liveblocks/client";

// Create a custom `CommentBody`
const commentBody: CommentBody = {
  version: 1,
  content: [
    {
      type: "paragraph",
      children: [
        { text: "Hello " },
        { type: "mention", id: "chris@example.com" },
      ],
    },
  ],
};

// Get the mentions inside the comment's body
const mentionedIds = getMentionedIdsFromCommentBody(commentBody);

// ["chris@example.com"]
console.log(mentionedIds);
```

<Banner title="Also available from @liveblocks/node">

If you‚Äôd like to use this on the server side, it's also available from
[`@liveblocks/node`](/docs/api-reference/liveblocks-node#get-mentioned-ids-from-comment-body).

</Banner>

### stringifyCommentBody [#stringify-comment-body]

Used to convert a `CommentBody` (found under `comment.body`) into either a plain
string, Markdown, HTML, or a custom format.

```ts
import { stringifyCommentBody } from "@liveblocks/client";

const stringComment = await stringifyCommentBody(comment.body);

// "Hello marc@example.com from https://liveblocks.io"
console.log(stringComment);
```

A number of options are available.

```ts
import { stringifyCommentBody } from "@liveblocks/client";

const stringComment = await stringifyCommentBody(comment.body, {
  // Optional, convert to specific format, "plain" (default) | "markdown" | "html"
  format: "markdown",

  // Optional, supply a separator to be used between paragraphs
  separator: `\n\n`,

  // Optional, override any elements in the CommentBody with a custom string
  elements: {
    // Optional, override the `paragraph` element
    paragraph: ({ element, children }) => `<p>${children}</p>`,

    // Optional, override the `text` element
    text: ({ element }) =>
      element.bold ? `<strong>${element.text}</strong>` : `${element.text}`,

    // Optional, override the `link` element
    link: ({ element, href }) =>
      `<a href="${href}" target="_blank">${element.url}</a>`,

    // Optional, override the `mention` element. `user` available if `resolveUsers` supplied
    mention: ({ element, user }) =>
      `<a href="${user.profileUrl}">${element.id}</a>`,
  },

  // Optional, get your user's names and info from their ID to be displayed in mentions
  async resolveUsers({ userIds }) {
    const usersData = await __getUsersFromDB__(userIds);

    return usersData.map((userData) => ({
      // Name is inserted into the output instead of a user's ID
      name: userData.name,

      // Custom formatting in `elements.mention` allows custom properties to be used
      profileUrl: userData.profileUrl,
    }));
  },
});
```

<Banner title="Also available from @liveblocks/node">

If you‚Äôd like to use this on the server side, it's also available from
[`@liveblocks/node`](/docs/api-reference/liveblocks-node#stringify-comment-body).

</Banner>

#### Formatting examples

Here are a number of different formatting examples derived from the same
`CommentBody`.

```ts
// "Hello marc@example.com from https://liveblocks.io"
await stringifyCommentBody(comment.body);

// "Hello @Marc from https://liveblocks.io"
await stringifyCommentBody(comment.body, {
  resolveUsers({ userIds }) {
    return [{ name: "Marc" }];
  },
});

// "**Hello** @Marc from [https://liveblocks.io](https://liveblocks.io)"
await stringifyCommentBody(comment.body, {
  format: "markdown",

  resolveUsers() {
    return [{ name: "Marc" }];
  },
});

// "<b>Hello</b> <span data-mention>@Marc</span> from
// <a href="https://liveblocks.io">https://liveblocks.io</a>"
await stringifyCommentBody(comment.body, {
  format: "html",

  resolveUsers() {
    return [{ name: "Marc" }];
  },
});

// "<b>Hello</b> <a href="https://example.com" data-id="marc@example.com">@Marc</a> from
// <a href="https://liveblocks.io">https://liveblocks.io</a>"
await stringifyCommentBody(comment.body, {
  format: "html",

  mention: ({ element, user }) =>
    `<a href="${user.profileUrl}" data-id="${element.id}">${user.name}</a>`,

  resolveUsers() {
    return [{ name: "Marc", profileUrl: "https://example.com" }];
  },
});
```

[`atob`]: https://developer.mozilla.org/en-US/docs/Web/API/atob
[`base-64`]: https://www.npmjs.com/package/base-64
[`client.enterRoom`]: /docs/api-reference/liveblocks-client#Client.enterRoom
[`client.getroom`]: /docs/api-reference/liveblocks-client#Client.getRoom
[`createclient`]: /docs/api-reference/liveblocks-client#createClient
[`fetch`]: https://developer.mozilla.org/en-US/docs/Web/API/Fetch_API
[`livelist`]: /docs/api-reference/liveblocks-client#LiveList
[`livemap`]: /docs/api-reference/liveblocks-client#LiveMap
[`liveobject`]: /docs/api-reference/liveblocks-client#LiveObject
[`lostconnectiontimeout`]:
  /docs/api-reference/liveblocks-client#createClientLostConnectionTimeout
[`toimmutable`]: /docs/api-reference/liveblocks-client#LiveObject.toImmutable
[`node-fetch`]: https://npmjs.com/package/node-fetch
[`room.broadcastevent`]:
  /docs/api-reference/liveblocks-client#Room.broadcastEvent
[`room.getstorage`]: /docs/api-reference/liveblocks-client#Room.getStorage
[`room.history`]: /docs/api-reference/liveblocks-client#Room.history
[`room.subscribe("event")`]:
  /docs/api-reference/liveblocks-client#Room.subscribe.event
[`room.subscribe("status")`]:
  /docs/api-reference/liveblocks-client#Room.subscribe.status
[`room.subscribe("lost-connection")`]:
  /docs/api-reference/liveblocks-client#Room.subscribe.lost-connection
[`room.subscribe("storage-status")`]:
  /docs/api-reference/liveblocks-client#Room.subscribe.storage-status
[`room.updatepresence`]:
  /docs/api-reference/liveblocks-client#Room.updatePresence
[`websocket`]: https://developer.mozilla.org/en-US/docs/Web/API/WebSocket
[`ws`]: https://www.npmjs.com/package/ws
[connection status example]:
  https://liveblocks.io/examples/connection-status/nextjs
