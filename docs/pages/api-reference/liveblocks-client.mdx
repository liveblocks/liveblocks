---
meta:
  title: "@liveblocks/client"
  parentTitle: "API Reference"
  description: "API Reference for the @liveblocks/client package"
alwaysShowAllNavigationLevels: false
---

`@liveblocks/client` provides you with JavaScript bindings for our realtime
collaboration APIs, built on top of WebSockets. Read our
[getting started](/docs/get-started) guides to learn more.

## createClient

Creates a [client](#Client) that allows you to connect to Liveblocks servers.
You must define either `authEndpoint` or `publicApiKey`. Resolver functions
should be placed inside here, and a number of other options are available.

```tsx
import { createClient } from "@liveblocks/client";

const client = createClient({
  authEndpoint: "/api/liveblocks-auth",

  // Other options
  // ...
});
```

```tsx title="Every createClient option" isCollapsable isCollapsed
import { createClient } from "@liveblocks/client";

const client = createClient({
  // Connect with authEndpoint
  authEndpoint: "/api/liveblocks-auth",

  // Alternatively, use an authEndpoint callback
  // authEndpoint: async (room) => {
  //   const response = await fetch("/api/liveblocks-auth", {
  //   method: "POST",
  //   headers: {
  //     Authentication: "<your own headers here>",
  //     "Content-Type": "application/json",
  //   },
  //   body: JSON.stringify({ room }),
  // });
  // return await response.json();
  // },

  // Alternatively, use a public key
  // publicApiKey: "pk_...",

  // Throttle time (ms) between WebSocket updates
  throttle: 100,

  // Prevent browser tab from closing while local changes arenâ€™t synchronized yet
  preventUnsavedChanges: false,

  // Throw lost-connection event after 5 seconds offline
  lostConnectionTimeout: 5000,

  // Disconnect users after X (ms) of inactivity, disabled by default
  backgroundKeepAliveTimeout: undefined,

  // Resolve user info for Comments, Text Editor, and Notifications
  resolveUsers: async ({ userIds }) => {
    const usersData = await __getUsersFromDB__(userIds);

    return usersData.map((userData) => ({
      name: userData.name,
      avatar: userData.avatar.src,
    }));
  },

  // Resolve room info for Notifications
  resolveRoomsInfo: async ({ roomIds }) => {
    const documentsData = await __getDocumentsFromDB__(roomIds);

    return documentsData.map((documentData) => ({
      name: documentData.name,
      // url: documentData.url,
    }));
  },

  // Resolve group info for Comments and Text Editor
  resolveGroupsInfo: async ({ groupIds }) => {
    const groupsData = await __getGroupsFromDB__(groupIds);

    return groupsData.map((groupData) => ({
      avatar: groupData.avatar.src,
      name: groupData.name,
      // description: groupData.description,
    }));
  },

  // Resolve mention suggestions for Comments and Text Editor
  resolveMentionSuggestions: async ({ text, roomId }) => {
    const workspaceUsers = await __getWorkspaceUsersFromDB__(roomId);

    if (!text) {
      // Show all workspace users by default
      return __getUserIds__(workspaceUsers);
    } else {
      const matchingUsers = __findUsers__(workspaceUsers, text);
      return __getUserIds__(matchingUsers);
    }
  },

  // Polyfill options for non-browser environments
  polyfills: {
    // atob,
    // fetch,
    // WebSocket,
  },

  // Set the location of the "Powered by Liveblocks" badge
  // "top-right", "bottom-right", "bottom-left", "top-left"
  badgeLocation: "bottom-right",
});
```

<PropertiesList title="Returns">
  <PropertiesListItem name="client" type="Client">
    Returns a [Client](#Client), used for connecting to Liveblocks.
  </PropertiesListItem>
</PropertiesList>

<PropertiesList title="Options">
  <PropertiesListItem
    name="authEndpoint"
    detailedType="string | async ((room?: string) => CustomAuthenticationResult)"
  >
    The URL of your back endâ€™s [authentication endpoint](/docs/authentication)
    as a string, or an async callback function that returns a Liveblocks token
    result. Either `authEndpoint` or `publicApiKey` are required. Learn more
    about [using a URL string](#createClientAuthEndpoint) and [using a
    callback](#createClientCallback).
  </PropertiesListItem>
  <PropertiesListItem name="publicApiKey" type="string">
    The public API key taken from your projectâ€™s
    [dashboard](/dashboard/apikeys). Generally not recommended for production
    use. Either `authEndpoint` or `publicApiKey` are required. [Learn
    more](#createClientPublicKey).
  </PropertiesListItem>
  <PropertiesListItem name="throttle" type="number" defaultValue="100">
    The throttle time between WebSocket messages in milliseconds, a number
    between `16` and `1000` is allowed. Using `16` means your app will update 60
    times per second. [Learn more](#createClientThrottle).
  </PropertiesListItem>
  <PropertiesListItem
    name="preventUnsavedChanges"
    type="boolean"
    defaultValue="false"
  >
    When set, navigating away from the current page is prevented while
    Liveblocks is still synchronizing local changes. [Learn
    more](#prevent-users-losing-unsaved-changes).
  </PropertiesListItem>
  <PropertiesListItem
    name="lostConnectionTimeout"
    type="number"
    defaultValue="5000"
  >
    After a user disconnects, the time in milliseconds before a
    [`"lost-connection"`](/docs/api-reference/liveblocks-client#Room.subscribe.lost-connection)
    event is fired. [Learn more](#createClientLostConnectionTimeout).
  </PropertiesListItem>
  <PropertiesListItem name="backgroundKeepAliveTimeout" type="number">
    The time before an inactive WebSocket connection is disconnected. This is
    disabled by default, but setting a number will activate it. [Learn
    more](#createClientBackgroundKeepAliveTimeout).
  </PropertiesListItem>
  <PropertiesListItem
    name="resolveUsers"
    detailedType='async? (args: ResolveUsersArgs) => (UserMeta["info"] | undefined)[] | undefined'
  >
    A function that resolves user information in
    [Comments](/docs/ready-made-features/comments), [Text Editor](/docs/ready-made-features/text-editor), and [Notifications](/docs/ready-made-features/notifications). Return an array of
    `UserMeta["info"]` objects in the same order they arrived. [Learn
    more](#createClientResolveUsers).
  </PropertiesListItem>
  <PropertiesListItem
    name="resolveRoomsInfo"
    detailedType="async? (args: ResolveRoomsInfoArgs) => (RoomInfo | undefined)[] | undefined"
  >
    A function that resolves room information in
    [Notifications](/docs/ready-made-features/notifications). Return an array of
    `RoomInfo` objects in the same order they arrived. [Learn
    more](#createClientResolveRoomsInfo).
  </PropertiesListItem>
  <PropertiesListItem
    name="resolveGroupsInfo"
    detailedType="async? (args: ResolveGroupsInfoArgs) => (GroupInfo | undefined)[] | undefined"
  >
    A function that resolves group information in
    [Comments](/docs/ready-made-features/comments) and [Text Editor](/docs/ready-made-features/text-editor). Return an array of
    `GroupInfo` objects in the same order they arrived. [Learn
    more](#createClientResolveGroupsInfo).
  </PropertiesListItem>
  <PropertiesListItem
    name="resolveMentionSuggestions"
    detailedType="async? (args: ResolveMentionSuggestionsArgs) => string[] | MentionData[]"
  >
    A function that resolves mention suggestions in
    [Comments](/docs/ready-made-features/comments) and [Text Editor](/docs/ready-made-features/text-editor). Return an array of user IDs or mention objects.
    [Learn more](#createClientResolveMentionSuggestions).
  </PropertiesListItem>
  <PropertiesListItem name="polyfills">
    Place polyfills for `atob`, `fetch`, and `WebSocket` inside here. Useful
    when using a non-browser environment, such as [Node.js](#createClientNode)
    or [React Native](#createClientReactNative).
  </PropertiesListItem>
  <PropertiesListItem
    name="largeMessageStrategy"
    detailedType='"default" | "split" | "experimental-fallback-to-http"'
    defaultValue={`"default"`}
  >
    <div className="-mb-3">
      How to handle WebSocket messages that are larger than the maximum message size. Can be set to one of these values:
    </div>

    - `"default"` Donâ€™t send anything, but log the error to the console and notify useErrorListener.
    - `"split"` Break the message up into chunks each of which is smaller than the maximum message size. Beware that using `"split"` will sacrifice atomicity of changes! Depending on your use case, this may or may not be problematic.
    - `"experimental-fallback-to-http"` Try sending the update over HTTP instead of WebSockets. This strategy is marked experimental, as it can make the client appear as "synchronizing" indefinitely when used with Liveblocks Storage or Yjs.

  </PropertiesListItem>
  <PropertiesListItem
    name="badgeLocation"
    detailedType='"top-right" | "bottom-right" | "bottom-left" | "top-left"'
    defaultValue={`"bottom-right"`}
  >
    The location of the "Powered by Liveblocks" badge. Can be set to either `"top-right"`, `"bottom-right"`, `"bottom-left"`, or `"top-left"`.
    [Learn more](#createClientBadgeLocation).
  </PropertiesListItem>
  <PropertiesListItem
    name="unstable_streamData"
    type="boolean"
    defaultValue="false"
  >
    Experimental. Stream the initial Storage content over HTTP, instead of
    waiting for a large initial WebSocket message to be sent from the server.
  </PropertiesListItem>
</PropertiesList>

### createClient with public key [#createClientPublicKey]

When creating a client with a public key, you donâ€™t need to set up an
authorization endpoint. We only recommend using a public key when prototyping,
or on public landing pages, as it makes it possible for end users to access any
roomâ€™s data. You should instead use an
[auth endpoint](#createClientAuthEndpoint).

```ts
import { createClient } from "@liveblocks/client";

const client = createClient({
  publicApiKey: "{{PUBLIC_KEY}}",
});
```

### createClient with auth endpoint [#createClientAuthEndpoint]

If you are not using a public key, you need to set up your own `authEndpoint`.
Please refer to our [Authentication guide](/docs/authentication).

```ts
import { createClient } from "@liveblocks/client";

const client = createClient({ authEndpoint: "/api/liveblocks-auth" });
```

### createClient with auth endpoint callback [#createClientCallback]

If you need to add additional headers or use your own function to call your
endpoint, `authEndpoint` can be provided as a custom callback. You should return
the token created with
[`Liveblocks.prepareSession`](/docs/api-reference/liveblocks-node#access-tokens)
or [`liveblocks.identifyUser`](/docs/api-reference/liveblocks-node#id-tokens),
learn more in [authentication guide](/docs/rooms/authentication).

```ts
import { createClient } from "@liveblocks/client";

const client = createClient({
  authEndpoint: async (room) => {
    // Fetch your authentication endpoint and retrieve your access or ID token
    // ...

    return { token: "..." };
  },
});
```

`room` is the room ID that the user is connecting to. When using
[Notifications](/docs/ready-made-features/comments/email-notifications), `room`
can be `undefined`, as the client is requesting a token that grants access to
multiple rooms, rather than a specific room.

#### Fetch your endpoint

Hereâ€™s an example of fetching your API endpoint at `/api/liveblocks-auth` within
the callback.

```ts
import { createClient } from "@liveblocks/client";

const client = createClient({
  authEndpoint: async (room) => {
    const response = await fetch("/api/liveblocks-auth", {
      method: "POST",
      headers: {
        Authentication: "<your own headers here>",
        "Content-Type": "application/json",
      },
      // Donâ€™t forget to pass `room` down. Note that it
      // can be undefined when using Notifications.
      body: JSON.stringify({ room }),
    });
    return await response.json();
  },
});
```

#### Token details

You should return the token created with
[`Liveblocks.prepareSession`](/docs/api-reference/liveblocks-node#access-tokens)
or [`liveblocks.identifyUser`](/docs/api-reference/liveblocks-node#id-tokens).
These are the values the functions can return.

1. A valid token, it returns a `{ "token": "..." }` shaped response.
1. A token that explicitly forbids access, it returns an
   `{ "error": "forbidden", "reason": "..." }` shaped response. If this is
   returned, the client will disconnect and wonâ€™t keep trying to authorize.

Any other error will be treated as an unexpected error, after which the client
will retry the request until it receives either 1. or 2.

### WebSocket throttle [#createClientThrottle]

By default, the client throttles the WebSocket messages sent to one every 100
milliseconds, which translates to 10 updates per second. Itâ€™s possible to
override that configuration with the `throttle` option with a value between `16`
and `1000` milliseconds.

```ts
import { createClient } from "@liveblocks/client";

const client = createClient({
  throttle: 16,

  // Other options
  // ...
});
```

This option is helpful for smoothing out realtime animations in your
application, as you can effectively increase the framerate without using any
interpolation. Here are some examples with their approximate frames per second
(FPS) values.

```ts
throttle:  16, // 60 FPS
throttle:  32, // 30 FPS
throttle: 200, //  5 FPS
```

### Prevent users losing unsaved changes [#prevent-users-losing-unsaved-changes]

Liveblocks usually synchronizes milliseconds after a local change, but if a user
immediately closes their tab, or if they have a slow connection, it may take
longer for changes to synchronize. Enabling `preventUnsavedChanges` will stop
tabs with unsaved changes closing, by opening a dialog that warns users. In
usual circumstances, it will very rarely trigger.

```tsx
import { createClient } from "@liveblocks/client";

const client = createClient({
  preventUnsavedChanges: true,

  // Other options
  // ...
});
```

More specifically, this option triggers when:

- There are unsaved changes after calling any hooks or methods, in all of our
  products.
- There are unsaved changes in a
  [Text Editor](/docs/ready-made-features/text-editor).
- Thereâ€™s an unsubmitted comment in the
  [Composer](/docs/api-reference/liveblocks-react-ui#Composer).
- The user has made changes and is currently offline.

Internally, this option uses the
[beforeunload event](https://developer.mozilla.org/en-US/docs/Web/API/Window/beforeunload_event).

### Lost connection timeout [#createClientLostConnectionTimeout]

If youâ€™re connected to a room and briefly lose connection, Liveblocks will
reconnect automatically and quickly. However, if reconnecting takes longer than
usual, for example if your network is offline, then the room will emit an event
informing you about this.

How quickly this event is triggered can be configured with the
`lostConnectionTimeout` setting, and it takes a number in milliseconds.
`lostConnectionTimeout` can be set between `1000` and `30000` milliseconds. The
default is `5000`, or 5 seconds.

```ts
import { createClient } from "@liveblocks/client";

const client = createClient({
  lostConnectionTimeout: 5000,

  // Other options
  // ...
});
```

You can listen to the event with [`room.subscribe("lost-connection")`][]. Note
that this also affects when `others` are reset to an empty array after a
disconnection. This helps prevent temporary flashes in your application as a
user quickly disconnects and reconnects. For a demonstration of this behavior,
see our [connection status example][].

### Background keep-alive timeout [#createClientBackgroundKeepAliveTimeout]

By default, Liveblocks applications will maintain an active WebSocket connection
to the Liveblocks servers, even when running in a browser tab thatâ€™s in the
background. However, if youâ€™d prefer for background tabs to disconnect after a
period of inactivity, then you can use `backgroundKeepAliveTimeout`.

When `backgroundKeepAliveTimeout` is specified, the client will automatically
disconnect applications that have been in an unfocused background tab for _at
least_ the specified time. When the browser tab is refocused, the client will
immediately reconnect to the room and synchronize the document.

```ts
import { createClient } from "@liveblocks/client";

const client = createClient({
  // Disconnect users after 15 minutes of inactivity
  backgroundKeepAliveTimeout: 15 * 60 * 1000,

  // Other options
  // ...
});
```

`backgroundKeepAliveTimeout` accepts a number in millisecondsâ€”we advise using a
value of at least a few minutes, to avoid unnecessary disconnections.

### resolveUsers [#createClientResolveUsers]

[Comments](/docs/ready-made-features/comments) and
[Text Editor](/docs/ready-made-features/text-editor) store user IDs in their
system, but no other user information. To display user information in Comments,
Text Editor, and Notifications components, such as a userâ€™s name or avatar, you
need to resolve these IDs into user objects. This function receives a list of
user IDs and you should return a list of user objects of the same size, in the
same order.

User IDs are automatically resolved in batches with a maximum of 50 users per
batch to optimize performance and prevent overwhelming your user resolution
function.

```tsx
import { createClient } from "@liveblocks/client";

const client = createClient({
  resolveUsers: async ({ userIds }) => {
    const usersData = await __getUsersFromDB__(userIds);

    return usersData.map((userData) => ({
      name: userData.name,
      avatar: userData.avatar.src,
    }));
  },

  // Other options
  // ...
});
```

The name and avatar you return are rendered in
[`Thread`](/docs/api-reference/liveblocks-react-ui#Thread) components.

#### User objects

The user objects returned by the resolver function take the shape of
`UserMeta["info"]`, which contains `name` and `avatar` by default. These two
values are optional, though if youâ€™re using the
[Comments default components](/docs/api-reference/liveblocks-react-ui#Components),
they are necessary. Hereâ€™s an example of `userIds` and the exact values
returned.

```ts
resolveUsers: async ({ userIds }) => {
  // ["marc@example.com", "nimesh@example.com"];
  console.log(userIds);

  return [
    { name: "Marc", avatar: "https://example.com/marc.png" },
    { name: "Nimesh", avatar: "https://example.com/nimesh.png" },
  ];
};
```

You can also return custom information, for example, a userâ€™s `color`:

```ts
resolveUsers: async ({ userIds }) => {
  // ["marc@example.com"];
  console.log(userIds);

  return [
    {
      name: "Marc",
      avatar: "https://example.com/marc.png",
      // +++
      color: "purple",
      // +++
    },
  ];
};
```

#### Accessing user data in React

You can access any values set within `resolveUsers` with the
[`useUser`](/docs/api-reference/liveblocks-react#useUser) hook.

```tsx
import { useUser } from "@liveblocks/react/suspense";

function Component() {
  const user = useUser("marc@example.com");

  // { name: "Marc", avatar: "https://...", ... }
  console.log(user);
}
```

### resolveRoomsInfo [#createClientResolveRoomsInfo]

When using
[Notifications](/docs/ready-made-features/comments/email-notifications) with
[Comments](/docs/ready-made-features/comments), room IDs will be used to
contextualize notifications (e.g. â€œChris mentioned you in _room-id_â€) in the
[`InboxNotification`](/docs/api-reference/liveblocks-react-ui#InboxNotification)
component. To replace room IDs with more fitting names (e.g. document names,
â€œChris mentioned you in _Document A_â€), you can provide a resolver function to
the `resolveRoomsInfo` option in [`createClient`](#createClient).

This resolver function will receive a list of room IDs and should return a list
of room info objects of the same size and in the same order.

```tsx
import { createClient } from "@liveblocks/client";

const client = createClient({
  resolveRoomsInfo: async ({ roomIds }) => {
    const documentsData = await __getDocumentsFromDB__(roomIds);

    return documentsData.map((documentData) => ({
      name: documentData.name,
      // url: documentData.url,
    }));
  },

  // Other options
  // ...
});
```

In addition to the roomâ€™s name, you can also provide a roomâ€™s URL as the `url`
property. If you do so, the
[`InboxNotification`](/docs/api-reference/liveblocks-react-ui#InboxNotification)
component will automatically use it. Itâ€™s possible to use an inbox
notificationâ€™s `roomId` property to construct a roomâ€™s URL directly in React and
set it on
[`InboxNotification`](/docs/api-reference/liveblocks-react-ui#InboxNotification)
via `href`, but the room ID might not be enough for you to construct the URL,
you might need to call your backend for example. In that case, providing it via
`resolveRoomsInfo` is the preferred way.

### resolveGroupsInfo [#createClientResolveGroupsInfo]

When using group mentions with [Comments](/docs/ready-made-features/comments)
and [Text Editor](/docs/ready-made-features/text-editor), group IDs will be used
instead of user IDs. Similarly to [`resolveUsers`](#createClientResolveUsers),
you can provide a resolver function to the `resolveGroupsInfo` option in
[`createClient`](#createClient) to assign information like names and avatars to
group IDs.

```tsx
import { createClient } from "@liveblocks/client";

const client = createClient({
  resolveGroupsInfo: async ({ groupIds }) => {
    const groupsData = await __getGroupsFromDB__(groupIds);

    return groupsData.map((groupData) => ({
      name: groupData.name,
      avatar: groupData.avatar.src,
    }));
  },

  // Other options
  // ...
});
```

#### Accessing group info in React

You can access any values set within `resolveGroupsInfo` with the
[`useGroupInfo`](/docs/api-reference/liveblocks-react#useGroupInfo) hook.

```tsx
import { useGroupInfo } from "@liveblocks/react/suspense";

function Component() {
  const group = useGroupInfo("group-engineering");

  // { name: "Engineering", avatar: "https://...", ... }
  console.log(group);
}
```

### resolveMentionSuggestions [#createClientResolveMentionSuggestions]

To enable creating mentions in [Comments](/docs/ready-made-features/comments)
and [Text Editor](/docs/ready-made-features/text-editor), you can provide a
resolver function to the `resolveMentionSuggestions` option in
[`createClient`](#createClient). These mentions will be displayed in the
[`Composer`](/docs/api-reference/liveblocks-react-ui#Composer) component and in
text editors.

This resolver function will receive the mention currently being typed (e.g. when
writing â€œ@janeâ€, `text` will be `jane`) and should return a list of user IDs
matching that text. This function will be called every time the text changes but
with some debouncing.

```tsx
import { createClient } from "@liveblocks/client";

const client = createClient({
  resolveMentionSuggestions: async ({ text, roomId }) => {
    const workspaceUsers = await __getWorkspaceUsersFromDB__(roomId);

    if (!text) {
      // Show all workspace users by default
      return __getUserIds__(workspaceUsers);
    } else {
      const matchingUsers = __findUsers__(workspaceUsers, text);
      return __getUserIds__(matchingUsers);
    }
  },

  // Other options
  // ...
});
```

#### Group mentions

To support group mentions in [Comments](/docs/ready-made-features/comments) and
[Text Editor](/docs/ready-made-features/text-editor), you can return a list of
mention objects instead of user IDs to suggest a mix of user and group mentions.

```tsx
import { createClient } from "@liveblocks/client";

const client = createClient({
  resolveMentionSuggestions: async ({ text, roomId }) => {
    const dbUsers = await __findUsersFromDB__(roomId);
    const dbGroups = await __findGroupsFromDB__(roomId);

    // Show groups and users matching the text being typed
    return [
      ...dbGroups.map((group) => ({
        kind: "group",
        id: group.id,
      })),
      ...dbUsers.map((user) => ({
        kind: "user",
        id: user.id,
      })),
    ];
  },

  // Other options
  // ...
});
```

The mention objects specify which kind of mention it is, the ID to mention (user
ID or group ID), etc.

```tsx
// A user mention suggestion
{
  kind: "user",
  id: "user-1",
}

// A group mention suggestion
{
  kind: "group",
  id: "group-1",
}

// A group mention suggestion with fixed group members
// When using fixed group members via `userIds`, they will take precedence
// if the group ID exists on Liveblocks.
{
  kind: "group",
  id: "here",
  members: ["user-1", "user-2"],
}
```

### createClient for Node.js [#createClientNode]

To use `@liveblocks/client` in Node.js, you need to provide [`WebSocket`][] and
[`fetch`][] polyfills. As polyfills, we recommend installing [`ws`][] and
[`node-fetch`][].

```bash
npm install ws node-fetch
```

Then, pass them to the `createClient` polyfill option as below.

```ts
import { createClient } from "@liveblocks/client";
import fetch from "node-fetch";
import WebSocket from "ws";

const client = createClient({
  polyfills: {
    fetch,
    WebSocket,
  },

  // Other options
  // ...
});
```

Note that `node-fetch` v3+
[does not support CommonJS](https://github.com/node-fetch/node-fetch/blob/main/docs/v3-UPGRADE-GUIDE.md#converted-to-es-module).
If you are using CommonJS, downgrade `node-fetch` to v2.

### createClient for React Native [#createClientReactNative]

To use `@liveblocks/client` with [React Native](https://reactnative.dev/), you
need to add an [`atob`][] polyfill. As a polyfill, we recommend installing
[`base-64`][].

```bash
npm install base-64
```

Then you can pass the `decode` function to our `atob` polyfill option when you
create the client.

```ts
import { createClient } from "@liveblocks/client";
import { decode } from "base-64";

const client = createClient({
  polyfills: {
    atob: decode,
  },

  // Other options
  // ...
});
```

### Powered by Liveblocks branding [#createClientBadgeLocation]

By default, Liveblocks displays a "Powered by Liveblocks" badge in your
application. You can adjust the position of the badge by setting the
`badgeLocation` property on `createClient`.

```ts title="Set badge location"
import { createClient } from "@liveblocks/client";

// "top-right", "bottom-right", "bottom-left", "top-left"
const client = createClient({
  badgeLocation: "bottom-right",

  // ...
});
```

If you wish to remove the badge entirely, you can do so by following these
steps:

1. In the Liveblocks dashboard, navigate to your
   [team's settings](/dashboard/settings).
2. Under **General**, toggle on the remove "Powered by Liveblocks" branding
   option.

<Banner title='Removing the "Powered by Liveblocks" badge'>

Removing the "Powered by Liveblocks" badge on your projects requires a
[paid plan](/pricing/). See the [pricing page](/pricing/) for more information.

</Banner>

## Client

Client returned by [`createClient`][] which allows you to connect to Liveblocks
servers in your application, and enter rooms.

### Client.enterRoom

Enters a room and returns both the local `Room` instance, and a `leave`
unsubscribe function. The authentication endpoint is called as soon as you call
this function. Used for setting [initial Presence](#setting-initial-presence)
and [initial Storage](#setting-initial-storage) values.

```ts
const { room, leave } = client.enterRoom("my-room-id", {
  // Options
  // ...
});
```

Note that itâ€™s possible to [add types to your room](#typing-your-data).

<PropertiesList title="Returns">
  <PropertiesListItem
    name="room"
    type="Room<Presence, Storage, UserMeta, RoomEvent>"
  >
    A [Room](#Room), used for building your Liveblocks application. Learn more
    about [typing your room](#typing-your-data).
  </PropertiesListItem>
  <PropertiesListItem name="leave" type="() => void">
    A function thatâ€™s used to leave the room and disconnect.
  </PropertiesListItem>
</PropertiesList>

<PropertiesList title="Arguments">
  <PropertiesListItem name="roomId" type="string" required>
    The ID of the room youâ€™re connecting to.
  </PropertiesListItem>
  <PropertiesListItem name="options.initialPresence" type="JsonObject">
    The initial Presence of the user entering the room. Each user has their own
    presence, and this is readable for all other connected users. A userâ€™s
    Presence resets every time they disconnect. This object must be
    JSON-serializable. [Learn more](#setting-initial-presence).
  </PropertiesListItem>
  <PropertiesListItem name="options.initialStorage" type="LsonObject">
    The initial Storage structure for the room when itâ€™s joined for the first
    time. This is only set a single time, when the room has not yet been
    populated. This object must contain [conflict-free live
    structures](/docs/api-reference/liveblocks-client#Storage). [Learn
    more](#setting-initial-storage).
  </PropertiesListItem>
  <PropertiesListItem
    name="options.autoConnect"
    type="boolean"
    defaultValue="true"
  >
    Whether the room immediately connects to Liveblocks servers.
  </PropertiesListItem>
</PropertiesList>

#### Setting initial Presence [#setting-initial-presence]

Presence is used for storing temporary user-based values, such as a userâ€™s
cursor coordinates, or their current selection. Each user has their own
presence, and this is readable for all other connected users. Set your initial
Presence value by using `initialPresence`.

```ts
const { room, leave } = client.enterRoom("my-room-id", {
  // +++
  initialPresence: {
    cursor: null,
    colors: ["red", "purple"],
    selection: {
      id: 72426,
    },
  },
  // +++

  // Other options
  // ...
});
```

Each userâ€™s Presence resets every time they disconnect, as this is only meant
for temporary data. Any JSON-serializable object is allowed (the `JsonObject`
type).

#### Setting initial Storage [#setting-initial-storage]

Storage is used to store permanent data thatâ€™s used in your application, such as
shapes on a whiteboard, nodes on a flowchart, or text in a form. The first time
a room is entered, you can set an initial value by using `initialStorage`.
`initialStorage` is only read and set a single time, unless a new top-level
property is added.

```ts
import { LiveList, LiveObject } from "@liveblocks/client";

const { room, leave } = client.enterRoom("my-room-id", {
  // +++
  initialStorage: {
    title: "Untitled",
    shapes: new LiveList([
      new LiveObject({ type: "rectangle", color: "yellow" }),
    ]),
  },
  // +++

  // Other options
  // ...
});
```

If a new top-level property is added to `initialStorage`, the next time a user
connects, the new property will be created. Other properties will be unaffected.
Any
[conflict-free live structures](/docs/api-reference/liveblocks-client#Storage)
and JSON-serializable objects are allowed (the `LsonObject` type).

#### Speed up connecting to a room [#speed-up-connecting-to-a-room]

To speed up connecting to a room, you can call
[`Liveblocks.prewarmRoom`](/docs/api-reference/liveblocks-node#get-rooms-roomId-prewarm)
on the server, which will warm up a room for the next 10 seconds. Triggering
this directly before a user navigates to a room is an easy to way use this API.

### Client.getRoom

Gets a room by its ID. Returns `null` if [`client.enterRoom`][] has not been
called previously.

```ts
const room = client.getRoom("my-room");
```

Itâ€™s unlikely youâ€™ll need this API if youâ€™re using the newer
[`client.enterRoom`][] API. Note that itâ€™s possible to
[add types to your room](#typing-your-data).

<PropertiesList title="Returns">
  <PropertiesListItem
    name="room"
    type="Room<Presence, Storage, UserMeta, RoomEvent> | null"
  >
    A [Room](#Room), used for building your Liveblocks application. Returns
    `null` if the room has not yet been joined by the current client. Learn more
    about [typing your room](#typing-your-data).
  </PropertiesListItem>
</PropertiesList>

<PropertiesList title="Arguments">
  <PropertiesListItem name="roomId" type="string" required>
    The ID of the room youâ€™re connecting to.
  </PropertiesListItem>
</PropertiesList>

### Client.getSyncStatus

Gets the current Liveblocks synchronization status.

```ts
const syncStatus = client.getSyncStatus();
// "synchronizing" | "synchronized"
```

<PropertiesList title="Returns">
  <PropertiesListItem name="returns" type={'"synchronizing" | "synchronized"'}>
    Will be `"synchronizing"` if there are any local changes to any part of
    Liveblocks that still need to be acknowledged by the server. Will be
    `"synchronized"` when all local changes have been persisted.
  </PropertiesListItem>
</PropertiesList>

### Client.logout

Purges any auth tokens from the clientâ€™s memory. If there are any rooms that are
still connected, they will be forced to reauthorize.

```ts
client.logout();
```

<PropertiesListEmpty title="Returns">_Nothing_</PropertiesListEmpty>

<PropertiesListEmpty title="Arguments">_None_</PropertiesListEmpty>

#### When to logout

Use this function if you have a single page application (SPA) and you wish to
log your user out, and reauthenticate them. This is a way to update your userâ€™s
`info` after a connection has begun.

## AI Copilots

### defineAiTool

Create a custom tool for your AI copilot to use. Defining tools allow the AI
copilot to look up information on-demand, render your own components based on
the toolâ€™s arguments, or perform actions in your application on behalf of the
current user, such as creating content, updating the application state, or
interacting with external services.

```tsx
import { defineAiTool } from "@liveblocks/client";

const myTool = defineAiTool()({
  description: "Fetch user information by ID",
  parameters: {
    type: "object",
    properties: {
      userId: { type: "string", description: "The userâ€™s unique identifier" },
    },
    required: ["userId"],
    additionalProperties: false,
  },
  execute: async ({ userId }) => {
    const user = await getUserById(userId);
    return { data: { user } };
  },
  render: ({ result }) => (
    <AiTool title="User Lookup" icon="ðŸ‘¤">
      {!result.data ? (
        <div>Looking up user...</div>
      ) : (
        <div>Found user: {result.data.user.name}</div>
      )}
    </AiTool>
  ),
});
```

<Banner>

Note that the function should be called like this `defineAiTool()({ ... })`
(double-parens). This allows TypeScriptâ€™s inference to work correctly. For the
best type inference experience, TypeScript 5.3 or higher is recommended. While
Liveblocks supports TypeScript 5.0+, full type inference for `defineAiTool()`
requires TypeScript 5.3+.

</Banner>

<PropertiesList title="Returns">
  <PropertiesListItem name="tool" type="AiOpaqueToolDefinition">
    An AI tool.
  </PropertiesListItem>
</PropertiesList>

<PropertiesList title="Arguments">
  <PropertiesListItem name="description" type="string" required>
    A clear description of what the tool does. Used by AI to understand when to
    call this tool.
  </PropertiesListItem>
  <PropertiesListItem name="parameters" type="JSONSchema7" required>
    JSON Schema defining the toolâ€™s input parameters. The AI will validate
    arguments against this schema.
  </PropertiesListItem>
  <PropertiesListItem name="enabled" type="boolean">
    Whether this tool should be enabled. When set to `false`, the tool will not
    be made available to the AI copilot for any new/future chat messages, but
    will still allow existing tool invocations to be rendered that are part of
    the historic chat record. Defaults to true.
  </PropertiesListItem>
  <PropertiesListItem name="execute" type="function">
    Async function that performs the toolâ€™s action. Receives validated arguments
    and execution context, returns structured data. See [implementing the tool
    call via `execute`](#implement-via-execute).
  </PropertiesListItem>
  <PropertiesListItem name="render" type="function">
    React component function that renders the toolâ€™s UI during different
    execution stages. See [tool call rendering
    stages](#tool-call-rendering-stages).
  </PropertiesListItem>
</PropertiesList>

Tools can be registered globally with
[`RegisterAiTool`](/docs/api-reference/liveblocks-react#RegisterAiTool) or
passed directly to [`AiChat`](/docs/api-reference/liveblocks-react-ui#AiChat).

### Tool call rendering stages [#tool-call-rendering-stages]

Rendering a tool call can be done before the tool call is executed, which allows
you to display a UI during its entire lifecycle. The tool call stages are:

- `receiving` (since [3.4]()) The tool call is being received and its args are
  being streamed in. During this stage, you can access `partialArgs` to display
  a UI while the tool call arguments are still being constructed, but before the
  tool call is executed.
- `executing` The tool call is currently executing, or is ready to be. In this
  stage, the `args` are fully known, but the result of the tool call is not
  known yet.
- `executed` The tool call has been executed, and the result is known. This
  happens after your `execute` function was run, or after you called `respond()`
  inside `render`. In this stage, the `result` object will be available.

The render component will automatically re-render when its stage changes.

### Implementing tool calls

When you implement a tool call, use one of these combinations:

1. Implement `execute` _and_ `render`
1. Implement only `execute`, but no `render`
1. Implement only `render`, but make sure to eventually call `respond()`

#### Implementing your tool call via `execute` [#implement-via-execute]

If you implement the `execute` function, this function will automatically be
invoked when the tool call gets made. The return value of this function will be
the result that will be passed back to the AI copilot.

- `{ data: any, description?: string }` The data to return in case of success.
  `data` must be a legal JSON value. Providing a description is optional. If you
  provide a description, it will be passed to the AI copilot to help it
  understand the returned data or to provide follow-up instructions for how to
  respond to this tool result.
- `{ error: string }` The error message in case the tool call failed to execute.
- `{ cancel: true | string }` If the tool call should be cancelled. You can
  optionally provide a cancel reason as an instruction to the AI copilot.

The returned value can be observed in the `render` method, through the `result`
param:

```tsx
defineAiTool()({
  /* ... */

  execute: async () => {
    await sleep(1000);
    return { data: { user: { name: "Alice" } } };
  },

  render: ({ result }) => {
    if (result.data) {
      return <div>Found user: {result.data.user.name}</div>;
    }

    // Tool hasnâ€™t executed yet
    return <Spinner />;
  },
});
```

If you do not implement `render` alongside `execute`, the tool call will still
be executed, but no UI will be displayed. The result will still be passed back
to the AI copilot.

#### Implementing your tool call via `render` [#implement-via-render]

Sometimes you may not want to immediately execute the tool call. This is most
common to build a Human-in-the-Loop (HITL) style UI where you want the user to
confirm or correct the tool callâ€™s behavior. In these scenarios, you do not want
to implement `execute`. Instead, you could display any UI, as long as you
eventually call the `respond` function that is provided to `render`â€™s props.

```tsx
defineAiTool()({
  /* ... */
  /* NOTE: No execute method used here! */

  render: ({ respond }) => {
    return (
      <div>
        <button
          onClick={() => {
            respond({ data: { user: { name: "Alice" } } });
          }}
        >
          Confirm
        </button>
        <button
          onClick={() => {
            respond({ cancel: true });
          }}
        >
          Cancel
        </button>
      </div>
    );
  },
});
```

In this example, until the Confirm button is clicked, the AI chat will remain in
â€œexecutingâ€ stage, awaiting the result of this tool call.

This example is for illustrative purposes only. In practice, using our
[`AiTool.Confirmation`](/docs/api-reference/liveblocks-react-ui#AiTool.Confirmation)
tool is preferred for building confirm/cancel flows.

Like with the `execute` function, the `respond` function should be called with a
value of this shape:

- `{ data: any, description?: string }` The data to return in case of success.
  `data` must be a legal JSON value. Providing a description is optional. If you
  provide a description, it will be passed to the AI copilot to help it
  understand the returned data or to provide follow-up instructions for how to
  respond to this tool result.
- `{ error: string }` The error message in case the tool call failed to execute.
- `{ cancel: true | string }` If the tool call should be cancelled. You can
  optionally provide a cancel reason as an instruction to the AI copilot.

#### Handling different tool call stages [#handling-stages]

You can handle all three stages of a tool call in your render function to
provide a smooth user experience during tool call streaming and execution:

```tsx
const bookFlightTool = defineAiTool()({
  description: "Book a flight for a user",
  parameters: {
    type: "object",
    properties: {
      origin: { type: "string", description: "Departure city" },
      destination: { type: "string", description: "Arrival city" },
      departureDate: {
        type: "string",
        description: "Departure date (YYYY-MM-DD)",
      },
      passengers: {
        type: "array",
        items: {
          type: "object",
          properties: {
            name: { type: "string" },
            age: { type: "number" },
          },
          required: ["name", "age"],
          additionalProperties: false,
        },
        description: "List of passengers",
      },
    },
    required: ["origin", "destination", "departureDate", "passengers"],
    additionalProperties: false,
  },
  execute: async ({ origin, destination, departureDate, passengers }) => {
    const booking = await bookFlight({
      origin,
      destination,
      departureDate,
      passengers,
    });
    return { data: { bookingId: booking.id } };
  },
  render: ({ stage, partialArgs, args, result }) => {
    return (
      <AiTool title="Flight Booking" icon="âœˆï¸">
        {stage === "receiving" && (
          <div>
            <h4>Preparing flight booking...</h4>
            {partialArgs.origin && <p>From: {partialArgs.origin}</p>}
            {partialArgs.destination && <p>To: {partialArgs.destination}</p>}
            {partialArgs.departureDate && (
              <p>Date: {partialArgs.departureDate}</p>
            )}
            {partialArgs.passengers && (
              <div>
                <p>Passengers ({partialArgs.passengers.length}):</p>
                <ul>
                  {partialArgs.passengers.map((passenger, index) => (
                    <li key={index}>
                      {passenger?.name || "Loading..."}
                      {passenger?.age && ` (${passenger.age})`}
                    </li>
                  ))}
                </ul>
              </div>
            )}
          </div>
        )}
        {stage === "executing" && (
          <div>
            <h4>Booking flight...</h4>
            <p>
              {args.origin} â†’ {args.destination} on {args.departureDate}
            </p>
            <p>{args.passengers.length} passenger(s)</p>
          </div>
        )}
        {stage === "executed" && result.data && (
          <div>
            <h4>Flight booked successfully!</h4>
            <p>Booking ID: {result.data.bookingId}</p>
          </div>
        )}
      </AiTool>
    );
  },
});
```

In this example, the tool arguments stream in progressively during the
`receiving` stage, causing multiple re-renders as each field appears:

- **1st render**: `{ stage: "receiving", partialArgs: {} }`
- **2nd render**: `{ stage: "receiving", partialArgs: { origin: "New York" } }`
- **3rd render**:
  `{ stage: "receiving", partialArgs: { origin: "New York", destination: "London" } }`
- **4th render**:
  `{ stage: "receiving", partialArgs: { origin: "New York", destination: "London", departureDate: "2024-12-15" } }`
- **5th render**: `{ stage: "receiving", partialArgs: { ..., passengers: [] } }`
- **6th render**:
  `{ stage: "receiving", partialArgs: { ..., passengers: [{ name: "John" }] } }`
- **7th render**:
  `{ stage: "receiving", partialArgs: { ..., passengers: [{ name: "John", age: 3 }] } }`
- **8th render**:
  `{ stage: "receiving", partialArgs: { ..., passengers: [{ name: "John", age: 30 }] } }`
- **Final render**: `{ stage: "executing", args: { /* complete object */ } }`

This demonstrates how each field and nested property appears incrementally,
providing real-time feedback to users as the AI constructs the tool call
arguments.

Arguments are streamed in forward-only order. Once a field begins appearing, all
previous fields are complete and wonâ€™t be modified. Youâ€™ll never see
`{ origin: "New York", destination: "London" }` followed by
`{ origin: "San Francisco", destination: "London" }`, but you might see
`{ origin: "New" }` then `{ origin: "New York" }` then
`{ origin: "New York", destination: "London" }`.

## Room

Room returned by [`client.enterRoom`][] (or [`client.getRoom`][]).

### Room.getPresence

Return the current userâ€™s Presence.
[Presence](/docs/ready-made-features/presence) is used to store custom
properties on each user that exist until the user disconnects. An example use
would be storing a userâ€™s cursor coordinates.

```ts
const presence = room.getPresence();

// { cursor: { x: 363, y: 723 } }
console.log(presence);
```

Presence is set with [`updatePresence`](#Room.updatePresence) and can be typed
when you [enter a room](#enter-room-typing-a-room). The example above is using
the following type:

```ts file="liveblocks.config.ts"
declare global {
  interface Liveblocks {
    Presence: {
      cursor: { x: number; y: number };
    };
  }
}
```

<PropertiesList title="Returns">
  <PropertiesListItem name="presence" type="TPresence">
    An object holding the Presence value for the currently connected user.
    Presence is set with [`updatePresence`](#Room.updatePresence). Will always
    be JSON-serializable. `TPresence` is the `Presence` type you set yourself,
    [learn more](#Typing-presence).
  </PropertiesListItem>
</PropertiesList>

<PropertiesListEmpty title="Arguments">_None_</PropertiesListEmpty>

### Room.updatePresence

Updates the current userâ€™s [Presence](/docs/ready-made-features/presence). Only
pass the properties you wish to updateâ€”any changes will be merged into the
current presence. The entire presence object will not be replaced.

```ts
room.updatePresence({ typing: true });
room.updatePresence({ status: "Online" });

// { typing: true, status: "Online" }
const presence = room.getPresence();
```

<PropertiesListEmpty title="Returns">_Nothing_</PropertiesListEmpty>

<PropertiesList title="Arguments">
  <PropertiesListItem name="update" type="TPresence" required>
    The updated Presence properties for the current user inside an object. The
    userâ€™s entire Presence object will not be replaced, instead these properties
    will be merged with the existing Presence. This object must be
    JSON-serializable.
  </PropertiesListItem>
  <PropertiesListItem
    name="options.addToHistory"
    type="boolean"
    defaultValue="false"
  >
    Adds Presence values to the history stack, meaning using undo and redo
    functions will change them. [Learn more](#add-presence-to-history).
  </PropertiesListItem>
</PropertiesList>

#### Add Presence to history [#add-presence-to-history]

By default, Presence values are not added to history. However, using the
`addToHistory` option will add items to the undo/redo stack.

```ts
room.updatePresence({ color: "blue" }, { addToHistory: true });
room.updatePresence({ color: "red" }, { addToHistory: true });
room.history.undo();

// { color: "blue" }
const presence = room.getPresence();
```

See [`room.history`][] for more information.

### Room.getOthers

Returns an array of currently connected users in the room. Returns a
[`User`](#user-type) object for each user. Note that you can also subscribe to
others using [`Room.subscribe("others")`](#Room.subscribe.others).

```ts
const others = room.getOthers();

for (const other of others) {
  const { connectionId, id, info, presence, canWrite, canComment } = other;
  // Do things
}
```

<PropertiesList title="Returns">
  <PropertiesListItem name="others" type="User<Presence, UserMeta>[]">
    An array holding each connected userâ€™s [`User`](#user-type) object. `User`
    contains the current userâ€™s Presence value, along with other information.
    Presence is set with [`updatePresence`](#Room.updatePresence). Returns an
    empty array when no other users are currently connected. Will always be
    JSON-serializable.
  </PropertiesListItem>
</PropertiesList>

<PropertiesListEmpty title="Arguments">_None_</PropertiesListEmpty>

### Room.broadcastEvent

Broadcast an event to other users in the Room. Events broadcast to the room can
be listened to with [`Room.subscribe("event")`][]. Takes a custom event payload
as first argument. Should be serializable to JSON.

```ts
room.broadcastEvent({ type: "REACTION", emoji: "ðŸ”¥" });
```

<PropertiesListEmpty title="Returns">_Nothing_</PropertiesListEmpty>

<PropertiesList title="Arguments">
  <PropertiesListItem name="event" type="TRoomEvent" required>
    The event to broadcast to every other user in the room. Must be
    JSON-serializable. `TRoomEvent` is the `RoomEvent` type you set yourself,
    [learn more](#typing-multiple-events).
  </PropertiesListItem>
  <PropertiesListItem
    name="options.shouldQueueEventIfNotReady"
    type="boolean"
    defaultValue="false"
  >
    Queue the event if the connection is currently closed, or has not been
    opened yet. Weâ€™re not sure if we want to support this option in the future
    so it might be deprecated to be replaced by something else. [Learn
    more](#broadcasting-an-event-when-disconnected).
  </PropertiesListItem>
</PropertiesList>

#### Receiving an event

To receive an event, use [`Room.subscribe("event")`][]. The `user` property
received on the other end is the senderâ€™s [`User`](#user-type) instance.

```ts
// User 1
room.broadcastEvent({ type: "REACTION", emoji: "ðŸ”¥" });

// User 2
const unsubscribe = room.subscribe("event", ({ event, user, connectionId }) => {
  //                                                  ^^^^ User 1
  if (event.type === "REACTION") {
    // Do something
  }
});
```

We recommend using a property such as `type`, so that itâ€™s easy to distinguish
between different events on the receiving end.

#### Typing multiple events [#typing-multiple-events]

When [defining your types](#typing-your-data), you can pass a `RoomEvent` type
in your config file to receive type hints in your app. To define multiple
different custom events, use a union.

```ts
declare global {
  interface Liveblocks {
    RoomEvent:
      | { type: "REACTION"; emoji: string }
      | { type: "ACTION"; action: string };
  }
}
```

```ts
room.subscribe("event", ({ event, user, connectionId }) => {
  if (event.type === "REACTION") {
    // Do something
  }
  if (event.type === "ACTION") {
    // Do something else
  }
});
```

#### Broadcasting an event when disconnected [#broadcasting-an-event-when-disconnected]

By default, broadcasting an event is a â€œfire and forgetâ€ action. If the sending
client is not currently connected to a room, the event is simply discarded. When
passing the `shouldQueueEventIfNotReady` option, the client will queue up the
event, and only send it once the connection to the room is (re)established.

<Banner>

Weâ€™re not sure if we want to support `shouldQueueEventIfNotReady` in the future,
so it may be deprecated and replaced with something else.

</Banner>

```ts
room.broadcastEvent(
  { type: "REACTION", emoji: "ðŸ”¥" },
  {
    // +++
    shouldQueueEventIfNotReady: true,
    // +++
  }
);
```

### Room.getSelf

Gets the current [`User`](#user-type). Returns `null` if the client is not yet
connected to the room.

```ts
const { connectionId, presence, id, info, canWrite, canComment } =
  room.getSelf();
```

<PropertiesList title="Returns">
  <PropertiesListItem name="user" type="User<Presence, UserMeta> | null">
    Returns the current [`User`](#user-type). Returns `null` if the client is
    not yet connected to the room.
  </PropertiesListItem>
</PropertiesList>

<PropertiesListEmpty title="Arguments">_None_</PropertiesListEmpty>

Hereâ€™s an example of a full return value, assuming `Presence` and `UserMeta`
[have been set](#user-type).

```ts
const user = room.getSelf();

// {
//   connectionId: 52,
//   presence: {
//     cursor: { x: 263, y: 786 },
//   },
//   id: "mislav.abha@example.com",
//   info: {
//     avatar: "/mislav.png",
//   },
//   canWrite: true,
//   canComment: true,
// }
console.log(user);
```

### Room.getStatus

Gets the current WebSocket connection status of the room. The possible value
are: `initial`, `connecting`, `connected`, `reconnecting`, or `disconnected`.

```ts
const status = room.getStatus();

// "connected"
console.log(status);
```

<PropertiesList title="Returns">
  <PropertiesListItem
    name="status"
    type={`"initial" | "connecting" | "connected" | "reconnecting" | "disconnected"`}
  >
    <div className="-mb-3">
    Returns the roomâ€™s current connection status. It can return one of five values:
    </div>

    - `"initial"` The room has not attempted to connect yet.
    - `"connecting"` The room is currently authenticating or connecting.
    - `"connected"` The room is connected.
    - `"reconnecting"` The room has disconnected, and is trying to connect again.
    - `"disconnected"` The room is disconnected, and is no longer attempting to connect.

  </PropertiesListItem>
</PropertiesList>

<PropertiesListEmpty title="Arguments">_None_</PropertiesListEmpty>

### Room.getStorageStatus

Get the Storage status. Use this to tell whether Storage has been synchronized
with the Liveblocks servers.

```ts
const status = room.getStorageStatus();

// "synchronizing"
console.log(status);
```

<PropertiesList title="Returns">
  <PropertiesListItem
    name="status"
    type={`"not-loaded" | "loading" | "synchronizing" | "synchronized"`}
  >
    <div className="-mb-3">
    The current roomâ€™s Storage status. `status` can be one of four types.
    </div>

    - `"not-loaded"` Storage has not been loaded yet as [`room.getStorage`][] has not been called.
    - `"loading"` Storage is currently loading for the first time.
    - `"synchronizing"` Local Storage changes are currently being synchronized.
    - `"synchronized"` Local Storage changes have been synchronized.

  </PropertiesListItem>
</PropertiesList>

<PropertiesListEmpty title="Arguments">_None_</PropertiesListEmpty>

### Room.subscribe(storageItem)

Subscribe to updates on a particular storage item, and takes a callback function
thatâ€™s called when the storage item is updated. The Storage `root` is a
[`LiveObject`][], which means you can subscribe to this, as well as other live
structures. Returns an unsubscribe function.

```ts
const { root } = await room.getStorage();

const unsubscribe = room.subscribe(root, (updatedRoot) => {
  // Do something
});
```

<PropertiesList title="Returns">
  <PropertiesListItem name="unsubscribe" type="() => void">
    Unsubscribe function. Call it to cancel the subscription.
  </PropertiesListItem>
</PropertiesList>

<PropertiesList title="Arguments">
  <PropertiesListItem
    name="storageItem"
    type="L extends (LiveObject | LiveMap | LiveList)"
    required
  >
    The `LiveObject`, `LiveMap`, or `LiveList` which is being subscribed to.
    Each time the structure is updated, the callback is called.
  </PropertiesListItem>
  <PropertiesListItem name="callback" type="(node: L) => void" required>
    Function thatâ€™s called when `storageItem` updates. Returns the updated
    storage structure.
  </PropertiesListItem>
  <PropertiesListItem name="options.isDeep" type="boolean">
    Subscribe to both `storageItem` and its children. The callback function will
    be passed a list of updates instead of just the new Storage item. [Learn
    more](#listening-for-nested-changes).
  </PropertiesListItem>
</PropertiesList>

#### Typing Storage

To type the Storage values you receive, make sure to set your `Storage` type.

```ts file="liveblocks.config.ts"
import { LiveList } from "@liveblocks/client";

declare global {
  interface Liveblocks {
    Storage: {
      animals: LiveList<{ name: string }>;
    };
  }
}
```

The type received in the callback will match the type passed. Learn more under
[typing your room](#typing-your-data).

```ts
const { root } = await room.getStorage();
const animals = root.get("animals");

const unsubscribe = room.subscribe(animals, (updatedAnimals) => {
  // LiveList<[{ name: "Fido" }, { name: "Felix" }]>
  console.log(updatedAnimals);
});
```

#### Subscribe to any live structure

You can subscribe to any live structure, be it the Storage `root`, a child, or a
structure even more deeply nested.

```ts file="liveblocks.config.ts"
import { LiveMap, LiveObject } from "@liveblocks/client";

type Person = LiveObject<{ name: string; age: number }>;

declare global {
  interface Liveblocks {
    Storage: {
      people: LiveMap<string, Person>;
    };
  }
}
```

```ts
const { root } = await room.getStorage();
const people = root.get("people");
const steven = people.get("steven");

const unsubscribeRoot = room.subscribe(root, (updatedRoot) => {
  // ...
});

const unsubscribePeople = room.subscribe(people, (updatedPeople) => {
  // ...
});

const unsubscribeSteven = room.subscribe(steven, (updatedSteven) => {
  // ...
});
```

#### Listening for nested changes [#listening-for-nested-changes]

Itâ€™s also possible to subscribe to a Storage item and all of its children by
passing an optional `isDeep` option in the third argument. In this case, the
callback will be passed a list of updates instead of just the new Storage item.
Each such update is a `{ type, node, updates }` object.

```ts
const { root } = await room.getStorage();

const unsubscribe = room.subscribe(
  root,
  (storageUpdates) => {
    for (const update of storageUpdates) {
      const {
        type, // "LiveObject", "LiveList", or "LiveMap"
        node,
        updates,
      } = update;
      switch (type) {
        case "LiveObject": {
          // updates["property"]?.type; is "update" or "delete"
          // update.node is the LiveObject that has been updated/deleted
          break;
        }
        case "LiveMap": {
          // updates["key"]?.type; is "update" or "delete"
          // update.node is the LiveMap that has been updated/deleted
          break;
        }
        case "LiveList": {
          // updates[0]?.type; is "delete", "insert", "move", or "set"
          // update.node is the LiveList that has been updated, deleted, or modified
          break;
        }
      }
    }
  },
  { isDeep: true }
);
```

#### Using async functions

You use an `async` function inside the subscription callback, though bear in
mind that the callback itself is synchronous, and thereâ€™s no guarantee the
`async` function will complete before the callback is run again.

```ts
const { root } = await room.getStorage();

const unsubscribe = room.subscribe(root, (updatedRoot) => {
  async function doThing() {
    await fetch(/* ... */);
  }

  doThing();
});
```

If the order of updates is important in your application, and itâ€™s important to
ensure that your `async` function doesnâ€™t start before the previous one
finishes, you can use a package such as
[`async-mutex`](https://www.npmjs.com/package/async-mutex) to help you with
this. Using `runExclusive` will effectively form a queue for all upcoming
updates, guaranteeing serial execution.

```ts
import { Mutex } from "async-mutex";

const { root } = await room.getStorage();
const myMutex = new Mutex();

const unsubscribeUpdates = room.subscribe(root, (root) => {
  void myMutex.runExclusive(async () => {
    await fetch(/* ... */);
  });
});
```

Note that this may cause a performance penalty in your application, as certain
updates will be ignored.

### Room.subscribe("event") [#Room.subscribe.event]

Subscribe to events broadcast by [`Room.broadcastEvent`][]. Takes a callback
thatâ€™s run when another user calls [`Room.broadcastEvent`][]. Provides the
`event` along with the `user` and their `connectionId` of the user that sent the
message. Returns an unsubscribe function.

```ts
// User 1
room.broadcastEvent({ type: "REACTION", emoji: "ðŸ”¥" });

// +++
// User 2
const unsubscribe = room.subscribe("event", ({ event, user, connectionId }) => {
  //                                                  ^^^^ Will be User 1
  if (event.type === "REACTION") {
    // Do something
  }
});
// +++
```

<PropertiesList title="Returns">
  <PropertiesListItem name="unsubscribe" type="() => void">
    Unsubscribe function. Call it to cancel the subscription.
  </PropertiesListItem>
</PropertiesList>

<PropertiesList title="Arguments">
  <PropertiesListItem name="eventType" type={`"event"`} required>
    Listen to events.
  </PropertiesListItem>
  <PropertiesListItem
    name="callback"
    detailedType="(event: RoomEventMessage<Presence, UserMeta, RoomEvent>) => void"
    required
  >
    Function thatâ€™s called when another user sends an event. Receives the event,
    the [`user`](#user-type) that sent the event, and their `connectionId`. If
    this event was sent via
    [`liveblocks.broadcastEvent`](/docs/api-reference/liveblocks-node#post-broadcast-event)
    or the [Broadcast event
    API](/docs/api-reference/rest-api-endpoints#post-broadcast-event), `user`
    will be `null` and `connectionId` will be `-1`. [Learn
    more](#receiving-events-from-the-server)
  </PropertiesListItem>
</PropertiesList>

#### Typing events

When [defining your types](#typing-your-data), you can pass a `RoomEvent` type
to your config file to receive type hints in your app. To define multiple
different custom events, use a union.

```ts
declare global {
  interface Liveblocks {
    RoomEvent:
      | { type: "REACTION"; emoji: string }
      | { type: "ACTION"; action: string };
  }
}
```

```ts
room.subscribe("event", ({ event, user, connectionId }) => {
  if (event.type === "REACTION") {
    // Do something
  }
  if (event.type === "ACTION") {
    // Do something else
  }
});
```

#### Receiving events from the server [#receiving-events-from-the-server]

Events can be received from the server with either
[`liveblocks.broadcastEvent`](/docs/api-reference/liveblocks-node#post-broadcast-event)
or the
[Broadcast Event API](/docs/api-reference/rest-api-endpoints#post-broadcast-event).
In events sent from the server, `user` will be `null`, and `connectionId` will
be `-1`.

```ts
import { Liveblocks } from "@liveblocks/node";

const liveblocks = new Liveblocks({
  secret: "{{SECRET_KEY}}",
});

export async function POST() {
  await liveblocks.broadcastEvent({ type: "REACTION", emoji: "ðŸ”¥" });
}
```

```ts
const unsubscribe = room.subscribe("event", ({ event, user, connectionId }) => {
  // `null`, `-1`
  console.log(user, connectionId);
});
```

### Room.subscribe("my-presence") [#Room.subscribe.my-presence]

Subscribe to the current userâ€™s Presence. Takes a callback that is called every
time the current user presence is updated with [`Room.updatePresence`][].
Returns an unsubscribe function.

```ts
const unsubscribe = room.subscribe("my-presence", (presence) => {
  // Do something
});
```

<PropertiesList title="Returns">
  <PropertiesListItem name="unsubscribe" type="() => void">
    Unsubscribe function. Call it to cancel the subscription.
  </PropertiesListItem>
</PropertiesList>

<PropertiesList title="Arguments">
  <PropertiesListItem name="eventType" type={`"my-presence"`} required>
    Listen to the current userâ€™s presence.
  </PropertiesListItem>
  <PropertiesListItem
    name="callback"
    type="(presence: TPresence) => void"
    required
  >
    Function thatâ€™s called when the current userâ€™s Presence has updated, for
    example with [`Room.updatePresence`][]. Receives the updates Presence value.
  </PropertiesListItem>
</PropertiesList>

#### Typing Presence

To type the Presence values you receive, make sure to set your Presence type.

```ts file="liveblocks.config.ts"
declare global {
  interface Liveblocks {
    Presence: {
      status: string;
      cursor: { x: number; y: number };
    };
  }
}
```

The type received in the callback will match the type passed. Learn more under
[typing your data](#typing-your-data).

```ts
const unsubscribe = room.subscribe("my-presence", (presence) => {
  // { status: "typing", cursor: { x: 45, y: 67 }
  console.log(presence);
});
```

### Room.subscribe("others") [#Room.subscribe.others]

Subscribe to every other usersâ€™ updates. Takes a callback thatâ€™s called when a
userâ€™s Presence updates, or when they enter or leave the room. Returns an
unsubscribe function.

```ts
const unsubscribe = room.subscribe("others", (others, event) => {
  // Do something
});
```

<PropertiesList title="Returns">
  <PropertiesListItem name="unsubscribe" type="() => void">
    Unsubscribe function. Call it to cancel the subscription.
  </PropertiesListItem>
</PropertiesList>

<PropertiesList title="Arguments">
  <PropertiesListItem name="eventType" type={`"others"`} required>
    Listen to others.
  </PropertiesListItem>
  <PropertiesListItem
    name="callback"
    type="(others: User<Presence, UserMeta>[], event: OthersEvent) => void"
    required
  >
    Function thatâ€™s called when another userâ€™s Presence has updated, for example
    with [`Room.updatePresence`][], or an others event has occurred. Receives an
    array of [`User`](#user-type) values for each currently connected user. Also
    received an object with information about the event that has triggered the
    update, [learn more](#listening-for-others-events).
  </PropertiesListItem>
</PropertiesList>

#### Typing Presence

To type the Presence values you receive, make sure to set your Presence type.

```ts file="liveblocks.config.ts"
declare global {
  interface Liveblocks {
    Presence: {
      status: string;
      cursor: { x: number; y: number };
    };
  }
}
```

The type received in the callback will match the type passed. Learn more under
[typing your data](#typing-your-data).

```ts
const unsubscribe = room.subscribe("others", (others, event) => {
  // { status: "typing", cursor: { x: 45, y: 67 }
  console.log(others[0].presence);
});
```

#### Listening for others events [#listening-for-others-events]

The `event` parameter returns information on why the callback has just run, for
example if their Presence has updated, if theyâ€™ve just left or entered the room,
or if the current user has disconnected.

```ts
const unsubscribe = room.subscribe("others", (others, event) => {
  if (event.type === "leave") {
    // A user has left the room
    // event.user;
  }

  if (event.type === "enter") {
    // A user has entered the room
    // event.user;
  }

  if (event.type === "update") {
    // A user has updated
    // event.user;
    // event.updates;
  }

  if (event.type === "reset") {
    // A disconnection has occurred and others has reset
  }
});
```

#### Live cursors

Hereâ€™s a basic example showing you how to render live cursors.
[`Room.updatePresence`](/docs/api-reference/liveblocks-client#Room.updatePresence)
is being used to update each userâ€™s cursor position.

```ts file="liveblocks.config.ts"
declare global {
  interface Liveblocks {
    Presence: {
      cursor: { x: number; y: number };
    };
  }
}
```

```ts
const { room, leave } = client.enterRoom("my-room-id");

// Call this to update the current userâ€™s Presence
function updateCursorPosition({ x, y }) {
  room.updatePresence({ cursor: { x, y } });
}

const others = room.getOthers();

// Run __renderCursor__ when any other connected user updates their presence
const unsubscribe = room.subscribe("others", (others, event) => {
  for (const { id, presence } of others) {
    const { x, y } = presence.cursor;
    __renderCursor__(id, { x, y });
  }
}

// Handle events and rendering
// ...
```

Check our [examples page](/examples/browse/cursors) for live demos.

### Room.subscribe("status") [#Room.subscribe.status]

Subscribe to WebSocket connection status updates. Takes a callback that is
called whenever the connection status changes. Possible value are: `initial`,
`connecting`, `connected`, `reconnecting`, or `disconnected`. Returns an
unsubscribe function.

```ts
const unsubscribe = room.subscribe("status", (status) => {
  // "connected"
  console.log(status);
});
```

<PropertiesList title="Returns">
  <PropertiesListItem name="unsubscribe" type="() => void">
    Unsubscribe function. Call it to cancel the subscription.
  </PropertiesListItem>
</PropertiesList>

<PropertiesList title="Arguments">
  <PropertiesListItem name="eventType" type={`"status"`} required>
    Listen to status updates.
  </PropertiesListItem>
  <PropertiesListItem
    name="callback"
    detailedType={`(status: "initial" | "connecting" | "connected" | "reconnecting" | "disconnected") => void`}
    required
  >
    <div className="-mb-3">
    Function thatâ€™s called when the roomâ€™s connection status has changed. It can return one of five values:
    </div>

    - `"initial"` The room has not attempted to connect yet.
    - `"connecting"` The room is currently authenticating or connecting.
    - `"connected"` The room is connected.
    - `"reconnecting"` The room has disconnected, and is trying to connect again.
    - `"disconnected"` The room is disconnected, and is no longer attempting to connect.

  </PropertiesListItem>
</PropertiesList>

#### When to use status

Status is a low-level API that exposes the WebSocketâ€™s connectivity status. You
can use this, for example, to update a connection status indicator in your UI.
It would be normal for a client to briefly lose the connection and restore it
with quick `connected` â†’ `reconnecting` â†’ `connected` status jumps.

```ts
let indicator = "âšª";

const unsubscribe = room.subscribe("status", (status) => {
  switch (status) {
    case "connecting":
      indicator = "ðŸŸ¡";
      break;
    case "connected":
      indicator = "ðŸŸ¢";
      break;
    // ...
  }
});
```

If youâ€™d like to let users know that there may be connectivity issues, donâ€™t use
this API, but instead refer to [`Room.subscribe("lost-connection")`][] which was
specially built for this purpose.

Do not use this API to detect when Storage or Presence are initialized or
loaded. "Connected" does not guarantee that Storage or Presence are ready. To
detect when Storage is loaded, rely on awaiting the [`Room.getStorage`][]
promise or using the [`Room.subscribe("storage-status")`][] event.

### Room.subscribe("lost-connection") [#Room.subscribe.lost-connection]

A special-purpose event that will fire when a previously connected Liveblocks
client has lost connection, for example due to a network outage, and was unable
to recover quickly. This event is
[designed to help improve UX for your users](#when-to-use-lost-connection-events),
and will not trigger on short interruptions, those that are less than
[5 seconds by default](#setting-lost-connection-timeout). The event only
triggers if a previously connected client disconnects.

```ts
const unsubscribe = room.subscribe("lost-connection", (event) => {
  // "lost"
  console.log(event);
});
```

<PropertiesList title="Returns">
  <PropertiesListItem name="unsubscribe" type="() => void">
    Unsubscribe function. Call it to cancel the subscription.
  </PropertiesListItem>
</PropertiesList>

<PropertiesList title="Arguments">
  <PropertiesListItem name="eventType" type={`"lost-connection"`} required>
    Listen to lost connection events.
  </PropertiesListItem>
  <PropertiesListItem
    name="callback"
    detailedType={`(event: "lost" | "restored" | "failed") => void`}
    required
  >
    <div className="-mb-3">
    Function thatâ€™s called when a roomâ€™s lost connection event has been triggered. It can return one of three values:
    </div>

    - `"lost"` A connection has been lost for longer than [`lostConnectionTimeout`][].
    - `"restored"` The connection has been restored again.
    - `"failed"` The room has been unable to reconnect again, and is no longer trying. This may happen if a userâ€™s
    network has recovered, but the roomâ€™s authentication values no longer allow them to enter.

  </PropertiesListItem>
</PropertiesList>

#### When to use lost connection events [#when-to-use-lost-connection-events]

Lost connections events allows you to build high-quality UIs by warning your
users that the application is still trying to re-establish the connection, for
example through a toast notification. You may want to take extra care in the
mean time to ensure their changes wonâ€™t go unsaved, or to help them understand
why theyâ€™re not seeing updates made by others yet.

When this happens, this callback is called with the event `lost`. Then, once the
connection restores, the callback will be called with the value `restored`. If
the connection could definitively not be restored, it will be called with
`failed` (uncommon).

```ts
import { toast } from "my-preferred-toast-library";

const unsubscribe = room.subscribe("lost-connection", (event) => {
  switch (event) {
    case "lost":
      toast.warn("Still trying to reconnect...");
      break;

    case "restored":
      toast.success("Successfully reconnected again!");
      break;

    case "failed":
      toast.error("Could not restore the connection");
      break;
  }
});
```

#### Setting lost connection timeout [#setting-lost-connection-timeout]

The [`lostConnectionTimeout`][] configuration option will determine how quickly
the event triggers after a connection loss occurs. By default, itâ€™s set to
`5000`ms, which is 5 seconds.

```ts
import { createClient } from "@liveblocks/client";

const client = createClient({
  // Throw lost-connection event after 5 seconds offline
  lostConnectionTimeout: 5000,

  // ...
});
```

### Room.subscribe("error") [#Room.subscribe.error]

Subscribe to unrecoverable room connection errors. This event will be emitted
immediately before the client disconnects and wonâ€™t try reconnecting again.
Returns an unsubscribe function. If youâ€™d like to retry connecting, call
[`room.reconnect`][].

```ts
const unsubscribe = room.subscribe("error", (error) => {
  switch (error.context.code) {
    case -1:
      // Authentication error
      break;

    case 4001:
      // Could not connect because you donâ€™t have access to this room
      break;

    case 4005:
      // Could not connect because room was full
      break;

    case 4006:
      // The room ID has changed, get the new room ID (use this for redirecting)
      const newRoomId = error.message;
      break;

    default:
      // Unexpected error
      break;
  }
});
```

<PropertiesList title="Returns">
  <PropertiesListItem name="unsubscribe" type="() => void">
    Unsubscribe function. Call it to cancel the subscription.
  </PropertiesListItem>
</PropertiesList>

<PropertiesList title="Arguments">
  <PropertiesListItem name="eventType" type={`"error"`} required>
    Listen to error events.
  </PropertiesListItem>
  <PropertiesListItem
    name="callback"
    detailedType={`(error: LiveblocksError) => void`}
    required
  >
    <div className="-mb-3">
    Function thatâ€™s called when an unrecoverable error event has been triggered. `error.code` can return one of these
    values:
    </div>

    - `-1` Authentication error.
    - `4001` Could not connect because you donâ€™t have access to this room.
    - `4005` Could not connect because room was full.
    - `4006` The room ID has changed.

  </PropertiesListItem>
</PropertiesList>

#### When to use error events

You can use this event to trigger a â€œNot allowedâ€ screen/dialog. It can also be
helpful for implementing a redirect to another page.

```ts
const unsubscribe = room.subscribe("error", (error) => {
  // Could not connect because you donâ€™t have access to this room
  if (error.context.code === 4001)
    return __displayForbiddenEntryDialog__();
  }
});
```

#### When a room ID has changed

When a room ID has been changed with
[`liveblocks.updateRoomId`](/docs/api-reference/liveblocks-node#post-rooms-update-roomId)
or the
[Update Room ID API](/docs/api-reference/rest-api-endpoints#post-rooms-update-roomId),
`error.message` will contain the new room ID.

```ts
const unsubscribe = room.subscribe("error", (error) => {
  // The room ID has changed, get the new room ID
  if (error.context.code === 4006)
    const newRoomId = error.message;
    return __redirect__(`/app/${newRoomId}`)
  }
});
```

### Room.subscribe("history") [#Room.subscribe.history]

Subscribe to the current userâ€™s history changes. Returns an unsubscribe
function.

```ts
const unsubscribe = room.subscribe("history", ({ canUndo, canRedo }) => {
  // Do something
});
```

<PropertiesList title="Returns">
  <PropertiesListItem name="unsubscribe" type="() => void">
    Unsubscribe function. Call it to cancel the subscription.
  </PropertiesListItem>
</PropertiesList>

<PropertiesList title="Arguments">
  <PropertiesListItem name="eventType" type={`"history"`} required>
    Listen to history events.
  </PropertiesListItem>
  <PropertiesListItem
    name="callback"
    detailedType={`({ canUndo: boolean, canRedo: boolean }) => void`}
    required
  >
    Function thatâ€™s called when the current userâ€™s history changes. Returns
    booleans that describe whether the user can use
    [undo](/docs/api-reference/liveblocks-client#Room.history.undo) or
    [redo](/docs/api-reference/liveblocks-client#Room.history.redo).
  </PropertiesListItem>
</PropertiesList>

### Room.subscribe("storage-status") [#Room.subscribe.storage-status]

Subscribe to Storage status changes. Use this to tell whether Storage has been
synchronized with the Liveblocks servers. Returns an unsubscribe function.

```ts
const unsubscribe = room.subscribe("storage-status", (status) => {
  switch (status) {
    case "not-loaded":
      // Storage has not been loaded yet
      break;
    case "loading":
      // Storage is currently loading
      break;
    case "synchronizing":
      // Local Storage changes are being synchronized
      break;
    case "synchronized":
      // Local Storage changes have been synchronized
      break;
  }
});
```

<PropertiesList title="Returns">
  <PropertiesListItem name="unsubscribe" type="() => void">
    Unsubscribe function. Call it to cancel the subscription.
  </PropertiesListItem>
</PropertiesList>

<PropertiesList title="Arguments">
  <PropertiesListItem name="eventType" type={`"storage-status"`} required>
    Listen to Storage status events.
  </PropertiesListItem>
  <PropertiesListItem
    name="callback"
    detailedType={`(status: "not-loaded" | "loading" | "synchronizing" | "synchronized") => void`}
    required
  >
    <div className="-mb-3">
    Function thatâ€™s called when the current userâ€™s Storage updated status have
    changed. `status` can be one of four types.
    </div>

    - `"not-loaded` - Storage has not been loaded yet as [`getStorage`][] has not been called.
    - `"loading"` - Storage is currently loading for the first time.
    - `"synchronizing"` - Local Storage changes are currently being synchronized.
    - `"synchronized"` - Local Storage changes have been synchronized

  </PropertiesListItem>
</PropertiesList>

### Room.batch

Batches Storage and Presence modifications made during the given function. Each
modification is grouped together, which means that other clients receive the
changes as a single message after the batch function has run. When undoing or
redoing these changes, the entire batch will be undone/redone together instead
of atomically.

```ts
const { root } = await room.getStorage();

room.batch(() => {
  root.set("x", 0);
  room.updatePresence({ cursor: { x: 100, y: 100 } });
});
```

<PropertiesList title="Returns">
  <PropertiesListItem name="return" type="T">
    Returns the return value from the callback.
  </PropertiesListItem>
</PropertiesList>

<PropertiesList title="Arguments">
  <PropertiesListItem name="callback" type="() => T" required>
    A callback containing every Storage and Presence notification that will be
    part of the batch. Cannot be an `async` function.
  </PropertiesListItem>
</PropertiesList>

#### When to batch updates

For the most part, _you donâ€™t need to batch updates_. For example, given a
[whiteboard application](/examples/browse/whiteboard), itâ€™s perfectly fine to
update a noteâ€™s position on the board multiple times per second, in separate
updates. However, should you implement a â€œDelete allâ€ button, that may delete 50
notes at once, this is where you should use a batch.

```ts
const { root } = await room.getStorage();
const notes = root.get("notes");

// âœ… Batch simultaneous changes together
room.batch(() => {
  for (const noteId of notes.keys()) {
    notes.delete(noteId);
  }
});
```

This batch places each
[`LiveMap.delete`](/docs/api-reference/liveblocks-client#LiveMap.delete) call
into a single WebSocket update, instead of sending multiple updates. This will
be much quicker.

#### Batching groups history changes

Batching changes will also group changes into a single history state.

```ts
const { root } = await room.getStorage();
const pet = root.set("pet", new LiveObject({ name: "Fido", age: 5 }));

// âœ… Batch groups changes into one
room.batch(() => {
  pet.set("name", "Felix");
  pet.set("age", 10);
});

// { name: "Felix", age: 10 }
pet.toImmutable();

room.history.undo();

// { name: "Fido", age: 5 }
pet.toImmutable();
```

#### Doesnâ€™t work with async functions

Note that `room.batch` cannot take an `async` function.

```tsx
// âŒ Wonâ€™t work
room.batch(async () => {
  // ...
});

// âœ… Will work
room.batch(() => {
  // ...
});
```

### Room.history

Roomâ€™s history contains functions that let you undo and redo operations made to
Storage and Presence on the current client. Each user has a separate history
stored in memory, and history is reset when the page is reloaded.

```ts
const { undo, redo, pause, resume /*, ... */ } = room.history;
```

<Banner title="History in Yjs">

Note that to undo or redo in Yjs, you must use a separate history manager,
[`Y.UndoManager`](https://docs.yjs.dev/api/undo-manager).

</Banner>

#### Add Presence to history

By default, history is only enabled for Storage. However, you can use the
`addToHistory` option to additionally
[add Presence state to history](/docs/api-reference/liveblocks-client#add-presence-to-history).

```tsx
room.updatePresence({ color: "blue" }, { addToHistory: true });
```

### Room.history.undo

Reverts the last operation. It does not impact operations made by other clients,
and will only undo changes made by the current client.

```ts
const person = new LiveObject();
person.set("name", "Pierre");
person.set("name", "Jonathan");

room.history.undo();

// "Pierre"
root.get("name");
```

<PropertiesListEmpty title="Returns">_Nothing_</PropertiesListEmpty>

<PropertiesListEmpty title="Arguments">_None_</PropertiesListEmpty>

### Room.history.redo

Restores the last undone operation. It does not impact operations made by other
clients, and will only restore changes made by the current client.

```ts
const person = new LiveObject();
person.set("name", "Pierre");
person.set("name", "Jonathan");

room.history.undo();
room.history.redo();

// "Jonathan"
root.get("name");
```

<PropertiesListEmpty title="Returns">_Nothing_</PropertiesListEmpty>

<PropertiesListEmpty title="Arguments">_None_</PropertiesListEmpty>

### Room.history.canUndo

Returns true or false, depending on whether there are any operations to undo.
Helpful for disabling undo buttons.

```ts
const person = new LiveObject();
person.set("name", "Pierre");

// true
room.history.canUndo();

room.history.undo();

// false
room.history.canUndo();
```

<PropertiesList title="Returns">
  <PropertiesListItem name="canUndo" type="boolean">
    Whether there is an undo operation in the current history stack.
  </PropertiesListItem>
</PropertiesList>

<PropertiesListEmpty title="Arguments">_None_</PropertiesListEmpty>

### Room.history.canRedo

Returns true or false, depending on whether there are any operations to redo.
Helpful for disabling redo buttons.

```ts
const person = new LiveObject();
person.set("name", "Pierre");

// false
room.history.canRedo();

room.history.undo();

// true
room.history.canRedo();
```

<PropertiesList title="Returns">
  <PropertiesListItem name="canRedo" type="boolean">
    Whether there is a redo operation in the current history stack.
  </PropertiesListItem>
</PropertiesList>

<PropertiesListEmpty title="Arguments">_None_</PropertiesListEmpty>

### Room.history.clear

Clears the undo and redo stacks for the current client. Explicitly clearing
history resets the ability to undo beyond the current document state. Other
clientsâ€™ histories are unaffected.

```ts
const person = new LiveObject();
person.set("name", "Pierre");

// true
room.history.canUndo();

room.history.clear();

// false
room.history.canUndo();
```

<PropertiesListEmpty title="Returns">_Nothing_</PropertiesListEmpty>

<PropertiesListEmpty title="Arguments">_None_</PropertiesListEmpty>

### Room.history.pause

All future modifications made on the Room will be merged together to create a
single history item until resume is called.

```ts
const info = new LiveObject({ time: "one" });

room.history.pause();
info.set("time", "two");
info.set("time", "three");
room.history.resume();

room.history.undo();

// "one"
room.get("time");
```

<PropertiesListEmpty title="Returns">_Nothing_</PropertiesListEmpty>

<PropertiesListEmpty title="Arguments">_None_</PropertiesListEmpty>

### Room.history.resume

Resumes history after a [pause](#Room.history.pause). Modifications made on the
Room are not merged into a single history item any more.

```ts
const info = new LiveObject({ time: "one" });

room.history.pause();
info.set("time", "two");
info.set("time", "three");
room.history.resume();

room.history.undo();

// "one"
room.get("time");
```

<PropertiesListEmpty title="Returns">_Nothing_</PropertiesListEmpty>

<PropertiesListEmpty title="Arguments">_None_</PropertiesListEmpty>

### Room.connect

Connect the local room instance to the Liveblocks server. Does nothing if the
room is already connecting, reconnecting or connected. We donâ€™t recommend using
this API directly.

```ts
room.connect();
```

<PropertiesListEmpty title="Returns">_Nothing_</PropertiesListEmpty>

<PropertiesListEmpty title="Arguments">_None_</PropertiesListEmpty>

### Room.reconnect

Reconnect the local room instance to the Liveblocks server, using a new
WebSocket connection.

```ts
room.reconnect();
```

<PropertiesListEmpty title="Returns">_Nothing_</PropertiesListEmpty>

<PropertiesListEmpty title="Arguments">_None_</PropertiesListEmpty>

### Room.disconnect

Disconnect the local room instance from the Liveblocks server. The room instance
will remain functional (for example, it will still allow local presence or
storage mutations), but since itâ€™s no longer connected, changes will not be
persisted or synchronized until the room instance is reconnected again. We donâ€™t
recommend using this API directly.

```ts
room.disconnect();
```

<PropertiesListEmpty title="Returns">_Nothing_</PropertiesListEmpty>

<PropertiesListEmpty title="Arguments">_None_</PropertiesListEmpty>

## Comments

### Room.getThreads

Returns threads, and their associated inbox notifications and subscriptions,
that are in the current room. It also returns the request date that can be used
for subsequent polling. Itâ€™s possible to filter for
[a threadâ€™s resolved status](#filtering-resolved-status) and using
[custom metadata](#filtering-metadata).

```ts
const { threads, inboxNotifications, requestedAt } = await room.getThreads();

// [{ id: "th_s436g8...", type: "thread" }, ...]
console.log(threads);

// [{ id: "in_fwh3d4...", kind: "thread", }, ...]
console.log(inboxNotifications);
```

<PropertiesList title="Returns">
  <PropertiesListItem name="threads" type="ThreadData[]">
    Threads within the current room.
  </PropertiesListItem>
  <PropertiesListItem name="inboxNotifications" type="InboxNotificationData[]">
    Inbox notifications associated with the threads.
  </PropertiesListItem>
  <PropertiesListItem name="subscriptions" type="SubscriptionData[]">
    Subscriptions associated with the threads.
  </PropertiesListItem>
  <PropertiesListItem name="requestedAt" type="Date">
    The request date to use for subsequent polling.
  </PropertiesListItem>
</PropertiesList>

<PropertiesList title="Options">
  <PropertiesListItem name="resolved" type="boolean">
    Only return `resolved` or `unresolved` threads. [Learn more](#filtering-resolved-status).
  </PropertiesListItem>
  <PropertiesListItem name="subscribed" type="boolean">
    Only return `subscribed` or `unsubscribed` threads. [Learn more](#filtering-subscribed-status).
  </PropertiesListItem>
  <PropertiesListItem name="metadata" type="Partial<ThreadMetadata>">
    Only return threads containing the custom metadata. Metadata is set yourself when creating a thread, for example `{ priority: "HIGH" }`. [Learn more](#filtering-metadata).
  </PropertiesListItem>
</PropertiesList>

#### Filtering resolved status [#filtering-resolved-status]

You can filter threads by those that are resolved, or unresolved, by passing a
`boolean` to `query.resolved`.

```ts
// Filtering for threads that are unresolved
const threads = await room.getThreads({
  query: {
    // +++
    resolved: false,
    // +++
  },
});
```

#### Filtering subscribed status [#filtering-subscribed-status]

You can filter threads by those that the user is subscribed to, or not, by
passing a `boolean` to `query.subscribed`.

```ts
// Filtering for threads that the user is subscribed to
const threads = await room.getThreads({
  query: {
    // +++
    subscribed: true,
    // +++
  },
});
```

#### Filtering metadata [#filtering-metadata]

You can define custom metadata when
[creating a thread](/docs/api-reference/liveblocks-client#Room.createThread),
and the `query.metadata` option allows you to return only threads that match.

```ts
// Creating a thread with `priority` metadata
await room.createThread({
  body: {
    // ...
  },
  // +++
  metadata: { priority: "HIGH" },
  // +++
});

// Filtering for threads with the same metadata
const threads = await room.getThreads({
  query: {
    // +++
    metadata: { priority: "HIGH" },
    // +++
  },
});
```

You can also filter for metadata that begins with a specific string.

```ts
// Creating a thread with `{ assigned: "sales:stacy" } metadata
await room.createThread({
  body: {
    // ...
  },
  // +++
  metadata: { assigned: "sales:stacy" },
  // +++
});

// Filtering for threads with `assigned` metadata that starts with `sales:`
const threads = await room.getThreads({
  query: {
    // +++
    metadata: {
      assigned: {
        startsWith: "sales:",
      },
    },
    // +++
  },
});
```

You can also filter for metadata using numeric operators.

```ts
// Creating a thread with `{ posX: 87, level: 5 } metadata
await room.createThread({
  body: {
    // ...
  },
  // +++
  metadata: { posX: 87, level: 5 },
  // +++
});

// Filtering for threads with `posX` greater than 50 and lower than 100, and level greater than or equal to 5
const threads = await room.getThreads({
  query: {
    // +++
    metadata: {
      posX: {
        gt: 50,
        lt: 100,
      },
      level: {
        gte: 5,
      },
    },
    // +++
  },
});
```

### Room.getThreadsSince

Returns threads, and their associated inbox notifications and subscriptions,
that have been updated or deleted since the requested date. Helpful when used in
combination with [`Room.getThreads`](#Room.getThreads) to initially fetch all
threads, then receive updates later.

```ts
const initial = await room.getThreads();

const { threads, inboxNotifications, subscriptions, requestedAt } =
  await room.getThreadsSince({ since: initial.requestedAt });

// { updated: [{ id: "th_s4368s...", type: "thread" }, ...], deleted: [...] }
console.log(threads);

// { updated: [{ id: "in_ds83hs...", kind: "thread", }, ...], deleted: [...] }
console.log(inboxNotifications);

// { updated: [{ subjectId: "th_s4368s...", kind: "thread", }, ...], deleted: [...] }
console.log(subscriptions);
```

<PropertiesList title="Returns">
  <PropertiesListItem
    name="threads"
    detailedType="{ updated: ThreadData[], deleted: ThreadDeleteInfo[] }"
  >
    Threads that have been updated or deleted since the requested date.
  </PropertiesListItem>
  <PropertiesListItem
    name="inboxNotifications"
    detailedType="{ updated: InboxNotificationData[], deleted: InboxNotificationDeleteInfo[] }"
  >
    Inbox notifications that have been updated or deleted since the requested
    date.
  </PropertiesListItem>
  <PropertiesListItem
    name="subscriptions"
    detailedType="{ updated: SubscriptionData[], deleted: SubscriptionDeleteInfo[] }"
  >
    Subscriptions that have been updated or deleted since the requested date.
  </PropertiesListItem>
  <PropertiesListItem name="requestedAt" type="Date">
    The request date to use for subsequent polling.
  </PropertiesListItem>
</PropertiesList>

<PropertiesList title="Options">
  <PropertiesListItem name="since" type="Date" required>
    Only return threads that have been updated or deleted after this date.
  </PropertiesListItem>
</PropertiesList>

### Room.getThread

Returns a thread and its associated inbox notification and subscription, from
its ID, if it exists.

```ts
const { thread, inboxNotification, subscription } =
  await room.getThread("th_xxx");
```

The thread ID can be retrieved from existing threads.

```ts
const newThread = await room.createThread(/* ... */);

const { thread, inboxNotification } = await room.getThread(newThread.id);
```

<PropertiesList title="Returns">
  <PropertiesListItem name="thread" type="ThreadData | undefined">
    The requested thread, or `undefined` if it doesnâ€™t exist.
  </PropertiesListItem>
  <PropertiesListItem
    name="inboxNotification"
    type="InboxNotificationThreadData | undefined"
  >
    The inbox notification associated with the thread, or `undefined` if it
    doesnâ€™t exist.
  </PropertiesListItem>
  <PropertiesListItem name="subscription" type="SubscriptionData | undefined">
    The subscription associated with the thread, or `undefined` if it doesnâ€™t
    exist.
  </PropertiesListItem>
</PropertiesList>

<PropertiesList title="Arguments">
  <PropertiesListItem name="value" type="string" required>
    The ID of the thread you want to retrieve.
  </PropertiesListItem>
</PropertiesList>

### Room.createThread

Creates a thread, and its initial comment, in the current room. A commentâ€™s body
is an array of paragraphs, each containing child nodes, learn more under
[creating thread content](#creating-thread-content).

```ts
const thread = await room.createThread({
  body: {
    version: 1,
    content: [{ type: "paragraph", children: [{ text: "Hello" }] }],
  },
});
```

<PropertiesList title="Returns">
  <PropertiesListItem name="value" type="ThreadData">
    The thread that has been created.
  </PropertiesListItem>
</PropertiesList>

<PropertiesList title="Options">
  <PropertiesListItem name="body" type="CommentBody" required>
    The content of the comment, see [creating thread
    content](#creating-thread-content).
  </PropertiesListItem>
  <PropertiesListItem name="attachmentIds" type="string[]">
    The IDs of the commentâ€™s attachments.
  </PropertiesListItem>
  <PropertiesListItem name="commentMetadata" type="CommentMetadata">
    Custom metadata to be attached to the initial comment, see [defining comment
    metadata](#defining-comment-metadata).
  </PropertiesListItem>
  <PropertiesListItem name="metadata" type="ThreadMetadata">
    Custom metadata to be attached to the thread, see [defining thread
    metadata](#defining-thread-metadata).
  </PropertiesListItem>
</PropertiesList>

#### Creating thread content [#creating-thread-content]

A commentâ€™s body is an array of paragraphs, each containing child nodes. Hereâ€™s
an example of how to construct the following simple comment body, which can be
passed to `room.createThread`.

> Hello **world**
>
> <div className="h-2"></div>
> _Second_ paragraph!

```tsx
import { CommentBody } from "@liveblocks/client";

const body: CommentBody = {
  version: 1,
  content: [
    // +++
    {
      type: "paragraph",
      children: [{ text: "Hello " }, { text: "world", bold: true }],
    },
    {
      type: "paragraph",
      children: [{ text: "Second", italic: true }, { text: " paragraph!" }],
    },
    // +++
  ],
};

const thread = await room.createThread({ body });
```

Itâ€™s also possible to create links and mentions.

> <span title="jody.hekla">**@Jody Hekla**</span> the
> **[Liveblocks](https://liveblocks.io)** website is cool!

```ts
const body: CommentBody = {
  version: 1,
  content: [
    // +++
    {
      type: "paragraph",
      children: [
        { type: "mention", id: "jody.hekla" },
        { text: " the " },
        { text: "Liveblocks", type: "link", url: "https://liveblocks.io" },
        { text: " website is cool!" },
      ],
    },
    // +++
  ],
};
```

#### Defining thread metadata [#defining-thread-metadata]

Custom metadata can be attached to each thread. `string`, `number`, and
`boolean` properties are allowed.

```ts
const metadata: Liveblocks["ThreadMetadata"] = {
  color: "blue",
  page: 3,
  pinned: true,
};

const thread = await room.createThread({ body, metadata });
```

### Room.deleteThread

Deletes a thread by its ID.

```ts
await room.deleteThread("th_xxx");
```

<PropertiesListEmpty title="Returns">_Nothing_</PropertiesListEmpty>

<PropertiesList title="Arguments">
  <PropertiesListItem name="threadId" type="string" required>
    The ID of the thread to delete.
  </PropertiesListItem>
</PropertiesList>

### Room.editThreadMetadata

Edits a threadâ€™s custom metadata. Metadata can be a `string`, `number`, or
`boolean`. To delete an existing metadata property, set its value to `null`.

```ts
await room.editThreadMetadata({
  threadId: "th_xxx",
  metadata: {
    color: "blue",
    page: 3,
    pinned: true,
  },
});
```

<PropertiesList title="Returns">
  <PropertiesListItem name="metadata" type="ThreadMetadata">
    The thread metadata.
  </PropertiesListItem>
</PropertiesList>

<PropertiesList title="Options">
  <PropertiesListItem name="threadId" type="string" required>
    The ID of the thread.
  </PropertiesListItem>
  <PropertiesListItem name="metadata" type="Patchable<ThreadMetadata>" required>
    An object containing the metadata properties to update. Metadata can be a
    `string`, `number`, or `boolean`. To delete an existing metadata property,
    set its value to `null`.
  </PropertiesListItem>
</PropertiesList>

### Room.markThreadAsResolved

Marks a thread as resolved.

```ts
await room.markThreadAsResolved("th_xxx");
```

<PropertiesListEmpty title="Returns">_Nothing_</PropertiesListEmpty>

<PropertiesList title="Arguments">
  <PropertiesListItem name="threadId" type="string" required>
    The ID of the thread to resolve.
  </PropertiesListItem>
</PropertiesList>

### Room.markThreadAsUnresolved

Marks a thread as unresolved.

```ts
await room.markThreadAsUnresolved("th_xxx");
```

<PropertiesListEmpty title="Returns">_Nothing_</PropertiesListEmpty>

<PropertiesList title="Arguments">
  <PropertiesListItem name="threadId" type="string" required>
    The ID of the thread to resolve.
  </PropertiesListItem>
</PropertiesList>

### Room.subscribeToThread

Subscribes the user to a thread, meaning they will receive inbox notifications
when new comments are posted.

```ts
await room.subscribeToThread("th_xxx");
```

<PropertiesList title="Returns">
  <PropertiesListItem name="value" type="SubscriptionData">
    The threadâ€™s subscription.
  </PropertiesListItem>
</PropertiesList>

<PropertiesList title="Arguments">
  <PropertiesListItem name="threadId" type="string" required>
    The ID of the thread to subscribe to.
  </PropertiesListItem>
</PropertiesList>

#### Replacing room-level subscriptions

Subscribing will replace any existing subscription for the current thread
[set at room-level](#Room.updateSubscriptionSettings). This value can also be
overridden by a room-level call that is run afterwards.

```ts
// 1. Disables notifications for all threads
await room.updateSubscriptionSettings({
  threads: "none",
});

// 2. Enables notifications just for this thread, "th_d75sF3..."
await room.subscribeToThread("th_d75sF3...");

// 3. Disables notifications for all threads, including "th_d75sF3..."
await room.updateSubscriptionSettings({
  threads: "none",
});
```

### Room.unsubscribeFromThread

Unsubscribes the user from a thread, meaning they will no longer receive inbox
notifications when new comments are posted.

```ts
await room.unsubscribeFromThread("th_xxx");
```

<PropertiesListEmpty title="Returns">_Nothing_</PropertiesListEmpty>

<PropertiesList title="Arguments">
  <PropertiesListItem name="threadId" type="string" required>
    The ID of the thread to unsubscribe from.
  </PropertiesListItem>
</PropertiesList>

#### Replacing room-level unsubscriptions

Unsubscribing will replace any existing unsubscription for the current thread
[set at room-level](#Room.updateSubscriptionSettings). This value can also be
overridden by a room-level call that is run afterwards.

```ts
// 1. Enable notifications for all threads
await room.updateSubscriptionSettings({
  threads: "all",
});

// 2. Disables notifications just for this thread, "th_d75sF3..."
await room.unsubscribeFromThread("th_d75sF3...");

// 3. Enables notifications for all threads, including "th_d75sF3..."
await room.updateSubscriptionSettings({
  threads: "all",
});
```

### Room.createComment

Creates a comment in a given thread.

```ts
const comment = await room.createComment({
  threadId: "th_xxx",
  body: {
    version: 1,
    content: [{ type: "paragraph", children: [{ text: "Hello" }] }],
  },
});
```

<PropertiesList title="Returns">
  <PropertiesListItem name="value" type="CommentData">
    The comment that has been created.
  </PropertiesListItem>
</PropertiesList>

<PropertiesList title="Options">
  <PropertiesListItem name="threadId" type="string" required>
    The ID of the thread that the comment will be added to.
  </PropertiesListItem>
  <PropertiesListItem name="body" type="CommentBody" required>
    The content of the comment, see [creating comment
    content](#creating-comment-content).
  </PropertiesListItem>
  <PropertiesListItem name="attachmentIds" type="string[]">
    The IDs of the commentâ€™s attachments.
  </PropertiesListItem>
  <PropertiesListItem name="metadata" type="CommentMetadata">
    Custom metadata to be attached to the comment, see [defining comment
    metadata](#defining-comment-metadata).
  </PropertiesListItem>
</PropertiesList>

#### Creating comment content [#creating-comment-content]

A commentâ€™s body is an array of paragraphs, each containing child nodes. Hereâ€™s
an example of how to construct the following simple comment body, which can be
passed to `room.createComment`.

> Hello **world**
>
> <div className="h-2"></div>
> _Second_ paragraph!

```tsx
import { CommentBody } from "@liveblocks/client";

const thread = await room.createThread(/* ... */);

const body: CommentBody = {
  version: 1,
  content: [
    // +++
    {
      type: "paragraph",
      children: [{ text: "Hello " }, { text: "world", bold: true }],
    },
    {
      type: "paragraph",
      children: [{ text: "Second", italic: true }, { text: " paragraph!" }],
    },
    // +++
  ],
};

const comment = await room.createComment({ threadId: thread.id, body });
```

Itâ€™s also possible to create links and mentions.

> <span title="jody.hekla">**@Jody Hekla**</span> the
> **[Liveblocks](https://liveblocks.io)** website is cool!

```ts
const body: CommentBody = {
  version: 1,
  content: [
    // +++
    {
      type: "paragraph",
      children: [
        { type: "mention", id: "jody.hekla" },
        { text: " the " },
        { text: "Liveblocks", type: "link", url: "https://liveblocks.io" },
        { text: " website is cool!" },
      ],
    },
    // +++
  ],
};
```

#### Defining comment metadata [#defining-comment-metadata]

Custom metadata can be attached to each comment. `string`, `number`, and
`boolean` properties are allowed.

```ts
const metadata: Liveblocks["CommentMetadata"] = {
  priority: 2,
  reviewed: true,
};

const comment = await room.createComment({
  threadId: "th_xxx",
  body,
  metadata,
});
```

### Room.editComment

Edits a comment, replacing its existing comment body and optionally updating its
attachments and metadata. Learn more about
[creating comment content](#creating-comment-content).

```ts
const comment = await room.editComment({
  threadId: "th_xxx",
  commentId: "cm_xxx",
  body: {
    version: 1,
    content: [{ type: "paragraph", children: [{ text: "Hello" }] }],
  },
});
```

<PropertiesList title="Returns">
  <PropertiesListItem name="value" type="CommentData">
    The comment that has been edited.
  </PropertiesListItem>
</PropertiesList>

<PropertiesList title="Options">
  <PropertiesListItem name="threadId" type="string" required>
    The ID of the thread containing the comment.
  </PropertiesListItem>
  <PropertiesListItem name="commentId" type="string" required>
    The ID of the comment thatâ€™s being edited.
  </PropertiesListItem>
  <PropertiesListItem name="body" type="CommentBody" required>
    The content of the comment, see [creating comment
    content](#creating-comment-content).
  </PropertiesListItem>
  <PropertiesListItem name="attachmentIds" type="string[]">
    The IDs of the commentâ€™s attachments.
  </PropertiesListItem>
  <PropertiesListItem name="metadata" type="CommentMetadata">
    Custom metadata to be attached to the comment.
  </PropertiesListItem>
</PropertiesList>

### Room.editCommentMetadata

Edits a commentâ€™s custom metadata. Metadata can be a `string`, `number`, or
`boolean`. To delete an existing metadata property, set its value to `null`.

```ts
await room.editCommentMetadata({
  threadId: "th_xxx",
  commentId: "cm_xxx",
  metadata: {
    tag: "important",
    priority: 2,
    flagged: true,
  },
});
```

<PropertiesList title="Returns">
  <PropertiesListItem name="metadata" type="CommentMetadata">
    The comment metadata.
  </PropertiesListItem>
</PropertiesList>

<PropertiesList title="Options">
  <PropertiesListItem name="threadId" type="string" required>
    The ID of the thread containing the comment.
  </PropertiesListItem>
  <PropertiesListItem name="commentId" type="string" required>
    The ID of the comment.
  </PropertiesListItem>
  <PropertiesListItem
    name="metadata"
    type="Patchable<CommentMetadata>"
    required
  >
    An object containing the metadata properties to update. Metadata can be a
    `string`, `number`, or `boolean`. To delete an existing metadata property,
    set its value to `null`.
  </PropertiesListItem>
</PropertiesList>

### Room.deleteComment

Deletes a comment. If it is the last non-deleted comment, the thread also gets
deleted.

```ts
await room.deleteComment({
  threadId: "th_xxx",
  commentId: "cm_xxx",
});
```

<PropertiesListEmpty title="Returns">_Nothing_</PropertiesListEmpty>

<PropertiesList title="Options">
  <PropertiesListItem name="threadId" type="string" required>
    The ID of the thread containing the comment.
  </PropertiesListItem>
  <PropertiesListItem name="commentId" type="string" required>
    The ID of the comment thatâ€™s being edited.
  </PropertiesListItem>
</PropertiesList>

### Room.addReaction

Adds a reaction from the current user on a comment.

```ts
const reaction = await room.addReaction({
  threadId: "th_xxx",
  commentId: "cm_xxx",
  emoji: "ðŸ‘",
});
```

<PropertiesList title="Returns">
  <PropertiesListItem name="value" type="CommentUserReaction">
    The reaction that has been created.
  </PropertiesListItem>
</PropertiesList>

<PropertiesList title="Options">
  <PropertiesListItem name="threadId" type="string" required>
    The ID of the thread containing the comment.
  </PropertiesListItem>
  <PropertiesListItem name="commentId" type="string" required>
    The ID of the comment to add a reaction to.
  </PropertiesListItem>
  <PropertiesListItem name="emoji" type="string" required>
    The emoji reaction to add.
  </PropertiesListItem>
</PropertiesList>

### Room.removeReaction

Removes a reaction from a comment.

```ts
await room.removeReaction({
  threadId: "th_xxx",
  commentId: "cm_xxx",
  emoji: "ðŸ‘",
});
```

<PropertiesListEmpty title="Returns">_Nothing_</PropertiesListEmpty>

<PropertiesList title="Options">
  <PropertiesListItem name="threadId" type="string" required>
    The ID of the thread containing the comment.
  </PropertiesListItem>
  <PropertiesListItem name="commentId" type="string" required>
    The ID of the comment to remove a reaction from.
  </PropertiesListItem>
  <PropertiesListItem name="emoji" type="string" required>
    The emoji reaction to remove.
  </PropertiesListItem>
</PropertiesList>

### Room.prepareAttachment

Creates a local attachment from a file.

```ts
const attachment = room.prepareAttachment({
  file: new File(["Hello, world!"], "hello.txt"),
});

// { "id": "at_1e6nNX...", "name": "hello.txt", "type": "attachment", ... }
console.log(attachment);
```

<PropertiesList title="Returns">
  <PropertiesListItem name="value" type="CommentLocalAttachment">
    The local attachment that has been created.
  </PropertiesListItem>
</PropertiesList>

<PropertiesList title="Arguments">
  <PropertiesListItem name="file" type="File" required>
    The file to create the attachment from.
  </PropertiesListItem>
</PropertiesList>

### Room.uploadAttachment

Uploads a local attachment.

```ts
const attachment = room.prepareAttachment(file);
await room.uploadAttachment(attachment);
```

Optionally, an
[`AbortSignal`](https://developer.mozilla.org/en-US/docs/Web/API/AbortSignal)
can be passed to cancel the upload.

```ts
const attachment = room.prepareAttachment(file);

// Cancel the upload after 5 seconds
room.uploadAttachment(attachment, { signal: AbortSignal.timeout(5000) });
```

<PropertiesList title="Returns">
  <PropertiesListItem name="value" type="CommentAttachment">
    The attachment that has been uploaded.
  </PropertiesListItem>
</PropertiesList>

<PropertiesList title="Arguments">
  <PropertiesListItem name="attachment" type="CommentLocalAttachment" required>
    The file to create the attachment from.
  </PropertiesListItem>
  <PropertiesListItem name="options" type="UploadAttachmentOptions">
    A set of options.
  </PropertiesListItem>
</PropertiesList>

<PropertiesList title="Options">
  <PropertiesListItem name="signal" type="AbortSignal">
    Only the inbox notifications updated or deleted after this date will be
    returned.
  </PropertiesListItem>
</PropertiesList>

### Room.getAttachmentUrl

Returns a presigned URL for an attachment by its ID.

```ts
const url = await room.getAttachmentUrl("at_xxx");

// "https://..."
console.log(url);
```

<PropertiesList title="Returns">
  <PropertiesListItem name="value" type="string">
    A presigned URL for the attachment.
  </PropertiesListItem>
</PropertiesList>

<PropertiesList title="Arguments">
  <PropertiesListItem name="attachmentId" type="string" required>
    The ID of the attachment to get the URL for.
  </PropertiesListItem>
</PropertiesList>

## Notifications

### Client.getInboxNotifications

Returns the current userâ€™s inbox notifications and their associated threads and
subscriptions. It also returns the request date that can be used for subsequent
polling.

```ts
const { inboxNotifications, threads, subscriptions, requestedAt } =
  await client.getInboxNotifications();

// [{ id: "in_fwh3d4...", kind: "thread", }, ...]
console.log(inboxNotifications);

// [{ id: "th_s436g8...", type: "thread" }, ...]
console.log(threads);

// [{ subjectId: "th_s436g8...", kind: "thread", }, ...]
console.log(subscriptions);
```

<PropertiesList title="Returns">
  <PropertiesListItem name="inboxNotifications" type="InboxNotificationData[]">
    Current userâ€™s inbox notifications.
  </PropertiesListItem>
  <PropertiesListItem name="threads" type="ThreadData[]">
    Threads associated with the inbox notifications.
  </PropertiesListItem>
  <PropertiesListItem name="subscriptions" type="SubscriptionData[]">
    Subscriptions associated with the inbox notifications.
  </PropertiesListItem>
  <PropertiesListItem name="requestedAt" type="Date">
    The request date to use for subsequent polling.
  </PropertiesListItem>
</PropertiesList>

<PropertiesList title="Options">
  <PropertiesListItem name="roomId" type="string">
    Only return inbox notifications for the given room. [Learn
    more](#filtering-inbox-notifications).
  </PropertiesListItem>
  <PropertiesListItem name="kind" type="string">
    Only return inbox notifications for the kind. [Learn
    more](#filtering-inbox-notifications).
  </PropertiesListItem>
</PropertiesList>

#### Filtering inbox notifications [#filtering-inbox-notifications]

You can filter inbox notifications by those that are associated with a specific
room or kind, by passing a `string` to `query.roomId` or `query.kind`.

```ts
// Filtering for inbox notifications that are associated with a specific room or kind
const { inboxNotifications } = await client.getInboxNotifications({
  query: {
    // +++
    roomId: "room1",
    kind: "thread",
    // +++
  },
});
```

### Client.getInboxNotificationsSince

Returns the updated and deleted inbox notifications and their associated threads
and subscriptions since the requested date. Helpful when used in combination
with [`Client.getInboxNotifications`](#Client.getInboxNotifications) to
initially fetch all notifications, then receive updates later.

```ts
const initial = await client.getInboxNotifications();

const { inboxNotifications, threads, subscriptions, requestedAt } =
  await client.getInboxNotificationsSince({ since: initial.requestedAt });

// { updated: [{ id: "in_ds83hs...", kind: "thread", }, ...], deleted: [...] }
console.log(inboxNotifications);

// { updated: [{ id: "th_s4368s...", type: "thread" }, ...], deleted: [...] }
console.log(threads);

// { updated: [{ subjectId: "th_s4368s...", kind: "thread", }, ...], deleted: [...] }
console.log(subscriptions);
```

<PropertiesList title="Returns">
  <PropertiesListItem
    name="inboxNotifications"
    detailedType="{ updated: InboxNotificationData[], deleted: InboxNotificationDeleteInfo[] }"
  >
    Inbox notifications that have been updated or deleted since the requested
    date.
  </PropertiesListItem>
  <PropertiesListItem
    name="threads"
    detailedType="{ updated: ThreadData[], deleted: ThreadDeleteInfo[] }"
  >
    Threads that have been updated or deleted since the requested date.
  </PropertiesListItem>
  <PropertiesListItem name="requestedAt" type="Date">
    The request date to use for subsequent polling.
  </PropertiesListItem>
</PropertiesList>

<PropertiesList title="Options">
  <PropertiesListItem name="since" type="Date" required>
    Only the inbox notifications updated or deleted after this date will be
    returned.
  </PropertiesListItem>
</PropertiesList>

### Client.getUnreadInboxNotificationsCount

Gets the number of unread inbox notifications for the current user.

```ts
const count = await client.getUnreadInboxNotificationsCount();
```

<PropertiesList title="Returns">
  <PropertiesListItem name="value" type="number">
    Number of unread inbox notifications.
  </PropertiesListItem>
</PropertiesList>

<PropertiesListEmpty title="Arguments">_None_</PropertiesListEmpty>

### Client.markAllInboxNotificationsAsRead

Marks all inbox notifications as read, for the current user.

```ts
await client.markAllInboxNotificationsAsRead();
```

<PropertiesListEmpty title="Returns">_Nothing_</PropertiesListEmpty>

<PropertiesListEmpty title="Arguments">_None_</PropertiesListEmpty>

### Client.markInboxNotificationAsRead

Marks an inbox notification as read, for the current user.

```ts
await client.markInboxNotificationAsRead("in_xxx");
```

<PropertiesListEmpty title="Returns">_Nothing_</PropertiesListEmpty>

<PropertiesList title="Arguments">
  <PropertiesListItem name="inboxNotificationId" type="string" required>
    The ID of the inbox notification to be marked as read.
  </PropertiesListItem>
</PropertiesList>

### Client.deleteAllInboxNotifications

Deletes an inbox notification for the current user.

```ts
await client.deleteAllInboxNotifications();
```

<PropertiesListEmpty title="Returns">_Nothing_</PropertiesListEmpty>

<PropertiesListEmpty title="Arguments">_None_</PropertiesListEmpty>

### Client.deleteInboxNotification

Deletes an inbox notification for the current user.

```ts
await client.deleteInboxNotification("in_xxx");
```

<PropertiesListEmpty title="Returns">_Nothing_</PropertiesListEmpty>

<PropertiesList title="Arguments">
  <PropertiesListItem name="inboxNotificationId" type="string" required>
    The ID of the inbox notification to be deleted.
  </PropertiesListItem>
</PropertiesList>

### Room.getSubscriptionSettings

Gets the userâ€™s subscription settings for the current room. This notates which
[`inboxNotifications`](/docs/api-reference/liveblocks-client#Client.getInboxNotifications)
the current user receives in the current room.

```ts
const settings = await room.getSubscriptionSettings();
```

<PropertiesList title="Returns">
  <PropertiesListItem
    name="settings"
    type="{ threads, textMentions }"
  >
    Subscription settings for Liveblocks products.
  </PropertiesListItem>
  <PropertiesListItem
    name="settings.threads"
    type={`"all" | "replies_and_mentions" | "none"`}
  >
    <div className="-mb-3">
      Returns the current roomâ€™s subscription settings for threads. It can return one of three values:
    </div>

    - `"all"` Receive notifications for every activity in every thread.
    - `"replies_and_mentions"` Receive notifications for mentions and threads youâ€™re participating in.
    - `"none"` No notifications are received.

  </PropertiesListItem>
    <PropertiesListItem
    name="settings.textMentions"
    type={`"mine" | "none"`}
  >
    <div className="-mb-3">
      Returns the current roomâ€™s subscription settings for text mentions. It can be one of two values:
    </div>

    - `"mine"` Receive notifications for mentions of you.
    - `"none"` No notifications are received.

  </PropertiesListItem>
</PropertiesList>

<PropertiesListEmpty title="Arguments">_None_</PropertiesListEmpty>

### Room.updateSubscriptionSettings

Updates the userâ€™s subscription settings for the current room. Updating this
setting will change which
[`inboxNotifications`](/docs/api-reference/liveblocks-client#Client.getInboxNotifications)
the current user receives in the current room.

```ts
const settings = await room.updateSubscriptionSettings({
  threads: "replies_and_mentions",
});
```

<PropertiesList title="Returns">
  <PropertiesListItem
    name="settings"
    type="{ threads, textMentions }"
  >
    Subscription settings for Liveblocks products.
  </PropertiesListItem>
  <PropertiesListItem
    name="settings.threads"
    type={`"all" | "replies_and_mentions" | "none"`}
  >
    <div className="-mb-3">
      Returns the current roomâ€™s subscription settings for threads. It can return one of three values:
    </div>

    - `"all"` Receive notifications for every activity in every thread.
    - `"replies_and_mentions"` Receive notifications for mentions and threads youâ€™re participating in.
    - `"none"` No notifications are received.

  </PropertiesListItem>
    <PropertiesListItem
    name="settings.textMentions"
    type={`"mine" | "none"`}
  >
    <div className="-mb-3">
      Returns the current roomâ€™s subscription settings for text mentions. It can be one of two values:
    </div>

    - `"mine"` Receive notifications for mentions of you.
    - `"none"` No notifications are received.

  </PropertiesListItem>
</PropertiesList>

<PropertiesList title="Options">
    <PropertiesListItem
    name="threads"
    type={`"all" | "replies_and_mentions" | "none"`}
  >
    <div className="-mb-3">
      Sets the current roomâ€™s subscription settings for threads. It can be one of three values:
    </div>

    - `"all"` Receive notifications for every activity in every thread.
    - `"replies_and_mentions"` Receive notifications for mentions and threads youâ€™re participating in.
    - `"none"` No notifications are received.

  </PropertiesListItem>
  <PropertiesListItem
    name="textMentions"
    type={`"mine" | "none"`}
  >
    <div className="-mb-3">
      Sets the current roomâ€™s subscription settings for text mentions. It can be one of two values:
    </div>

    - `"mine"` Receive notifications for mentions of you.
    - `"none"` No notifications are received.

  </PropertiesListItem>
</PropertiesList>

#### Replacing individual thread subscriptions

Subscribing will replace any
[existing thread subscriptions](#Room.subscribeToThread) in the current room.
This value can also be overridden by a room-level call that is run afterwards.

```ts
// 1. Enables notifications just for this thread, "th_d75sF3..."
await room.subscribeToThread("th_d75sF3...");

// 2. Disables notifications for all threads, including "th_d75sF3..."
await room.updateSubscriptionSettings({
  threads: "none",
});
```

### Client.getNotificationSettings [@badge=Beta]

Returns the userâ€™s notification settings in the current project, in other words
which [notification webhook events](/docs/platform/webhooks#NotificationEvent)
will be sent for the current user. Notification settings are project-based,
which means that this returns the current userâ€™s settings for every room.

```ts
const settings = await client.getNotificationSettings();

// { email: { thread: true, ... }, slack: { thread: false, ... }, ... }
console.log(settings);
```

A userâ€™s initial settings are set in the dashboard, and different kinds should
be enabled there. If no kind is enabled on the current channel, `null` will be
returned. For example, with the email channel:

```ts
const settings = await client.getNotificationSettings();

// { email: null, ... }
console.log(settings);
```

<PropertiesList title="Returns">
  <PropertiesListItem name="settings" type="NotificationSettings">
    Current userâ€™s notification settings.
  </PropertiesListItem>
</PropertiesList>

<PropertiesListEmpty title="Arguments">_None_</PropertiesListEmpty>

### Client.updateNotificationSettings [@badge=Beta]

Updates the current userâ€™s notification settings, which affects which
[notification webhook events](/docs/platform/webhooks#NotificationEvent) will be
sent for the current user. Notification settings are project-based, which means
that this modifies the current userâ€™s settings in every room. Each notification
`kind` must first be enabled on your projectâ€™s notification dashboard page
before settings can be used.

```ts
const settings = await client.updateNotificationSettings({
  email: { thread: false },
  slack: { textMention: true },
});

// { email: { thread: false, ... }, slack: { textMention: true, ... }, ... }
console.log(settings);
```

<PropertiesList title="Returns">
  <PropertiesListItem name="settings" type="NotificationSettings">
    Current userâ€™s notification settings.
  </PropertiesListItem>
</PropertiesList>

<PropertiesList title="Arguments">
  <PropertiesListItem name="settings" type="object" required>
    A deep partial object containing the notification settings to
    update. Custom notifications can be set too.

    <div className="-mt-2">
    ```js title="Examples" isCollapsable isCollapsed
    // You only need to pass partials
    await client.updateNotificationSettings({
      email: { thread: true },
    });

    // Enabling a custom notification on the slack channel
    await client.updateNotificationSettings({
      slack: { $myCustomNotification: true },
    });

    // Setting complex settings
    await client.updateNotificationSettings({
      email: {
        thread: true,
        textMention: false,
        $newDocument: true,
      },
        slack: {
        thread: false,
        $fileUpload: false,
      },
        teams: {
        thread: true,
      },
    });
    ```
    </div>

  </PropertiesListItem>
  <PropertiesListItem name="settings.email" type="NotificationChannelSettings">
    The email notification settings.
  </PropertiesListItem>
  <PropertiesListItem name="settings.slack" type="NotificationChannelSettings">
    The Slack notification settings.
  </PropertiesListItem>
  <PropertiesListItem name="settings.teams" type="NotificationChannelSettings">
    The Microsoft Teams notification settings.
  </PropertiesListItem>
  <PropertiesListItem name="settings.webPush" type="NotificationChannelSettings">
    The Web Push notification settings.
  </PropertiesListItem>
</PropertiesList>

## Storage

Each room contains Storage, a conflict-free data store that multiple users can
edit at the same time. When users make edits simultaneously, conflicts are
resolved automatically, and each user will see the same state. Storage is ideal
for storing permanent document state, such as shapes on a canvas, notes on a
whiteboard, or cells in a spreadsheet.

### Data structures

Storage provides three different conflict-free data structures, which you can
use to build your application. All structures are permanent and persist when all
users have left the room, unlike [Presence](/docs/ready-made-features/presence)
which is temporary.

- [`LiveObject`][] - Similar to JavaScript object. Use this for storing records
  with fixed key names and where the values donâ€™t necessarily have the same
  types. For example, a `Person` with a `name: string` and an `age: number`
  field. If multiple clients update the same property simultaneously, the last
  modification received by the Liveblocks servers is the winner.

- [`LiveList`][] - An ordered collection of items synchronized across clients.
  Even if multiple users add/remove/move elements simultaneously, LiveList will
  solve the conflicts to ensure everyone sees the same collection of items.

- [`LiveMap`][] - Similar to a JavaScript Map. Use this for indexing values that
  all have the same structure. For example, to store an index of `Person` values
  by their name. If multiple users update the same property simultaneously, the
  last modification received by the Liveblocks servers is the winner.

### Typing Storage [#typing-storage]

To type the Storage values you receive, make sure to set your `Storage` type.

```ts file="liveblocks.config.ts"
import { LiveList } from "@liveblocks/client";

declare global {
  interface Liveblocks {
    Storage: {
      animals: LiveList<{ name: string }>;
    };
  }
}
```

The type received in the callback will match the type passed. Learn more under
[typing your data](#typing-your-data).

```ts
const { root } = await room.getStorage();
const animals = root.get("animals");

const unsubscribe = room.subscribe(animals, (updatedAnimals) => {
  // LiveList<[{ name: "Fido" }, { name: "Felix" }]>
  console.log(updatedAnimals);
});
```

### Nesting data structures

All Storage data structures can be nested, allowing you to create complex trees
of conflict-free data.

```ts file="liveblocks.config.ts"
import { LiveObject, LiveList, LiveMap } from "@liveblocks/client";

type Person = LiveObject<{
  name: string;
  pets: LiveList<string>;
}>;

declare global {
  interface Liveblocks {
    Storage: {
      people: LiveMap<string, Person>;
    };
  }
}
```

```ts
import { LiveObject, LiveList, LiveMap } from "@liveblocks/client";

const pets = new LiveList(["Cat", "Dog"]);
const person = new LiveObject({ name: "Alicia", pets });
const people = new LiveMap();
people.set("alicia", person);

const { root } = await room.getStorage();
root.set(people);
```

<Banner title="Need help troubleshooting Storage?">

Get the [Liveblocks DevTools extension](/devtools) to develop and debug your
application as you build it.

</Banner>

### Room.getStorage

Get the roomâ€™s Storage asynchronously (returns a Promise). The promise will
resolve once the Storageâ€™s root is loaded and available. The Storageâ€™s root is
always a [`LiveObject`][].

```ts
const { root } = await room.getStorage();
```

<PropertiesList title="Returns">
  <PropertiesListItem name="storage" type="{ root: LiveObject<TStorage> }">
    The roomâ€™s Storage structures. `root` is a `LiveObject`, and is the root of
    your Storage. Learn more about [typing Storage](#typing-storage).
  </PropertiesListItem>
</PropertiesList>

<PropertiesListEmpty title="Arguments">_None_</PropertiesListEmpty>

## LiveObject

The `LiveObject` class is similar to a JavaScript object that is synchronized on
all clients. Use this for storing records with fixed key names and where the
values donâ€™t necessarily have the same types. For example, a `Person` with
`name` and `age` fields. To add typing, read more under
[typing Storage](#typing-storage).

```ts
type Person = LiveObject<{
  name: string;
  age: number;
}>;
```

Keys are strings, and values can contain other Storage structures, or
JSON-serializable data. If multiple clients update the same property
simultaneously, the last modification received by the Liveblocks servers is the
winner.

### new LiveObject [#LiveObject.constructor]

Create an empty `LiveObject`

```ts
import { LiveObject } from "@liveblocks/client";

const object = new LiveObject();
```

Create a `LiveObject` with initial data.

```ts
import { LiveObject } from "@liveblocks/client";

const object = new LiveObject({ firstName: "Margaret", lastName: "Hamilton" });
```

<PropertiesList title="Returns">
  <PropertiesListItem name="LiveObject" type="LiveObject<L>">
    The newly created `LiveObject`.
  </PropertiesListItem>
</PropertiesList>

<PropertiesList title="Arguments">
  <PropertiesListItem name="initialValue" type="L extends LsonObject" required>
    The initial value for the `LiveObject`. Can contain JSON-serializable data
    and other Liveblocks conflict-free data structures.
  </PropertiesListItem>
</PropertiesList>

#### Add a LiveObject to Storage

The Storage root is `LiveObject` itself, so you can use [`LiveObject.set`]() to
add a new property to your root. If youâ€™ve [typed Storage](#typing-storage)
youâ€™ll have type hints as you build.

```ts
import { LiveObject } from "@liveblocks/client";

const { root } = await room.getStorage();

const person = new LiveObject({ name: "Alicia" });
root.set("person", person);
```

### delete [#LiveObject.delete]

Delete a property from the `LiveObject`

```ts
const object = new LiveObject({ firstName: "Ada", lastName: "Lovelace" });
object.delete("lastName");

// { firstName: "Ada" }
object.toImmutable();
```

<PropertiesListEmpty title="Returns">_Nothing_</PropertiesListEmpty>

<PropertiesList title="Arguments">
  <PropertiesListItem name="key" type="string" required>
    The key of the property youâ€™re deleting. If the property doesnâ€™t exist,
    nothing will occur.
  </PropertiesListItem>
</PropertiesList>

### get [#LiveObject.get]

Get a property from the `LiveObject`.

```ts
const object = new LiveObject({ firstName: "Ada", lastName: "Lovelace" });

// "Ada"
object.get("firstName");
```

<PropertiesList title="Returns">
  <PropertiesListItem name="value">
    The value of the property. Returns `undefined` if it doesnâ€™t exist.
  </PropertiesListItem>
</PropertiesList>

<PropertiesList title="Arguments">
  <PropertiesListItem name="key" type="string" required>
    The key of the property youâ€™re getting.
  </PropertiesListItem>
</PropertiesList>

### set [#LiveObject.set]

Adds or updates a property with the specified key and a value.

```ts
const object = new LiveObject({ firstName: "Marie" });
object.set("lastName", "Curie");

// { firstName: "Ada", lastName: "Curie" }
object.toImmutable();
```

<PropertiesListEmpty title="Returns">_Nothing_</PropertiesListEmpty>

<PropertiesList title="Arguments">
  <PropertiesListItem name="key" type="string" required>
    The key of the property youâ€™re setting.
  </PropertiesListItem>
  <PropertiesListItem name="value" type="LsonObject" required>
    The value of the property youâ€™re setting. Can contain JSON-serializable data
    and other Liveblocks conflict-free data structures.
  </PropertiesListItem>
</PropertiesList>

### update [#LiveObject.update]

Adds or updates multiple properties at once. Nested changes to other Storage
types will not be applied.

```ts
const object = new LiveObject({ firstName: "Grace" });
object.update({ lastName: "Hopper", job: "Computer Scientist" });

// { firstName: "Grace", lastName: "Hopper", job: "Computer Scientist" }
object.toImmutable();
```

<PropertiesListEmpty title="Returns">_Nothing_</PropertiesListEmpty>

<PropertiesList title="Arguments">
  <PropertiesListItem name="value" type="LsonObject" required>
    The keys and values youâ€™re updating. Can contain JSON-serializable data and
    other Liveblocks conflict-free data structures. Nested changes to other
    Storage types will not be applied.
  </PropertiesListItem>
</PropertiesList>

### clone [#LiveObject.clone]

Returns a deep copy of the `LiveObject` that can be inserted elsewhere in the
Storage tree.

```ts
const obj = new LiveObject(/* ... */);
root.set("a", obj);
root.set("b", obj.clone());
```

<PropertiesList title="Returns">
  <PropertiesListItem name="clonedStructure" type="LiveObject">
    The cloned `LiveObject`.
  </PropertiesListItem>
</PropertiesList>

<PropertiesListEmpty title="Arguments">_None_</PropertiesListEmpty>

### toImmutable [#LiveObject.toImmutable]

Returns an immutable JavaScript object that is equivalent to the `LiveObject`.
Nested values will also be immutable. Calling this method multiple times has no
performance penalty. It will return the same cached immutable value as long as
its (nested) contents have not changed.

```ts
const liveObject = new LiveObject({
  firstName: "Grace",
  lastName: "Hopper",
  hobbies: new LiveList(["reading", "piano"]),
});

// {
//   firstName: "Grace",
//   lastName: "Hopper",
//   hobbies: ["reading", "piano"]
// }
liveObject.toImmutable();
```

<PropertiesList title="Returns">
  <PropertiesListItem name="immutableStructure" type="object">
    Returns a JavaScript object in the shape of your data structure.
    `LiveObject` is converted to an object, `LiveMap` to a map, and `LiveList`
    to an array.
  </PropertiesListItem>
</PropertiesList>

<PropertiesListEmpty title="Arguments">_None_</PropertiesListEmpty>

### toObject [#LiveObject.toObject]

<Banner title="Will be deprecated in the future">

Starting with 0.18, we recommend [`toImmutable`][] instead. Itâ€™s faster, cached,
and leads to fewer surprises.

</Banner>

Transform the `LiveObject` into a normal JavaScript object.

```ts
const liveObject = new LiveObject({ firstName: "Grace", lastName: "Hopper" });
liveObject.toObject();
// { firstName: "Grace", lastName: "Hopper" }
```

Please note that this method wonâ€™t recursively convert Live structures, which
may be surprising:

```ts
const liveObject = new LiveObject({
  animals: new LiveList(["ðŸ¦", "ðŸ¦Š", "ðŸµ"]),
});
liveObject.toObject();
// { animals: <LiveList instance> } // â—ï¸
```

## LiveMap

The `LiveMap` class is similar to a
[JavaScript Map](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Map)
that is synchronized on all clients. Use this for indexing values that all have
the same structure. For example, to store an index of `Person` values by their
name. To add typing, read more under [typing Storage](#typing-storage).

```ts
type Shapes = LiveMap<string, LiveObject<{ name: string }>>;
```

Keys are strings, and values can contain other Storage structures, or
JSON-serializable data. If multiple clients update the same property
simultaneously, the last modification received by the Liveblocks servers is the
winner.

### new LiveMap [#LiveMap.constructor]

Create an empty `LiveMap`.

```ts
const map = new LiveMap();
```

Create a `LiveMap` with initial data.

```ts
const map = new LiveMap([
  ["nimesh", "developer"],
  ["pierre", "designer"],
]);
```

<PropertiesList title="Returns">
  <PropertiesListItem name="LiveMap" type="LiveMap<string, L>">
    The newly created `LiveMap`.
  </PropertiesListItem>
</PropertiesList>

<PropertiesList title="Arguments">
  <PropertiesListItem
    name="initialValue"
    type="[string, L extends LsonObject][]"
    required
  >
    The initial value for the `LiveMap`. An array of tuples, each containing a
    key and a value. The values can contain JSON-serializable data and other
    Liveblocks conflict-free data structures.
  </PropertiesListItem>
</PropertiesList>

#### Add a LiveMap to Storage

The Storage root is a `LiveObject`, so you can create a new `LiveMap` then use
[`LiveObject.set`]() to add it to your root. If youâ€™ve
[typed Storage](#typing-storage) youâ€™ll have type hints as you build.

```ts
import { LiveMap } from "@liveblocks/client";

const { root } = await room.getStorage();

const people = new LiveMap([
  ["vincent", "engineer"],
  ["marc", "designer"],
]);
root.set("people", people);
```

### delete [#LiveMap.delete]

Removes the specified element by key. Returns true if an element existed and has
been removed, or false if the element does not exist.

```ts
const map = new LiveMap([
  ["nimesh", "developer"],
  ["pierre", "designer"],
]);

// true
map.delete("nimesh");

// Map { "pierre" => "designer" }
map.toImmutable();
```

<PropertiesList title="Returns">
  <PropertiesListItem name="deleted" type="boolean">
    If the element existed and was removed.
  </PropertiesListItem>
</PropertiesList>

<PropertiesList title="Arguments">
  <PropertiesListItem name="key" type="string" required>
    The key of the element youâ€™re deleting. If the element doesnâ€™t exist,
    nothing will occur.
  </PropertiesListItem>
</PropertiesList>

### entries [#LiveMap.entries]

Returns a new
[Iterator](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Guide/Iterators_and_Generators)
object that contains the `[key, value]` pairs for each element.

```ts
for (const [key, value] of map.entries()) {
  // Iterate over all the keys and values of the map
}
```

<Banner title="Iteration with TypeScript">

If your TypeScript project targets <code>es5</code> or lower, youâ€™ll need to
enable the <code>--downlevelIteration</code> option to use this API.

</Banner>

<PropertiesList title="Returns">
  <PropertiesListItem name="iterator" type="IterableIterator<[string, L]>">
    A new Iterator object for the `LiveMap`, containing the `[key, value]` pairs
    for each element.
  </PropertiesListItem>
</PropertiesList>

<PropertiesListEmpty title="Arguments">_None_</PropertiesListEmpty>

### forEach [#LiveMap.forEach]

Executes a provided function once per each key/value pair in the Map object, in
insertion order.

```ts
const map = new LiveMap([
  ["nimesh", "developer"],
  ["pierre", "designer"],
]);

// "developer", "designer"
map.forEach((value, key, liveMap) => console.log(value));
```

<PropertiesListEmpty title="Returns">_Nothing_</PropertiesListEmpty>

<PropertiesList title="Arguments">
  <PropertiesListItem
    name="callback"
    detailedType="(value: L, key: string, map: LiveMap<string, L>) => void"
    required
  >
    A callback for each entry. The callback is passed the current `value`,
    `key`, and the `LiveMap`. Return values are ignored.
  </PropertiesListItem>
</PropertiesList>

### get [#LiveMap.get]

Returns a specified element from the `LiveMap`. Returns `undefined` if the key
canâ€™t be found.

```ts
const map = new LiveMap([
  ["nimesh", "developer"],
  ["pierre", "designer"],
]);

// "developer"
map.get("nimesh");

// undefined
map.get("alicia");
```

<PropertiesList title="Returns">
  <PropertiesListItem name="value" type="L | undefined">
    The value of the entry. Returns `undefined` if it doesnâ€™t exist.
  </PropertiesListItem>
</PropertiesList>

<PropertiesList title="Arguments">
  <PropertiesListItem name="key" type="string" required>
    The key of the entry youâ€™re getting.
  </PropertiesListItem>
</PropertiesList>

### has [#LiveMap.has]

Returns a boolean indicating whether an element with the specified key exists or
not.

```ts
const map = new LiveMap([
  ["nimesh", "developer"],
  ["pierre", "designer"],
]);

// true
map.has("nimesh");

// false
map.has("alicia");
```

<PropertiesList title="Returns">
  <PropertiesListItem name="exists" type="boolean">
    Whether the entry exists.
  </PropertiesListItem>
</PropertiesList>

<PropertiesList title="Arguments">
  <PropertiesListItem name="key" type="string" required>
    The key of the entry youâ€™re getting.
  </PropertiesListItem>
</PropertiesList>

### keys [#LiveMap.keys]

Returns a new
[Iterator](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Guide/Iterators_and_Generators)
object that contains the keys for each element.

```ts
for (const key of map.keys()) {
  // Iterate over all the keys and values of the map
}
```

<Banner title="Iteration with TypeScript">

If your TypeScript project targets <code>es5</code> or lower, youâ€™ll need to
enable the <code>--downlevelIteration</code> option to use this API.

</Banner>

<PropertiesList title="Returns">
  <PropertiesListItem name="iterator" type="IterableIterator<string>">
    A new Iterator object for the `LiveMap`, containing the keys of each entry.
  </PropertiesListItem>
</PropertiesList>

<PropertiesListEmpty title="Arguments">_None_</PropertiesListEmpty>

### set [#LiveMap.set]

Adds or updates an element with a specified key and a value.

```ts
const map = new LiveMap();
map.set("vincent", "engineer");

// Map { "vincent" => "engineer" }
map.toImmutable();
```

<PropertiesListEmpty title="Returns">_Nothing_</PropertiesListEmpty>

<PropertiesList title="Arguments">
  <PropertiesListItem name="key" type="string" required>
    The key of the entry youâ€™re setting.
  </PropertiesListItem>
  <PropertiesListItem name="value" type="LsonObject" required>
    The value of the entry youâ€™re setting. Can contain JSON-serializable data
    and other Liveblocks conflict-free data structures.
  </PropertiesListItem>
</PropertiesList>

### size [#LiveMap.size]

Returns the number of elements in the `LiveMap`.

```ts
const map = new LiveMap([
  ["nimesh", "developer"],
  ["pierre", "designer"],
]);

// 2
map.size;
```

<PropertiesList title="Returns">
  <PropertiesListItem name="size" type="number">
    The number of entries in the `LiveMap`
  </PropertiesListItem>
</PropertiesList>

<PropertiesList title="Arguments">
  <PropertiesListItem>_N/A_</PropertiesListItem>
</PropertiesList>

### values [#LiveMap.values]

Returns a new
[Iterator](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Guide/Iterators_and_Generators)
object that contains the values for each element.

```ts
for (const value of map.values()) {
  // Iterate over all the values of the map
}
```

<Banner title="Iteration with TypeScript">

If your TypeScript project targets <code>es5</code> or lower, youâ€™ll need to
enable the <code>--downlevelIteration</code> option to use this API.

</Banner>

<PropertiesList title="Returns">
  <PropertiesListItem name="iterator" type="IterableIterator<L>">
    A new Iterator object for the `LiveMap`, containing the values of each
    entry.
  </PropertiesListItem>
</PropertiesList>

<PropertiesListEmpty title="Arguments">_None_</PropertiesListEmpty>

### clone [#LiveMap.clone]

Returns a deep copy of the `LiveMap` that can be inserted elsewhere in the
Storage tree.

```ts
const map = new LiveMap(/* ... */);
root.set("a", map);
root.set("b", map.clone());
```

<PropertiesList title="Returns">
  <PropertiesListItem name="clonedStructure" type="LiveMap">
    The cloned `LiveMap`.
  </PropertiesListItem>
</PropertiesList>

<PropertiesListEmpty title="Arguments">_None_</PropertiesListEmpty>

### toImmutable [#LiveMap.toImmutable]

Returns an immutable ES6 Map that is equivalent to the `LiveMap`. Nested values
will also be immutable. Calling this method multiple times has no performance
penalty. It will return the same cached immutable value as long as its (nested)
contents have not changed.

```ts
const map = new LiveMap([
  ["florent", new LiveObject({ role: "engineer" })],
  ["marc", new LiveObject({ role: "designer" })],
]);

// Map {
//   "florent" => { role: "engineer" },
//   "marc" => { role: "designer" },
// }
map.toImmutable();
```

<PropertiesList title="Returns">
  <PropertiesListItem name="immutableStructure" type="object">
    Returns a JavaScript object in the shape of your data structure. `LiveMap`
    is converted to a map, `LiveObject` to an object, and `LiveList` to an
    array.
  </PropertiesListItem>
</PropertiesList>

<PropertiesListEmpty title="Arguments">_None_</PropertiesListEmpty>

## LiveList

The `LiveList` class represents an ordered collection of items that is
synchronized across clients. To add typing, read more under
[typing Storage](#typing-storage).

```ts
type Names = LiveList<string>;
```

Items can contain other Storage structures, or JSON-serializable data.

### new LiveList [#LiveList.constructor]

Create an empty `LiveList`.

```ts
const list = new LiveList();
```

Create a `LiveList` with initial data.

```ts
const list = new LiveList(["adrien", "jonathan"]);
```

<PropertiesList title="Returns">
  <PropertiesListItem name="LiveList" type="LiveList<L>">
    The newly created `LiveList`.
  </PropertiesListItem>
</PropertiesList>

<PropertiesList title="Arguments">
  <PropertiesListItem
    name="initialValue"
    type="Array<L extends LsonObject>"
    required
  >
    The initial array of values for the `LiveList`. Can contain
    JSON-serializable data and other Liveblocks conflict-free data structures.
  </PropertiesListItem>
</PropertiesList>

### clear [#LiveList.clear]

Removes all the elements.

```ts
const list = new LiveList(["adrien", "jonathan"]);
list.clear();

// []
list.toImmutable();
```

<PropertiesListEmpty title="Returns">_Nothing_</PropertiesListEmpty>

<PropertiesListEmpty title="Arguments">_None_</PropertiesListEmpty>

### delete [#LiveList.delete]

Deletes the element living at the specified index locally. If the index doesn't
exist, an `Error` is thrown.

```ts
const list = new LiveList(["adrien", "jonathan"]);
list.delete(0);

// ["jonathan"]
list.toImmutable();
```

This operation uses ID-based semantics, not position-based. When called, it
reads the item at the specified index from the local state, then sends a "delete
item with ID X" instruction to the server.

If clients A and B both see a LiveList containing `["foo", "bar"]`, and client A
calls `.insert("qux", 0)`, while client B simultaneously calls `.delete(0)`, the
end result will always be `["qux", "bar"]` on both clients, and never
`["foo", "bar"]`.

<PropertiesListEmpty title="Returns">_Nothing_</PropertiesListEmpty>

<PropertiesList title="Arguments">
  <PropertiesListItem name="index" type="number" required>
    The index of the property youâ€™re deleting. If the property doesnâ€™t exist, an
    `Error` is thrown.
  </PropertiesListItem>
</PropertiesList>

### every [#LiveList.every]

Tests whether all elements pass the test implemented by the provided function.
Returns true if the predicate function returns a truthy value for every element.
Otherwise, false.

```ts
const list = new LiveList([0, 2, 4]);

// true
list.every((i) => i % 2 === 0);

list.push(5);

// false
list.every((i) => i % 2 === 0);
```

<PropertiesList title="Returns">
  <PropertiesListItem name="isEvery" type="boolean">
    Whether all elements pass the test implemented by the provided function.
  </PropertiesListItem>
</PropertiesList>

<PropertiesList title="Arguments">
  <PropertiesListItem
    name="callback"
    type="(value: L, index: number) => unknown"
    required
  >
    A function to execute for each item in the array. It should return a truthy
    value to indicate the element passes the test, and a falsy value otherwise.
    The function is passed the `value` of the item and its current `index`.
  </PropertiesListItem>
</PropertiesList>

### filter [#LiveList.filter]

Creates an array with all elements that pass the test implemented by the
provided function.

```ts
const list = new LiveList([0, 1, 2, 3, 4]);

// [0, 2, 4]
list.filter((i) => i % 2 === 0);
```

<PropertiesList title="Returns">
  <PropertiesListItem name="filteredArray" type="L[]">
    An array containing each item of the `LiveList` that passed the test
    implemented by the provided function.
  </PropertiesListItem>
</PropertiesList>

<PropertiesList title="Arguments">
  <PropertiesListItem
    name="callback"
    type="(value: L, index: number) => unknown"
    required
  >
    A function to execute for each item in the array. It should return a truthy
    value to indicate the element passes the test, and a falsy value otherwise.
    The function is passed the `value` of the item and its current `index`.
  </PropertiesListItem>
</PropertiesList>

### find [#LiveList.find]

Returns the first element that satisfies the provided testing function. If no
item passes the test, `undefined` is returned.

```ts
const list = new LiveList(["apple", "lemon", "tomato"]);

// "lemon"
list.find((value, index) => value.startsWith("l"));
```

<PropertiesList title="Returns">
  <PropertiesListItem name="item" type="L | undefined">
    The item that has been found. If no item passes the test, `undefined` is
    returned.
  </PropertiesListItem>
</PropertiesList>

<PropertiesList title="Arguments">
  <PropertiesListItem
    name="callback"
    type="(value: L, index: number) => unknown"
    required
  >
    A function to execute for each item in the array. It should return a truthy
    value to indicate the element passes the test, and a falsy value otherwise.
    The function is passed the `value` of the item and its current `index`.
  </PropertiesListItem>
</PropertiesList>

### findIndex [#LiveList.findIndex]

Returns the index of the first element in the `LiveList` that satisfies the
provided testing function. If no item passes the test, `-1` is returned.

```ts
const list = new LiveList(["apple", "lemon", "tomato"]);

// 1
list.findIndex((value, index) => value.startsWith("l"));
```

<PropertiesList title="Returns">
  <PropertiesListItem name="index" type="number">
    The index of the item that has been found. If no item passes the test, `-1`
    is returned.
  </PropertiesListItem>
</PropertiesList>

<PropertiesList title="Arguments">
  <PropertiesListItem
    name="callback"
    type="(value: L, index: number) => unknown"
    required
  >
    A function to execute for each item in the array. It should return a truthy
    value to indicate the element passes the test, and a falsy value otherwise.
    The function is passed the `value` of the item and its current `index`.
  </PropertiesListItem>
</PropertiesList>

### forEach [#LiveList.forEach]

Executes a provided function once for each element.

```ts
const list = new LiveList(["adrien", "jonathan"]);

// "adrien", "jonathan"
list.forEach((item) => console.log(item));
```

<PropertiesListEmpty title="Returns">_Nothing_</PropertiesListEmpty>

<PropertiesList title="Arguments">
  <PropertiesListItem
    name="callback"
    detailedType="(value: L, index: number) => void"
    required
  >
    A callback for each item. The callback is passed the current `value` and
    `index`. Return values are ignored.
  </PropertiesListItem>
</PropertiesList>

### get [#LiveList.get]

Get the element at the specified index. Returns `undefined` if the index doesnâ€™t
exist.

```ts
const list = new LiveList(["adrien", "jonathan"]);

// "jonathan"
list.get(1);
```

<PropertiesList title="Returns">
  <PropertiesListItem name="item" type="L | undefined">
    The value of the item at the index. Returns `undefined` if it doesnâ€™t exist.
  </PropertiesListItem>
</PropertiesList>

<PropertiesList title="Arguments">
  <PropertiesListItem name="index" type="number" required>
    The index of the item youâ€™re getting.
  </PropertiesListItem>
</PropertiesList>

### indexOf [#LiveList.indexOf]

Returns the first index at which a given element can be found in the `LiveList`.
Returns `-1` if it is not present.

```ts
const list = new LiveList(["adrien", "jonathan"]);

// 1
list.indexOf("jonathan");

// undefined
list.indexOf("chris");
```

<PropertiesList title="Returns">
  <PropertiesListItem name="index" type="number">
    The index of the item. Returns `-1` if it doesnâ€™t exist.
  </PropertiesListItem>
</PropertiesList>

<PropertiesList title="Arguments">
  <PropertiesListItem name="searchElement" type="L" required>
    The item youâ€™re locating.
  </PropertiesListItem>
  <PropertiesListItem name="index" type="number">
    The index to start the search at.
  </PropertiesListItem>
</PropertiesList>

### insert [#LiveList.insert]

Inserts one element at a specified index. Throws an `Error` if the index is out
of bounds.

```ts
const list = new LiveList(["adrien", "jonathan"]);

list.insert("chris", 1);

// ["adrien", "chris", "jonathan"]
list.toImmutable();
```

<PropertiesListEmpty title="Returns">_Nothing_</PropertiesListEmpty>

<PropertiesList title="Arguments">
  <PropertiesListItem name="value" type="L extends LsonObject" required>
    The value of the item youâ€™re inserting.
  </PropertiesListItem>
  <PropertiesListItem name="index" type="number" required>
    The index to insert the item into.
  </PropertiesListItem>
</PropertiesList>

### lastIndexOf [#LiveList.lastIndexOf]

Returns the last index at which a given element can be found in the `LiveList`,
or -1 if it is not present. The `LiveList` is searched backwards, starting at
fromIndex. Returns `-1` if it is not present.

```ts
const list = new LiveList(["adrien", "jonathan", "adrien"]);

// 2
list.indexOf("adrien");

// undefined
list.indexOf("chris");
```

<PropertiesList title="Returns">
  <PropertiesListItem name="index" type="number">
    The index of the item. Returns `-1` if it doesnâ€™t exist.
  </PropertiesListItem>
</PropertiesList>

<PropertiesList title="Arguments">
  <PropertiesListItem name="searchElement" type="L" required>
    The item youâ€™re locating.
  </PropertiesListItem>
  <PropertiesListItem name="index" type="number">
    The index at which to start searching backwards.
  </PropertiesListItem>
</PropertiesList>

### length [#LiveList.length]

Returns the number of elements.

```ts
const list = new LiveList(["adrien", "jonathan"]);

// 2
list.length;
```

<PropertiesList title="Returns">
  <PropertiesListItem name="length" type="number">
    The number of items in the `LiveList`.
  </PropertiesListItem>
</PropertiesList>

<PropertiesList title="Arguments">
  <PropertiesListItem>_N/A_</PropertiesListItem>
</PropertiesList>

### map [#LiveList.map]

Creates an array populated with the results of calling a provided function on
every element.

```ts
const list = new LiveList(["apple", "lemon", "tomato"]);

// ["APPLE", "LEMON", "TOMATO"]
list.map((value, index) => value.toUpperCase());
```

<PropertiesList title="Returns">
  <PropertiesListItem name="array">
    The array of each item has been transformed by the callback function.
  </PropertiesListItem>
</PropertiesList>

<PropertiesList title="Arguments">
  <PropertiesListItem
    name="callback"
    detailedType="(value: L, index: number) => void"
    required
  >
    A callback for each item. The callback is passed the current `value` and
    `index`. Return values are used in the returned array.
  </PropertiesListItem>
</PropertiesList>

### move [#LiveList.move]

Moves one element at a specified index.

```ts
const list = new LiveList(["adrien", "chris", "jonathan"]);

list.move(2, 0);

// ["jonathan", "adrien", "chris"]
list.toImmutable();
```

<PropertiesListEmpty title="Returns">_Nothing_</PropertiesListEmpty>

<PropertiesList title="Arguments">
  <PropertiesListItem name="index" type="number" required>
    The index of the item to move.
  </PropertiesListItem>
  <PropertiesListItem name="targetIndex" type="number" required>
    The index where the element should be after moving.
  </PropertiesListItem>
</PropertiesList>

### push [#LiveList.push]

Adds one element to the end of the `LiveList`.

```ts
const list = new LiveList(["adrien", "jonathan"]);

list.push("chris");

// ["adrien", "jonathan", "chris"]
list.toImmutable();
```

<PropertiesListEmpty title="Returns">_Nothing_</PropertiesListEmpty>

<PropertiesList title="Arguments">
  <PropertiesListItem name="index" type="L" required>
    The item to add to the end of the `LiveList`.
  </PropertiesListItem>
</PropertiesList>

### set [#LiveList.set]

Replace one element at the specified index.

```ts
const list = new LiveList(["adrien", "jonathan"]);

list.set(1, "chris");

// equals ["adrien", "chris"]
list.toImmutable();
```

### some [#LiveList.some]

Tests whether at least one element in the `LiveList` passes the test implemented
by the provided function.

```ts
const list = new LiveList(["apple", "lemon", "tomato"]);

// true
list.some((value, index) => value.startsWith("l"));

// false
list.some((value, index) => value.startsWith("x"));
```

<PropertiesList title="Returns">
  <PropertiesListItem name="areSome" type="boolean">
    Whether any elements pass the test implemented by the provided function.
  </PropertiesListItem>
</PropertiesList>

<PropertiesList title="Arguments">
  <PropertiesListItem
    name="callback"
    type="(value: L, index: number) => unknown"
    required
  >
    A function to execute for each item in the array. It should return a truthy
    value to indicate the element passes the test, and a falsy value otherwise.
    The function is passed the `value` of the item and its current `index`.
  </PropertiesListItem>
</PropertiesList>

### clone [#LiveList.clone]

Returns a deep copy of the `LiveList` that can be inserted elsewhere in the
Storage tree.

```ts
const list = new LiveList(/* ... */);
root.set("a", list);
root.set("b", list.clone());
```

<PropertiesList title="Returns">
  <PropertiesListItem name="clonedStructure" type="LiveList">
    The cloned `LiveList`.
  </PropertiesListItem>
</PropertiesList>

<PropertiesListEmpty title="Arguments">_None_</PropertiesListEmpty>

### toImmutable [#LiveList.toImmutable]

Returns an immutable JavaScript array that is equivalent to the `LiveList`.
Nested values will also be immutable. Calling this method multiple times has no
performance penalty. It will return the same cached immutable value as long as
its (nested) contents have not changed.

```ts
const list = new LiveList([
  new LiveObject({ name: "Olivier" }),
  new LiveObject({ name: "Vincent" }),
]);

// [
//   { name: "Olivier" },
//   { name: "Vincent" },
// ]
list.toImmutable();
```

<PropertiesList title="Returns">
  <PropertiesListItem name="immutableStructure" type="object">
    Returns a JavaScript object in the shape of your data structure. `ListList`
    is converted to an array, `LiveObject` to an object, and `LiveMap` to a map.
  </PropertiesListItem>
</PropertiesList>

<PropertiesListEmpty title="Arguments">_None_</PropertiesListEmpty>

### toArray [#LiveList.toArray]

<Banner title="Will be deprecated in the future">

Starting with 0.18, we recommend [`toImmutable`][] instead. Itâ€™s faster, cached,
and leads to fewer surprises.

</Banner>

Transforms the `LiveList` into a normal JavaScript array.

```ts
const list = new LiveList(["ðŸ¦", "ðŸ¦Š", "ðŸµ"]);
list.toArray();
// ["ðŸ¦", "ðŸ¦Š", "ðŸµ"]
```

Please note that this method wonâ€™t recursively convert Live structures, which
may be surprising:

```ts
const list = new LiveList([
  new LiveObject({ firstName: "Grace", lastName: "Hopper" }),
]);
list.toArray();
// [ <LiveObject instance> ]  // â—ï¸
```

## Resolvers

### invalidateUsers

`client.resolvers.invalidateUsers` can be used to invalidate some or all users
that were previously cached by [`resolveUsers`](#createClientResolveUsers).

It can be used when updating the current userâ€™s avatar for example, to instantly
refresh the user data everywhere without having to perform a page reload.

```tsx
// Invalidate all users
client.resolvers.invalidateUsers();

// Only invalidate "user-0" and "user-1"
client.resolvers.invalidateUsers(["user-0", "user-1"]);
```

### invalidateRoomsInfo

`client.resolvers.invalidateRoomsInfo` can be used to invalidate some or all
rooms that were previously cached by
[`resolveRoomsInfo`](#createClientResolveRoomsInfo).

It can be used when updating a roomâ€™s name for example, to instantly refresh the
room info everywhere without having to perform a page reload.

```tsx
// Invalidate all rooms
client.resolvers.invalidateRoomsInfo();

// Only invalidate "room-0" and "room-1"
client.resolvers.invalidateRoomsInfo(["room-0", "room-1"]);
```

### invalidateGroupsInfo

`client.resolvers.invalidateGroupsInfo` can be used to invalidate some or all
groups that were previously cached by
[`resolveGroupsInfo`](#createClientResolveGroupsInfo).

It can be used when updating a groupâ€™s name for example, to instantly refresh
the group info everywhere without having to perform a page reload.

```tsx
// Invalidate all groups
client.resolvers.invalidateGroupsInfo();

// Only invalidate "group-0" and "group-1"
client.resolvers.invalidateGroupsInfo(["group-0", "group-1"]);
```

### invalidateMentionSuggestions

`client.resolvers.invalidateMentionSuggestions` can be used to invalidate all
mention suggestions that were previously cached by
[`resolveMentionSuggestions`](#createClientResolveMentionSuggestions).

It can be used when updating a roomâ€™s list of users for example, to prevent
creating out-of-date mentions without having to perform a page reload.

```tsx
// Invalidate all mention suggestions
client.resolvers.invalidateMentionSuggestions();
```

## Utilities

### getMentionsFromCommentBody [#get-mentions-from-comment-body]

Returns an array of mentions from a `CommentBody` (found under `comment.body`).

```ts
import { getMentionsFromCommentBody } from "@liveblocks/client";

const mentions = getMentionsFromCommentBody(comment.body);
```

An optional second argument can be used to filter the returned mentions. By
default, if itâ€™s not provided, all mentions are returned, including future
mention kinds (e.g. group mentions in the future).

```tsx
// All mentions (same as `getMentionsFromCommentBody(commentBody)`)
getMentionsFromCommentBody(commentBody);

// Only user mentions with an ID of "123"
getMentionsFromCommentBody(
  commentBody,
  (mention) => mention.kind === "user" && mention.id === "123"
);

// Only mentions with an ID which starts with "prefix:"
getMentionsFromCommentBody(commentBody, (mention) => (
  mention.id.startsWith("prefix:")
);
```

Hereâ€™s an example with a custom `CommentBody`.

```ts
import { CommentBody, getMentionsFromCommentBody } from "@liveblocks/client";

// Create a custom `CommentBody`
const commentBody: CommentBody = {
  version: 1,
  content: [
    {
      type: "paragraph",
      children: [
        { text: "Hello " },
        { type: "mention", id: "chris@example.com" },
      ],
    },
  ],
};

// Get the mentions inside the commentâ€™s body
const mentions = getMentionsFromCommentBody(commentBody);

// [{ kind: "user", id: "chris@example.com" }]
console.log(mentions);
```

<Banner title="Also available from @liveblocks/node">

If youâ€™d like to use this on the server side, itâ€™s also available from
[`@liveblocks/node`](/docs/api-reference/liveblocks-node#get-mentions-from-comment-body).

</Banner>

### stringifyCommentBody [#stringify-comment-body]

Used to convert a `CommentBody` (found under `comment.body`) into either a plain
string, Markdown, HTML, or a custom format.

```ts
import { stringifyCommentBody } from "@liveblocks/client";

const stringComment = await stringifyCommentBody(comment.body);

// "Hello marc@example.com from https://liveblocks.io"
console.log(stringComment);
```

A number of options are available.

```ts
import { stringifyCommentBody } from "@liveblocks/client";

const stringComment = await stringifyCommentBody(comment.body, {
  // Optional, convert to specific format, "plain" (default) | "markdown" | "html"
  format: "markdown",

  // Optional, supply a separator to be used between paragraphs
  separator: `\n\n`,

  // Optional, override any elements in the CommentBody with a custom string
  elements: {
    // Optional, override the `paragraph` element
    paragraph: ({ element, children }) => `<p>${children}</p>`,

    // Optional, override the `text` element
    text: ({ element }) =>
      element.bold ? `<strong>${element.text}</strong>` : `${element.text}`,

    // Optional, override the `link` element
    link: ({ element, href }) =>
      `<a href="${href}" target="_blank">${element.url}</a>`,

    // Optional, override the `mention` element.
    // `user` and `group` are the optional data returned from `resolveUsers` and `resolveGroupsInfo`
    mention: ({ element, user, group }) =>
      `<a href="${user?.profileUrl ?? group?.settingsUrl ?? "#"}">${
        element.id
      }</a>`,
  },

  // Optional, get your userâ€™s names and info from their ID to be displayed in mentions
  async resolveUsers({ userIds }) {
    const usersData = await __getUsersFromDB__(userIds);

    return usersData.map((userData) => ({
      // Name is inserted into the output instead of a userâ€™s ID
      name: userData.name,

      // Custom formatting in `elements.mention` allows custom properties to be used
      profileUrl: userData.profileUrl,
    }));
  },

  // Optional, get your groupâ€™s names and info from their ID to be displayed in mentions
  async resolveGroupsInfo({ groupIds }) {
    const groupsData = await __getGroupsFromDB__(groupIds);

    return groupsData.map((groupData) => ({
      // Name is inserted into the output instead of a groupâ€™s ID
      name: groupData.name,

      // Custom formatting in `elements.mention` allows custom properties to be used
      settingsUrl: groupData.settingsUrl,
    }));
  },
});
```

<Banner title="Also available from @liveblocks/node">

If youâ€™d like to use this on the server side, itâ€™s also available from
[`@liveblocks/node`](/docs/api-reference/liveblocks-node#stringify-comment-body).

</Banner>

#### Formatting examples

Here are a number of different formatting examples derived from the same
`CommentBody`.

```ts
// "Hello marc@example.com from https://liveblocks.io"
await stringifyCommentBody(comment.body);

// "Hello @Marc from https://liveblocks.io"
await stringifyCommentBody(comment.body, {
  resolveUsers({ userIds }) {
    return [{ name: "Marc" }];
  },
});

// "**Hello** @Marc from [https://liveblocks.io](https://liveblocks.io)"
await stringifyCommentBody(comment.body, {
  format: "markdown",

  resolveUsers() {
    return [{ name: "Marc" }];
  },
});

// "<b>Hello</b> <span data-mention>@Marc</span> from
// <a href="https://liveblocks.io">https://liveblocks.io</a>"
await stringifyCommentBody(comment.body, {
  format: "html",

  resolveUsers() {
    return [{ name: "Marc" }];
  },
});

// "<b>Hello</b> <a href="https://example.com" data-id="marc@example.com">@Marc</a> from
// <a href="https://liveblocks.io">https://liveblocks.io</a>"
await stringifyCommentBody(comment.body, {
  format: "html",

  mention: ({ element, user }) =>
    `<a href="${user.profileUrl}" data-id="${element.id}">${user.name}</a>`,

  resolveUsers() {
    return [{ name: "Marc", profileUrl: "https://example.com" }];
  },
});
```

## TypeScript

### Typing your data

Itâ€™s possible to have automatic types flow through your application by defining
a global `Liveblocks` interface. We recommend doing this in a
`liveblocks.config.ts` file in the root of your app, so itâ€™s easy to keep track
of your types. Each type (`Presence`, `Storage`, etc.), is optional, but itâ€™s
recommended to make use of them.

```ts file="liveblocks.config.ts"
declare global {
  interface Liveblocks {
    // Each userâ€™s Presence
    Presence: {};

    // The Storage tree for the room
    Storage: {};

    UserMeta: {
      id: string;
      // Custom user info set when authenticating with a secret key
      info: {};
    };

    // Custom events
    RoomEvent: {};

    // Custom metadata set on threads
    ThreadMetadata: {};

    // Custom metadata set on comments
    CommentMetadata: {};

    // Custom room info set with resolveRoomsInfo
    RoomInfo: {};

    // Custom group info set with resolveGroupsInfo
    GroupInfo: {};

    // Custom activities data for custom notification kinds
    ActivitiesData: {};
  }
}

// Necessary if you have no imports/exports
export {};
```

Here are some example values that might be used.

```ts file="liveblocks.config.ts"
import { LiveList } from "@liveblocks/client";

declare global {
  interface Liveblocks {
    // Each userâ€™s Presence
    Presence: {
      // Example, real-time cursor coordinates
      cursor: { x: number; y: number };
    };

    // The Storage tree for the room
    Storage: {
      // Example, a conflict-free list
      animals: LiveList<string>;
    };

    UserMeta: {
      id: string;
      // Custom user info set when authenticating with a secret key
      info: {
        // Example properties
        name: string;
        avatar: string;
      };
    };

    // Custom events
    // Example has two events, using a union
    RoomEvent: { type: "PLAY" } | { type: "REACTION"; emoji: "ðŸ”¥" };

    // Custom metadata set on threads
    ThreadMetadata: {
      // Example, attaching coordinates to a thread
      x: number;
      y: number;
    };

    // Custom metadata set on comments
    CommentMetadata: {
      // Example, attaching a tag and a hidden flag to a comment
      tag: string;
      spam: boolean;
    };

    // Custom room info set with resolveRoomsInfo
    RoomInfo: {
      // Example, rooms with a title and url
      title: string;
      url: string;
    };

    // Custom group info set with resolveGroupsInfo
    GroupInfo: {
      // Example, groups with a name and a badge
      name: string;
      badge: string;
    };

    // Custom activities data for custom notification kinds
    ActivitiesData: {
      // Example, a custom $alert kind
      $alert: {
        title: string;
        message: string;
      };
    };
  }
}

// Necessary if you have no imports/exports
export {};
```

### Typing with client.enter

Before Liveblocks 2.0, it was recommended to type your data by passing
`Presence`, `Storage`, `UserMeta`, and `RoomEvents` types to
[`client.enterRoom`][]. This is no longer
[the recommended method](#Typing-your-data) for setting up Liveblocks, but it
can still be helpful, for example you can use `client.enter` multiple times to
create different room types, each with their own correctly typed hooks.

```ts
import { LiveList } from "@liveblocks/client";

// Each userâ€™s Presence
type Presence = {
  cursor: { x: number; y: number };
};

// The Storage tree for the room
type Storage = {
  animals: LiveList<string>;
};

// User information set when authenticating with a secret key
type UserMeta = {
  id: string;
  info: {
    // Custom properties, corresponds with userInfo
  };
};

// Custom events that can be broadcast, use a union for multiple events
type RoomEvent = {
  type: "REACTION";
  emoji: "ðŸ”¥";
};

const { room, leave } = client.enterRoom<
  Presence,
  Storage,
  UserMeta,
  RoomEvent
>("my-room-id");
```

You can also pass types to
[`client.getRoom`](/docs/api-reference/liveblocks-client#Client.getRoom).

```ts
const { room, leave } = client.getRoom<Presence, Storage, UserMeta, RoomEvent>(
  "my-room-id"
);
```

### ToolDefinition

Type definition for AI tools that can be executed by the AI. This type
represents the structure of a tool that can be registered and used in AI
interactions.

```ts
type ToolDefinition<TArgs = any, TResult = any> = {
  description: string;
  parameters: JSONSchema7;
  execute: (
    args: TArgs,
    context: ToolExecutionContext
  ) => Promise<{ data: TResult }>;
  render: (props: ToolRenderProps<TArgs, TResult>) => ReactNode;
};
```

<PropertiesList title="Properties">
  <PropertiesListItem name="description" type="string">
    A clear description of what the tool does. Used by AI to understand when to
    call this tool.
  </PropertiesListItem>
  <PropertiesListItem name="parameters" type="JSONSchema7">
    JSON Schema defining the toolâ€™s input parameters. The AI will validate
    arguments against this schema.
  </PropertiesListItem>
  <PropertiesListItem name="execute" type="function">
    Async function that performs the toolâ€™s action. Receives validated arguments
    and execution context, returns structured data.
  </PropertiesListItem>
  <PropertiesListItem name="render" type="function">
    React component function that renders the toolâ€™s UI during different
    execution stages.
  </PropertiesListItem>
</PropertiesList>

### AiKnowledgeSource

Type definition for knowledge sources that provide contextual information to AI.
Knowledge sources help the AI understand your applicationâ€™s current state and
make more informed responses.

```ts
type AiKnowledgeSource = {
  description: string;
  value: string;
};
```

<PropertiesList title="Properties">
  <PropertiesListItem name="description" type="string">
    A clear description of what this knowledge represents (e.g., "Current userâ€™s
    profile", "Application settings").
  </PropertiesListItem>
  <PropertiesListItem
    name="value"
    type="string | object | array | number | boolean | null"
  >
    The knowledge content. Can be any JSON-compatible format that provides
    context to the AI.
  </PropertiesListItem>
</PropertiesList>

Knowledge sources can be registered using
[`RegisterAiKnowledge`](/docs/api-reference/liveblocks-react#RegisterAiKnowledge)
or passed directly to [`AiChat`](/docs/api-reference/liveblocks-react-ui#AiChat)
via the `knowledge` prop.

```ts
// Example knowledge sources
const userKnowledge: AiKnowledgeSource = {
  description: "Current user information",
  value: { name: "John Doe", role: "admin" },
};

const appStateKnowledge: AiKnowledgeSource = {
  description: "Current application state",
  value: "The user is currently editing a document in dark mode",
};
```

### User [#user-type]

`User` is a type thatâ€™s returned by [`room.getSelf`][], [`room.getOthers`][],
and other functions. Some of its values are set when
[typing your room](#Typing-your-data), here are some example values:

```ts file="liveblocks.config.ts"
declare global {
  interface Liveblocks {
    // Each userâ€™s Presence
    // +++
    Presence: {
      cursor: { x: number; y: number };
    };
    // +++

    UserMeta: {
      id: string;
      // Custom user info set when authenticating with a secret key
      // +++
      info: {
        name: string;
        avatar: string;
      };
      // +++
    };
  }
}
```

```ts
const { room, leave } = client.enterRoom("my-room-id");

// {
//   connectionId: 52,
//   +++
//   presence: {
//     cursor: { x: 263, y: 786 },
//   },
//   +++
//   id: "mislav.abha@example.com",
//   +++
//   info: {
//     name: "Mislav Abha",
//     avatar: "/mislav.png",
//   },
//   +++
//   canWrite: true,
//   canComment: true,
// }
const user = room.getSelf();
```

<PropertiesList title="Properties">
  <PropertiesListItem name="connectionId" type="number">
    The connection ID of the User. It is unique and increments with every new
    connection.
  </PropertiesListItem>
  <PropertiesListItem name="id" type={`UserMeta["id"]`}>
    The ID of the User that has been set in the authentication endpoint. Useful
    to get additional information about the connected user.
  </PropertiesListItem>
  <PropertiesListItem name="info" type={`UserMeta["info"]`}>
    Additional user information that has been set in the authentication
    endpoint.
  </PropertiesListItem>
  <PropertiesListItem name="presence" type={`TPresence`}>
    The userâ€™s Presence data.
  </PropertiesListItem>
  <PropertiesListItem name="canWrite" type="boolean">
    `true` if the user can mutate the Roomâ€™s Storage and/or YDoc, `false` if
    they can only read but not mutate it. Set via your [room
    permissions](/docs/authentication#Room-permissions).
  </PropertiesListItem>
  <PropertiesListItem name="canComment" type="boolean">
    `true` if the user can leave a comment in the room, `false` if they can only
    read comments but not leave them. Set via your [room
    permissions](/docs/authentication#Room-permissions).
  </PropertiesListItem>
</PropertiesList>

[`atob`]: https://developer.mozilla.org/en-US/docs/Web/API/atob
[`base-64`]: https://www.npmjs.com/package/base-64
[`client.enterroom`]: /docs/api-reference/liveblocks-client#Client.enterRoom
[`client.getroom`]: /docs/api-reference/liveblocks-client#Client.getRoom
[`createclient`]: /docs/api-reference/liveblocks-client#createClient
[`fetch`]: https://developer.mozilla.org/en-US/docs/Web/API/Fetch_API
[`livelist`]: /docs/api-reference/liveblocks-client#LiveList
[`livemap`]: /docs/api-reference/liveblocks-client#LiveMap
[`liveobject`]: /docs/api-reference/liveblocks-client#LiveObject
[`lostconnectiontimeout`]:
  /docs/api-reference/liveblocks-client#createClientLostConnectionTimeout
[`toimmutable`]: /docs/api-reference/liveblocks-client#LiveObject.toImmutable
[`node-fetch`]: https://npmjs.com/package/node-fetch
[`room.broadcastevent`]:
  /docs/api-reference/liveblocks-client#Room.broadcastEvent
[`room.getstorage`]: /docs/api-reference/liveblocks-client#Room.getStorage
[`room.reconnect`]: /docs/api-reference/liveblocks-client#Room.reconnect
[`room.getself`]: /docs/api-reference/liveblocks-client#Room.getSelf
[`room.getothers`]: /docs/api-reference/liveblocks-client#Room.getOthers
[`room.getstorage`]: /docs/api-reference/liveblocks-client#Room.getStorage
[`room.getsubscriptionsettings`]:
  /docs/api-reference/liveblocks-client#Room.getSubscriptionSettings
[`room.updatesubscriptionsettings`]:
  /docs/api-reference/liveblocks-client#Room.updateSubscriptionSettings
[`room.history`]: /docs/api-reference/liveblocks-client#Room.history
[`room.subscribe("event")`]:
  /docs/api-reference/liveblocks-client#Room.subscribe.event
[`room.subscribe("status")`]:
  /docs/api-reference/liveblocks-client#Room.subscribe.status
[`room.subscribe("lost-connection")`]:
  /docs/api-reference/liveblocks-client#Room.subscribe.lost-connection
[`room.subscribe("storage-status")`]:
  /docs/api-reference/liveblocks-client#Room.subscribe.storage-status
[`room.updatepresence`]:
  /docs/api-reference/liveblocks-client#Room.updatePresence
[`websocket`]: https://developer.mozilla.org/en-US/docs/Web/API/WebSocket
[`ws`]: https://www.npmjs.com/package/ws
[connection status example]:
  https://liveblocks.io/examples/connection-status/nextjs
[3.4]: https://github.com/liveblocks/liveblocks/releases/tag/v3.4.0
