---
meta:
  title: "@liveblocks/client"
  parentTitle: "API Reference"
  description: "API Reference for the @liveblocks/client package"
alwaysShowAllNavigationLevels: false
---

`@liveblocks/client` provides you with JavaScript bindings for our real-time
collaboration APIs, built on top of WebSockets. Read our
[getting started](/docs/get-started) guides to learn more.

## createClient

Creates a [client](#Client) that allows you to connect to Liveblocks servers.
You must define either `authEndpoint` or `publicApiKey`. Resolver functions
should be placed inside here, and a number of other options are available.

```tsx
import { createClient } from "@liveblocks/client";

const client = createClient({
  authEndpoint: "/api/liveblocks-auth",

  // Other options
  // ...
});
```

```tsx title="Every createClient option" isCollapsable isCollapsed
import { createClient } from "@liveblocks/client";

const client = createClient({
  // Connect with authEndpoint
  authEndpoint: "/api/liveblocks-auth",

  // Alternatively, use an authEndpoint callback
  // authEndpoint: async (room) => {
  //   const response = await fetch("/api/liveblocks-auth", {
  //   method: "POST",
  //   headers: {
  //     Authentication: "<your own headers here>",
  //     "Content-Type": "application/json",
  //   },
  //   body: JSON.stringify({ room }),
  // });
  // return await response.json();
  // },

  // Alternatively, use a public key
  // publicApiKey: "pk_...",

  // Throttle time (ms) between WebSocket updates
  throttle: 100,

  // Throw lost-connection event after 5 seconds offline
  lostConnectionTimeout: 5000,

  // Disconnect users after X (ms) of inactivity, disabled by default
  backgroundKeepAliveTimeout: undefined,

  // Resolve user info for Comments and Notifications
  resolveUsers: async ({ userIds }) => {
    const usersData = await __getUsersFromDB__(userIds);

    return usersData.map((userData) => ({
      name: userData.name,
      avatar: userData.avatar.src,
    }));
  },

  // Resolve room info for Notifications
  resolveRoomsInfo: async ({ roomIds }) => {
    const documentsData = await __getDocumentsFromDB__(roomIds);

    return documentsData.map((documentData) => ({
      name: documentData.name,
      // url: documentData.url,
    }));
  },

  // Resolve mention suggestions for Comments
  resolveMentionSuggestions: async ({ text, roomId }) => {
    const workspaceUsers = await __getWorkspaceUsersFromDB__(roomId);

    if (!text) {
      // Show all workspace users by default
      return __getUserIds__(workspaceUsers);
    } else {
      const matchingUsers = __findUsers__(workspaceUsers, text);
      return __getUserIds__(matchingUsers);
    }
  },

  // Polyfill options for non-browser environments
  polyfills: {
    // atob,
    // fetch,
    // WebSocket,
  },
});
```

<PropertiesList title="Returns">
  <PropertiesListItem name="client" type="Client">
    Returns a [Client](#Client), used for connecting to Liveblocks.
  </PropertiesListItem>
</PropertiesList>

<PropertiesList title="Options">
  <PropertiesListItem
    name="authEndpoint"
    detailedType="string | async ((room?: string) => CustomAuthenticationResult)"
  >
    The URL of your [authentication endpoint](/docs/authentication) as a string,
    or an async callback function that returns a Liveblocks token result. Either
    `authEndpoint` or `publicApikey` are required. Learn more about [using a URL
    string](#createClientAuthEndpoint) and [using a
    callback](#createClientCallback).
  </PropertiesListItem>
  <PropertiesListItem name="publicApiKey" type="string">
    The public API key taken from your project‚Äôs
    [dashboard](/dashboard/apikeys). Generally not recommended for production
    use. Either `authEndpoint` or `publicApikey` are required. [Learn
    more](#createClientPublicKey).
  </PropertiesListItem>
  <PropertiesListItem name="throttle" type="number" defaultValue="100">
    The throttle time between WebSocket messages in milliseconds, a number
    between `16` and `1000` is allowed. Using `16` means your app will update 60
    times per second. [Learn more](#createClientThrottle).
  </PropertiesListItem>
  <PropertiesListItem
    name="lostConnectionTimeout"
    type="number"
    defaultValue="5000"
  >
    After a user disconnects, the time in milliseconds before a
    [`"lost-connection"`](/docs/api-reference/liveblocks-client#Room.subscribe.lost-connection)
    event is fired. [Learn more](#createClientLostConnectionTimeout).
  </PropertiesListItem>
  <PropertiesListItem name="backgroundKeepAliveTimeout" type="number">
    The time before an inactive WebSocket connection is disconnected. This is
    disabled by default, but setting a number will activate it. [Learn
    more](#createClientBackgroundKeepAliveTimeout).
  </PropertiesListItem>
  <PropertiesListItem
    name="resolveUsers"
    detailedType='async? (args: ResolveUsersArgs) => (TUserMeta["info"] | undefined)[] | undefined'
  >
    A function that resolves user information in
    [Comments](/docs/products/comments). Return an array of `TUserMeta["info"]`
    objects in the same order they arrived. [Learn
    more](#createClientResolveUsers).
  </PropertiesListItem>
  <PropertiesListItem
    name="resolveRoomsInfo"
    detailedType="async? (args: ResolveRoomsInfoArgs) => (RoomInfo | undefined)[] | undefined"
  >
    A function that resolves room information in
    [Comments](/docs/products/comments). Return an array of `RoomInfo` objects
    in the same order they arrived. [Learn more](#createClientResolveRoomsInfo).
  </PropertiesListItem>
  <PropertiesListItem
    name="resolveMentionSuggestions"
    detailedType="async? (args: ResolveMentionSuggestionsArgs) => string[]"
  >
    A function that resolves mention suggestions in
    [Comments](/docs/products/comments). Return an array of user IDs. [Learn
    more](#createClientResolveMentionSuggestions).
  </PropertiesListItem>
  <PropertiesListItem name="polyfills" type="Polyfills">
    Place polyfills for `atob`, `fetch`, and `WebSocket` inside here. Useful
    when using a non-browser environment, such as [Node.js](#createClientNode)
    or [React Native](#createClientReactNative).
  </PropertiesListItem>
  <PropertiesListItem
    name="unstable_fallbackToHTTP"
    type="boolean"
    defaultValue="false"
  >
    Automatically fall back to HTTP when a message is too large for WebSockets.
  </PropertiesListItem>
  <PropertiesListItem
    name="unstable_streamData"
    type="boolean"
    defaultValue="false"
  >
    help???
  </PropertiesListItem>
</PropertiesList>

### createClient with public key [#createClientPublicKey]

When creating a client with a public key, you don‚Äôt need to set up an
authorization endpoint. We only recommend using a public key when prototyping,
or on public landing pages, as it makes it possible for end users to access any
room‚Äôs data. You should instead use an
[auth endpoint](#createClientAuthEndpoint).

```ts
import { createClient } from "@liveblocks/client";

const client = createClient({
  publicApiKey: "{{PUBLIC_KEY}}",
});
```

### createClient with auth endpoint [#createClientAuthEndpoint]

If you are not using a public key, you need to set up your own `authEndpoint`.
Please refer to our [Authentication guide](/docs/authentication).

```ts
import { createClient } from "@liveblocks/client";

const client = createClient({ authEndpoint: "/api/liveblocks-auth" });
```

### createClient with auth endpoint callback [#createClientCallback]

If you need to add additional headers or use your own function to call your
endpoint, `authEndpoint` can be provided as a custom callback. You should return
the token created with
[`Liveblocks.prepareSession`](/docs/api-reference/liveblocks-node#access-tokens)
or [`liveblocks.identifyUser`](/docs/api-reference/liveblocks-node#id-tokens),
learn more in [authentication guide](/docs/rooms/authentication).

```ts
import { createClient } from "@liveblocks/client";

const client = createClient({
  authEndpoint: async (room) => {
    // Fetch your authentication endpoint and retrieve your access or ID token
    // ...

    return '{ "token": "..." }';
  },
});
```

`room` is the room ID that the user is connecting to. When using
[Notifications](/docs/products/comments/notifications), `room` can be
`undefined`, as the client is requesting a token that grants access to multiple
rooms, rather than a specific room.

#### Fetch your endpoint

Here‚Äôs an example of fetching your API endpoint at `/api/liveblocks-auth` within
the callback.

```ts
import { createClient } from "@liveblocks/client";

const client = createClient({
  authEndpoint: async (room) => {
    const response = await fetch("/api/liveblocks-auth", {
      method: "POST",
      headers: {
        Authentication: "<your own headers here>",
        "Content-Type": "application/json",
      },
      // Don't forget to pass `room` down. Note that it
      // can be undefined when using Notifications.
      body: JSON.stringify({ room }),
    });
    return await response.json();
  },
});
```

#### Token details

You should return the token created with
[`Liveblocks.prepareSession`](/docs/api-reference/liveblocks-node#access-tokens)
or [`liveblocks.identifyUser`](/docs/api-reference/liveblocks-node#id-tokens).
These are the values the functions can return.

1. A valid token, it returns a `'{ "token": "..." }'` shaped response.
1. A token that explicitly forbids access, it returns an
   `'{ "error": "forbidden", "reason": "..." }'` shaped response. If this is
   returned, the client will disconnect and won't keep trying to authorize.

Any other error will be treated as an unexpected error, after which the client
will retry the request until it receives either 1. or 2.

### WebSocket throttle [#createClientThrottle]

By default, the client throttles the WebSocket messages sent to one every 100
milliseconds, which translates to 10 updates per second. It‚Äôs possible to
override that configuration with the `throttle` option with a value between `16`
and `1000` milliseconds.

```ts
import { createClient } from "@liveblocks/client";

const client = createClient({
  throttle: 16,

  // Other options
  // ...
});
```

This option is helpful for smoothing out real-time animations in your
application, as you can effectively increase the framerate without using any
interpolation. Here are some examples with their approximate frames per second
(FPS) values.

```ts
throttle:  16, // 60 FPS
throttle:  32, // 30 FPS
throttle: 200, //  5 FPS
```

### Lost connection timeout [#createClientLostConnectionTimeout]

If you‚Äôre connected to a room and briefly lose connection, Liveblocks will
reconnect automatically and quickly. However, if reconnecting takes longer than
usual, for example if your network is offline, then the room will emit an event
informing you about this.

How quickly this event is triggered can be configured with the
`lostConnectionTimeout` setting, and it takes a number in milliseconds.
`lostConnectionTimeout` can be set between `1000` and `30000` milliseconds. The
default is `5000`, or 5 seconds.

```ts
import { createClient } from "@liveblocks/client";

const client = createClient({
  lostConnectionTimeout: 5000,

  // Other options
  // ...
});
```

You can listen to the event with [`room.subscribe("lost-connection")`][]. Note
that this also affects when `others` are reset to an empty array after a
disconnection. This helps prevent temporary flashes in your application as a
user quickly disconnects and reconnects. For a demonstration of this behavior,
see our [connection status example][].

### Background keep-alive timeout [#createClientBackgroundKeepAliveTimeout]

By default, Liveblocks applications will maintain an active WebSocket connection
to the Liveblocks servers, even when running in a browser tab that‚Äôs in the
background. However, if you‚Äôd prefer for background tabs to disconnect after a
period of inactivity, then you can use `backgroundKeepAliveTimeout`.

When `backgroundKeepAliveTimeout` is specified, the client will automatically
disconnect applications that have been in an unfocused background tab for _at
least_ the specified time. When the browser tab is refocused, the client will
immediately reconnect to the room and synchronize the document.

```ts
import { createClient } from "@liveblocks/client";

const client = createClient({
  // Disconnect users after 15 minutes of inactivity
  backgroundKeepAliveTimeout: 15 * 60 * 1000,

  // Other options
  // ...
});
```

`backgroundKeepAliveTimeout` accepts a number in milliseconds‚Äîwe advise using a
value of at least a few minutes, to avoid unnecessary disconnections.

### resolveUsers [#createClientResolveUsers]

<Banner title="Public beta">

Comments is currently in beta. If you have any questions or feedback, please
join us on our [Discord server](https://liveblocks.io/discord). We‚Äôd love to
hear from you.

</Banner>

[Comments](/docs/products/comments) stores user IDs in its system, but no other
user information. To display user information in Comments components, such as a
user‚Äôs name or avatar, you need to resolve these IDs into user objects. This
function receives a list of user IDs and you should return a list of user
objects of the same size, in the same order.

```tsx
import { createClient } from "@liveblocks/client";

const client = createClient({
  resolveUsers: async ({ userIds }) => {
    const usersData = await __getUsersFromDB__(userIds);

    return usersData.map((userData) => ({
      name: userData.name,
      avatar: userData.avatar.src,
    }));
  },

  // Other options
  // ...
});
```

#### User objects

The user objects returned by the resolver function take the shape of
`UserMeta["info"]`, which contains `name` and `avatar` by default. These two
values are optional, though if you‚Äôre using the
[Comments default components](/docs/api-reference/liveblocks-react-comments#Components),
they are necessary. Here‚Äôs an example of `userIds` and the exact values
returned.

```ts
resolveUsers: async ({ userIds }) => {
  // ["marc@example.com", "nimesh@example.com"];
  console.log(userIds);

  return [
    { name: "Marc", avatar: "https://example.com/marc.png" },
    { name: "Nimesh", avatar: "https://example.com/nimesh.png" },
  ];
};
```

You can also return custom information, for example, a user‚Äôs `color`:

```ts highlight="9"
resolveUsers: async ({ userIds }) => {
  // ["marc@example.com"];
  console.log(userIds);

  return [
    {
      name: "Marc",
      avatar: "https://example.com/marc.png",
      color: "purple",
    },
  ];
};
```

#### Accessing user data in React

You can access any values set within `resolveUsers` with the
[`useUser`](/docs/api-reference/liveblocks-react#useUser) hook.

```tsx
import { useUser } from "../liveblocks.config";

function Component() {
  const user = useUser("marc@example.com");

  // { name: "Marc", avatar: "https://...", ... }
  console.log(user);
}
```

### resolveRoomsInfo [#createClientResolveRoomsInfo]

<Banner title="Public beta">

Comments is currently in beta. If you have any questions or feedback, please
join us on our [Discord server](https://liveblocks.io/discord). We‚Äôd love to
hear from you.

</Banner>

When using [Notifications](/docs/products/comments/notifications) with
[Comments](/docs/products/comments), room IDs will be used to contextualize
notifications (e.g. ‚ÄúChris mentioned you in room-id‚Äù). To replace room IDs with
more fitting names (e.g. document names, ‚ÄúChris mentioned you in Document A‚Äù),
you can provide a resolver function to the `resolveRoomsInfo` option in
[`createClient`](#createClient).

This resolver function will receive a list of room IDs and should return a list
of room info objects of the same size and in the same order.

```tsx
import { createClient } from "@liveblocks/client";

const client = createClient({
  resolveRoomsInfo: async ({ roomIds }) => {
    const documentsData = await __getDocumentsFromDB__(roomIds);

    return documentsData.map((documentData) => ({
      name: documentData.name,
      // url: documentData.url,
    }));
  },

  // Other options
  // ...
});
```

In addition to the room‚Äôs name, you can also provide a room‚Äôs URL as the `url`
property. If you do so, the
[`InboxNotification`](/docs/api-reference/liveblocks-react-comments#InboxNotification)
component will automatically use it. It‚Äôs possible to use an inbox
notification‚Äôs `roomId` property to construct a room‚Äôs URL directly in React and
set it on
[`InboxNotification`](/docs/api-reference/liveblocks-react-comments#InboxNotification)
via `href`, but the room ID might not be enough for you to construct the URL ,
you might need to call your backend for example. In that case, providing it via
`resolveRoomsInfo` is the preferred way.

### resolveMentionSuggestions [#createClientResolveMentionSuggestions]

<Banner title="Public beta">

Comments is currently in beta. If you have any questions or feedback, please
join us on our [Discord server](https://liveblocks.io/discord). We‚Äôd love to
hear from you.

</Banner>

To enable creating mentions in [Comments](/docs/products/comments), you can
provide a resolver function to the `resolveMentionSuggestions` option in
[`createClient`](#createClient).

This resolver function will receive the mention currently being written (e.g.
when writing ‚Äú@jane‚Äù, `text` will be `jane`) and should return a list of user
IDs matching that text. This function will be called every time the text changes
but with some debouncing.

```tsx
import { createClient } from "@liveblocks/client";

const client = createClient({
  resolveMentionSuggestions: async ({ text, roomId }) => {
    const workspaceUsers = await __getWorkspaceUsersFromDB__(roomId);

    if (!text) {
      // Show all workspace users by default
      return __getUserIds__(workspaceUsers);
    } else {
      const matchingUsers = __findUsers__(workspaceUsers, text);
      return __getUserIds__(matchingUsers);
    }
  },

  // Other options
  // ...
});
```

### createClient for Node.js [#createClientNode]

To use `@liveblocks/client` in Node.js, you need to provide [`WebSocket`][] and
[`fetch`][] polyfills. As polyfills, we recommend installing [`ws`][] and
[`node-fetch`][].

```bash
npm install ws node-fetch
```

Then, pass them to the `createClient` polyfill option as below.

```ts
import { createClient } from "@liveblocks/client";
import fetch from "node-fetch";
import WebSocket from "ws";

const client = createClient({
  polyfills: {
    fetch,
    WebSocket,
  },

  // Other options
  // ...
});
```

Note that `node-fetch` v3+
[does not support CommonJS](https://github.com/node-fetch/node-fetch/blob/main/docs/v3-UPGRADE-GUIDE.md#converted-to-es-module).
If you are using CommonJS, downgrade `node-fetch` to v2.

### createClient for React Native [#createClientReactNative]

To use `@liveblocks/client` with [React Native](https://reactnative.dev/), you
need to add an [`atob`][] polyfill. As a polyfill, we recommend installing
[`base-64`][].

```bash
npm install base-64
```

Then you can pass the `decode` function to our `atob` polyfill option when you
create the client.

```ts
import { createClient } from "@liveblocks/client";
import { decode } from "base-64";

const client = createClient({
  polyfills: {
    atob: decode,
  },

  // Other options
  // ...
});
```

## Client

Client returned by [`createClient`][] which allows you to connect to Liveblocks
servers in your application, and enter rooms.

### Client.enterRoom

Enters a room and returns both the local `Room` instance, and a `leave`
unsubscribe function. The authentication endpoint is called as soon as you call
this function. Used for setting [initial Presence](#setting-initial-presence)
and [initial Storage](#setting-initial-storage) values.

```ts
const { room, leave } = client.enterRoom("my-room-id", {
  initialPresence: {},

  // Other options
  // ...
});
```

Note that it‚Äôs possible to [add types to your room](#typing-your-room).

<PropertiesList title="Returns">
  <PropertiesListItem
    name="room"
    type="Room<TPresence, TStorage, TUserMeta, TRoomEvent>"
  >
    A [Room](#Room), used for building your Liveblocks application. Learn more
    about [typing your room](#typing-your-room).
  </PropertiesListItem>
  <PropertiesListItem name="leave" type="() => void">
    A function that‚Äôs used to destroy the room.
  </PropertiesListItem>
</PropertiesList>

<PropertiesList title="Arguments">
  <PropertiesListItem name="roomId" detailedType="string" required>
    The ID of the room you‚Äôre connecting to.
  </PropertiesListItem>
  <PropertiesListItem name="options.initialPresence" type="JsonObject" required>
    The initial Presence of the user entering the room. Each user has their own
    presence, and this is readable for all other connected users. A user‚Äôs
    Presence resets every time they disconnect. This object must be
    JSON-serializable. [Learn more](#setting-initial-presence).
  </PropertiesListItem>
  <PropertiesListItem name="options.initialStorage" type="LsonObject">
    The initial Storage structure for the room when it‚Äôs joined for the first
    time. This is only set on time. This object must contain [conflict-free live
    structures](/docs/api-reference/liveblocks-client#Storage) or be
    JSON-serializable. [Learn more](#setting-initial-storage).
  </PropertiesListItem>
  <PropertiesListItem
    name="options.autoConnect"
    type="boolean"
    defaultValue="true"
  >
    Whether the room immediately connects to Liveblocks servers.
  </PropertiesListItem>
</PropertiesList>

#### Setting initial Presence [#setting-initial-presence]

Presence is used for storing temporary user-based values, such as a user‚Äôs
cursor coordinates, or their current selection. Each user has their own
presence, and this is readable for all other connected users. Set your initial
Presence value by using `initialPresence`.

```ts highlight="2-8"
const { room, leave } = client.enterRoom("my-room-id", {
  initialPresence: {
    cursor: null,
    colors: ["red", "purple"],
    selection: {
      id: 72426,
    },
  },

  // Other options
  // ...
});
```

Each user‚Äôs Presence resets every time they disconnect, as this is only meant
for temporary data. Any JSON-serializable object is allowed (the `JsonObject`
type).

#### Setting initial Storage [#setting-initial-storage]

Storage is used to store permanent data that‚Äôs used in your application, such as
shapes on a whiteboard, nodes on a flowchart, or text in a form. The first time
a room is entered, you can set an initial value by using `initialStorage`. Note
that this value is only read a single time.

```ts highlight="4-9"
import { LiveList, LiveObject } from "@liveblocks/client";

const { room, leave } = client.enterRoom("my-room-id", {
  initialStorage: {
    title: "Untitled",
    shapes: new LiveList([
      new LiveObject({ type: "rectangle", color: "yellow" }),
    ]),
  },

  // Other options
  // ...
});
```

Any
[conflict-free live structures](/docs/api-reference/liveblocks-client#Storage)
and JSON-serializable objects are allowed (the `LsonObject` type).

### Client.enter [@badge=Deprecated]

Enters a room and returns its local `Room` instance.

<Banner title="Deprecated since 1.5" type="warning">

We no longer recommend this API, because issues will occur if you simultaneously
connect to the same room with multiple instances. We recommend using
[`client.enterRoom`][] instead.

</Banner>

```ts
// ‚ùå This API was recommended before 1.5
const room = client.enter("my-room", {
  initialPresence: { cursor: null },
  initialStorage: { todos: new LiveList() },
});
client.leave(roomId);

// ‚úÖ Prefer this instead
const { room, leave } = client.enterRoom("my-room", {
  initialPresence: { cursor: null },
  initialStorage: { todos: new LiveList() },
});
leave();
```

### Client.leave [@badge=Deprecated]

Leaves a room.

<Banner title="Deprecated since 1.5" type="warning">

We no longer recommend this API, because issues will occur if you simultaneously
connect to the same room with multiple instances. We recommend using
[`client.enterRoom`][] instead.

</Banner>

```ts
// ‚ùå This API was recommended before 1.5
client.leave("my-room");

// ‚úÖ Prefer this instead
const { room, leave } = client.enterRoom("my-room" /* options */);
leave();
```

### Client.getRoom

Gets a room by its ID. Returns `null` if [`client.enterRoom`][] has not been
called previously.

```ts
const room = client.getRoom("my-room");
```

It‚Äôs unlikely you‚Äôll need this API if you‚Äôre using the newer
[`client.enterRoom`][] API. Note that it‚Äôs possible to
[add types to your room](#typing-your-room).

<PropertiesList title="Returns">
  <PropertiesListItem
    name="room"
    type="Room<TPresence, TStorage, TUserMeta, TRoomEvent> | null"
  >
    A [Room](#Room), used for building your Liveblocks application. Returns
    `null` if the room has not yet been joined by the current client. Learn more
    about [typing your room](#typing-your-room).
  </PropertiesListItem>
</PropertiesList>

<PropertiesList title="Arguments">
  <PropertiesListItem name="roomId" detailedType="string" required>
    The ID of the room you‚Äôre connecting to.
  </PropertiesListItem>
</PropertiesList>

### Client.logout

Purges any auth tokens from the client‚Äôs memory. If there are any rooms that are
still connected, they will be forced to reauthorize.

```ts
client.logout();
```

Use this function if you have a single page application (SPA) and you wish to
log your user out, and reauthenticate them. This is a way to update your user‚Äôs
`info` after a connection has begun.

## Room

Room returned by [`client.enterRoom`][] (or [`client.getRoom`][]).

### Room.getPresence

Return the current user‚Äôs Presence. [Presence](/docs/products/presence) is used
to store custom properties on each user that exist until the user disconnects.
An example use would be storing a user‚Äôs cursor coordinates.

```ts
const presence = room.getPresence();

// { cursor: { x: 363, y: 723 } }
console.log(presence);
```

Presence is set with [`updatePresence`](#Room.updatePresence) and can be typed
when you [enter a room](#enter-room-typing-a-room). The example above is using
the following type:

```ts
type Presence = {
  cursor: { x: number; y: number };
};
```

<PropertiesList title="Returns">
  <PropertiesListItem name="presence" type="TPresence">
    An object holding the Presence value for the currently connected user.
    Presence is set with [`updatePresence`](#Room.updatePresence). Will always
    be JSON-serializable.
  </PropertiesListItem>
</PropertiesList>

### Room.updatePresence

Updates the current user‚Äôs [Presence](/docs/products/presence). Only pass the
properties you wish to update‚Äîany changes will be merged into the current
presence. The entire presence object will not be replaced.

```ts
room.updatePresence({ typing: true });
room.updatePresence({ status: "Online" });

// { typing: true, status: "Online" }
const presence = room.getPresence();
```

<PropertiesList title="Arguments">
  <PropertiesListItem name="update" type="TPresence" required>
    The updated Presence properties for the current user inside an object. The
    user‚Äôs entire Presence object will not be replaced, instead these properties
    will be merged with the existing Presence. This object must be
    JSON-serializable.
  </PropertiesListItem>
  <PropertiesListItem
    name="options.addToHistory"
    type="boolean"
    defaultValue="false"
  >
    Adds Presence values to the history stack, meaning using undo and redo
    functions will change them. [Learn more](#add-presence-to-history).
  </PropertiesListItem>
</PropertiesList>

#### Add Presence to history [#add-presence-to-history]

By default, Presence values are not added to history. However, using the
`addToHistory` option will add items to the undo/redo stack.

```ts
room.updatePresence({ color: "blue" }, { addToHistory: true });
room.updatePresence({ color: "red" }, { addToHistory: true });
room.history.undo();

// { color: "blue" }
const presence = room.getPresence();
```

See [`room.history`][] for more information.

### Room.getOthers

Returns an array of currently connected users in the room. Returns a
[`User`](#user-type) object for each user. Note that you can also subscribe to
others using [`Room.subscribe("others")`](#Room.subscribe.others).

```ts
const others = room.getOthers();

for (const other of others) {
  const { connectionId, id, info, presence, canWrite, canComment } = other;
  // Do things
}
```

<PropertiesList title="Returns">
  <PropertiesListItem name="others" type="User<TPresence, TUserMeta>[]">
    An array holding each connected user‚Äôs [`User`](#user-type) object. `User`
    contains the current user‚Äôs Presence value, along with other information.
    Presence is set with [`updatePresence`](#Room.updatePresence). Returns an
    empty array when no other users are currently connected. Will always be
    JSON-serializable.
  </PropertiesListItem>
</PropertiesList>

### Room.broadcastEvent

Broadcast an event to other users in the Room. Events broadcast to the room can
be listened to with [`Room.subscribe("event")`][]. Takes a custom event payload
as first argument. Should be serializable to JSON.

```ts
room.broadcastEvent({ type: "REACTION", emoji: "üî•" });
```

<PropertiesList title="Arguments">
  <PropertiesListItem name="event" type="TRoomEvent" required>
    The event to broadcast to every other user in the room. Must be
    JSON-serializable.
  </PropertiesListItem>
  <PropertiesListItem
    name="options.shouldQueueEventIfNotReady"
    type="boolean"
    defaultValue="false"
  >
    Queue the event if the connection is currently closed, or has not been
    opened yet. We‚Äôre not sure if we want to support this option in the future
    so it might be deprecated to be replaced by something else. [Learn
    more](#broadcasting-an-event-when-disconnected).
  </PropertiesListItem>
</PropertiesList>

#### Receiving an event

To receive an event, use [`Room.subscribe("event")`][]. The `user` property
received on the other end is the sender‚Äôs [`User`](#user-type) instance.

```ts
// User 1
room.broadcastEvent({ type: "REACTION", emoji: "üî•" });

// User 2
const unsubscribe = room.subscribe("event", ({ event, user, connectionId }) => {
  //                              ^^^^ User 1
  if (event.type === "REACTION") {
    // Do something
  }
});
```

We recommend using a property such as `type`, so that it‚Äôs easy to distinguish
between different events on the receiving end.

#### Typing multiple events [#typing-multiple-events]

When [defining your types](#typing-your-room), you can pass a `RoomEvent` type
to the fourth generic in [`client.enterRoom`][] to receive type hints in your
app. To define multiple different custom events, use a union.

```ts highlight="5-7,17-22"
type Presence = {};
type Storage = {};
type UserMeta = {};

type ReactionEvent = { type: "REACTION"; emoji: string };
type ActionEvent = { type: "ACTION"; action: string };
type RoomEvent = ReactionEvent | ActionEvent;

const { room, leave } = client.enterRoom<
  Presence,
  Storage,
  UserMeta,
  RoomEvent
>("my-room-id", { initialPresence: {} });

room.subscribe("event", ({ event, user, connectionId }) => {
  if (event.type === "REACTION") {
    // Do something
  }
  if (event.type === "ACTION") {
    // Do something else
  }
});
```

#### Broadcasting an event when disconnected [#broadcasting-an-event-when-disconnected]

By default, broadcasting an event is a ‚Äúfire and forget‚Äù action. If the sending
client is not currently connected to a room, the event is simply discarded. When
passing the `shouldQueueEventIfNotReady` option, the client will queue up the
event, and only send it once the connection to the room is (re)established.

<Banner>

We‚Äôre not sure if we want to support `shouldQueueEventIfNotReady` in the future,
so it may be deprecated and replaced with something else.

</Banner>

```ts highlight="4"
room.broadcastEvent(
  { type: "REACTION", emoji: "üî•" },
  {
    shouldQueueEventIfNotReady: true,
  }
);
```

### Room.getSelf

Gets the current [`User`](#user-type). Returns `null` if the client is not yet
connected to the room.

```ts
const { connectionId, presence, id, info, canWrite, canComment } =
  room.getSelf();
```

<PropertiesList title="Returns">
  <PropertiesListItem name="user" type="User<TPresence, TUserMeta> | null">
    Returns the current [`User`](#user-type). Returns `null` if the client is
    not yet connected to the room.
  </PropertiesListItem>
</PropertiesList>

Here‚Äôs an example of a full return value, assuming `Presence` and `UserMeta`
[have been set](#user-type).

```ts
const user = room.getSelf();

// {
//   connectionId: 52,
//   presence: {
//     cursor: { x: 263, y: 786 },
//   },
//   id: "mislav.abha@example.com",
//   info: {
//     avatar: "/mislav.png",
//   },
//   canWrite: true,
//   canComment: true,
// }
console.log(user);
```

### Room.getStatus

Gets the current WebSocket connection status of the room. The possible value
are: `initial`, `connecting`, `connected`, `reconnecting`, or `disconnected`.

```ts
const status = room.getStatus();

// "connected"
console.log(status);
```

<PropertiesList title="Returns">
  <PropertiesListItem
    name="status"
    type={`"initial" | "connecting" | "connected" | "reconnecting" | "disconnected"`}
  >
    Returns the current room status. It can return one of five values:

    - `"initial"` - The room has not attempted to connect yet.
    - `"connecting"` - The room is currently authenticating or connecting.
    - `"connected"` - The room is connected.
    - `"reconnecting"` - The room has disconnected, and is trying to connect again.
    - `"disconnected"` - The room is disconnected, and is no longer attempting to connect.

  </PropertiesListItem>
</PropertiesList>

### Room.subscribe(storageItem)

Subscribe to updates on a particular storage item, and takes a callback function
that‚Äôs called when the storage item is updated. The Storage `root` is a
[`LiveObject`][], which means you can subscribe to this, as well as other live
structures. Returns an unsubscribe function.

```ts
const { root } = await room.getStorage();

const unsubscribe = room.subscribe(root, (updatedRoot) => {
  // Do something
});
```

<PropertiesList title="Returns">
  <PropertiesListItem name="unsubscribe" type="() => void" required>
    Unsubscribe function. Call it to cancel the subscription.
  </PropertiesListItem>
</PropertiesList>

<PropertiesList title="Arguments">
  <PropertiesListItem
    name="storageItem"
    type="L extends (LiveObject | LiveMap | LiveList)"
  >
    The `LiveObject`, `LiveMap`, or `LiveList` which is being subscribed to.
    Each time the structure is updated, the callback is called.
  </PropertiesListItem>
  <PropertiesListItem name="callback" type="(node: L) => void" required>
    Function that‚Äôs called when `storageItem` updates. Returns the updated
    storage structure.
  </PropertiesListItem>
  <PropertiesListItem name="options.isDeep" type="boolean">
    Subscribe to both `storageItem` and its children. The callback function will
    be passed a list of updates instead of just the new Storage item. [Learn
    more](#listening-for-nested-changes).
  </PropertiesListItem>
</PropertiesList>

#### Typing Storage

To type the Storage values you receive, make sure to set your `Storage` type.

```ts
import { LiveList } from "@liveblocks/client";

type Storage = {
  animals: LiveList<{ name: string }>;
};
```

The type received in the callback will match the type passed. Learn more under
[typing your room](#typing-your-room).

```ts
const { root } = await room.getStorage();
const animals = root.get("animals");

const unsubscribe = room.subscribe(animals, (updatedAnimals) => {
  // LiveList<[{ name: "Fido" }, { name: "Felix" }]>
  console.log(updatedAnimals);
});
```

#### Subscribe to any live structure

You can subscribe to any live structure, be it the Storage `root`, a child, or a
structure even more deeply nested.

```ts
import { LiveObject, LiveMap } from "@liveblocks/client";

type Person = LiveObject<{ name: string; age: number }>;

type Storage = {
  people: LiveMap<string, Person>;
};
```

```ts
const { root } = await room.getStorage();
const people = root.get("people");
const steven = people.get("steven");

const unsubscribeRoot = room.subscribe(root, (updatedRoot) => {
  // ...
});

const unsubscribePeople = room.subscribe(people, (updatedPeople) => {
  // ...
});

const unsubscribeSteven = room.subscribe(steven, (updatedSteven) => {
  // ...
});
```

#### Listening for nested changes [#listening-for-nested-changes]

It‚Äôs also possible to subscribe to a Storage item and all of its children by
passing an optional `isDeep` option in the third argument. In this case, the
callback will be passed a list of updates instead of just the new Storage item.
Each such update is a `{ type, node, updates }` object.

```ts
const { root } = await room.getStorage();

const unsubscribe = room.subscribe(
  root,
  (storageUpdates) => {
    for (const update of storageUpdates) {
      const {
        type, // "LiveObject", "LiveList", or "LiveMap"
        node,
        updates,
      } = update;
      switch (type) {
        case "LiveObject": {
          // updates["property"]?.type; is "update" or "delete"
          // update.node is the LiveObject that has been updated/deleted
          break;
        }
        case "LiveMap": {
          // updates["key"]?.type; is "update" or "delete"
          // update.node is the LiveMap that has been updated/deleted
          break;
        }
        case "LiveList": {
          // updates[0]?.type; is "delete", "insert", "move", or "set"
          // update.node is the LiveList that has been updated, deleted, or modified
          break;
        }
      }
    }
  },
  { isDeep: true }
);
```

### Room.subscribe("event") [#Room.subscribe.event]

Subscribe to events broadcast by [`Room.broadcastEvent`][]. Takes a callback
that‚Äôs run when another user calls [`Room.broadcastEvent`][]. Provides the
`event` along with the `user` and their `connectionId` of the user that sent the
message. Returns an unsubscribe function.

```ts highlight="4-10"
// User 1
room.broadcastEvent({ type: "REACTION", emoji: "üî•" });

// User 2
const unsubscribe = room.subscribe("event", ({ event, user, connectionId }) => {
  //                                                  ^^^^ Will be User 1
  if (event.type === "REACTION") {
    // Do something
  }
});
```

<PropertiesList title="Returns">
  <PropertiesListItem name="unsubscribe" type="() => void" required>
    Unsubscribe function. Call it to cancel the subscription.
  </PropertiesListItem>
</PropertiesList>

<PropertiesList title="Arguments">
  <PropertiesListItem name="event" type={`"event"`}>
    Listen to events.
  </PropertiesListItem>
  <PropertiesListItem
    name="callback"
    detailedType="RoomEventMessage<TPresence, TUserMeta, TRoomEvent>"
    required
  >
    Function that‚Äôs called when another user sends an event. Receives the event,
    the [`user`](#user-type) that sent the event, and their `connectionId`. If
    this event was sent via
    [`liveblocks.broadcastEvent`](/docs/api-reference/liveblocks-node#post-broadcast-event)
    or the [Broadcast to a
    room](/docs/api-reference/rest-api-endpoints#post-broadcast-event) REST API,
    `user` will be `null` and `connectionId` will be `-1`.
  </PropertiesListItem>
</PropertiesList>

#### Typing events

When [defining your types](#typing-your-room), you can pass a `RoomEvent` type
to the fourth generic in [`client.enterRoom`][] to receive type hints in your
app. To define multiple different custom events, use a union.

```ts highlight="5-7,17-22"
type Presence = {};
type Storage = {};
type UserMeta = {};

type ReactionEvent = { type: "REACTION"; emoji: string };
type ActionEvent = { type: "ACTION"; action: string };
type RoomEvent = ReactionEvent | ActionEvent;

const { room, leave } = client.enterRoom<
  Presence,
  Storage,
  UserMeta,
  RoomEvent
>("my-room-id", { initialPresence: {} });

room.subscribe("event", ({ event, user, connectionId }) => {
  if (event.type === "REACTION") {
    // Do something
  }
  if (event.type === "ACTION") {
    // Do something else
  }
});
```

#### Receiving events from the server

Events can be received from the server with either
[`liveblocks.broadcastEvent`](/docs/api-reference/liveblocks-node#post-broadcast-event)
or the
[Broadcast Event API](/docs/api-reference/rest-api-endpoints#post-broadcast-event).
In events sent from the server, `user` will be `null`, and `connectionId` will
be `-1`.

```ts
import { Liveblocks } from "@liveblocks/node";

const liveblocks = new Liveblocks({
  secret: "{{SECRET_KEY}}",
});

export async function POST() {
  await liveblocks.broadcastEvent({ type: "REACTION", emoji: "üî•" });
}
```

```ts
const unsubscribe = room.subscribe("event", ({ event, user, connectionId }) => {
  // `null`, `-1`
  console.log(user, connectionId);
});
```

### Room.subscribe("my-presence") [#Room.subscribe.my-presence]

Subscribe to the current user presence updates.

Takes a callback that is called every time the current user presence is updated
with [`Room.updatePresence`][].

Returns an unsubscribe function.

```ts
const unsubscribe = room.subscribe("my-presence", (presence) => {
  // Do something
});
```

### Room.subscribe("others") [#Room.subscribe.others]

Subscribe to the other users updates.

Takes a callback that is called when a user enters or leaves the room or when a
user update its presence.

Returns an unsubscribe function.

```ts
const unsubscribe = room.subscribe("others", (others, event) => {
  // Do something

  if (event.type === "leave") {
    // A user has left the room
    // event.user;
  }

  if (event.type === "enter") {
    // A user has entered the room
    // event.user;
  }

  if (event.type === "update") {
    // A user has updated
    // event.user;
    // event.updates;
  }

  if (event.type === "reset") {
    // A disconnection has occurred and others has reset
  }
});
```

#### Live cursors

Here‚Äôs a basic example showing you how to render live cursors.
[`Room.updatePresence`](/docs/api-reference/liveblocks-client#Room.updatePresence)
is being used to update each user‚Äôs cursor position.

```ts highlight="15-18,20,22-28"
type Presence = {
  cursor: { x: number; y: number };
};
type Storage = {};
type UserMeta = { id: string };
type RoomEvent = {};

const { room, leave } = client.enterRoom<
  Presence,
  Storage,
  UserMeta,
  RoomEvent
>("my-room-id", { initialPresence: {} });

// Call this to update the current user's Presence
function updateCursorPosition({ x, y }) {
  room.updatePresence({ cursor: { x, y } });
}

const others = room.getOthers();

// Run __renderCursor__ when any other connected user updates their presence
const unsubscribe = room.subscribe("others", (others, event) => {
  for (const { id, presence } of others) {
    const { x, y } = presence.cursor;
    __renderCursor__(id, { x, y });
  }
}

// Handle events and rendering
// ...
```

Check our [examples page](/examples/browse/cursors) for live demos.

### Room.subscribe("status") [#Room.subscribe.status]

Subscribe to WebSocket connection status updates.

Takes a callback that is called whenever the connection status changes. Possible
value are: `initial`, `connecting`, `connected`, `reconnecting`, or
`disconnected`.

Returns an unsubscribe function.

```ts
const unsubscribe = room.subscribe("status", (status) => {
  // Do something
});
```

This is a low-level API that exposes the WebSocket‚Äôs connectivity status. You
can use this, for example, to update a connection status indicator in your UI.
It would be normal for a client to briefly lose the connection and restore it,
using quick `connected` ‚Üí `reconnecting` ‚Üí `connected` status jumps.

If you want to let users know that there may be connectivity issues, don‚Äôt use
this API, but instead refer to [`Room.subscribe("lost-connection")`][].

<Banner title="Notice">

Do not use this API to detect when Storage or Presence are initialized or
loaded. "Connected" does not guarantee that Storage or Presence are ready. To
detect when Storage is loaded, rely on awaiting the [`Room.getStorage`][]
promise or using the [`Room.subscribe("storage-status")`][] event.

</Banner>

### Room.subscribe("lost-connection") [#Room.subscribe.lost-connection]

A special-purpose event that will fire in the exceptional case where a
previously connected Liveblocks client has lost its connection (e.g. due to a
network outage) and was unable to recover quickly.

This event allows you to build high-quality UIs by warning your users that the
app is still trying to re-establish the connection, for example through a toast
notification. You may want to take extra care in the mean time to ensure their
changes won‚Äôt go unsaved, or to help them understand why they‚Äôre not seeing
updates made by others yet.

When this happens, this callback is called with the event `lost`. Then, once the
connection restores, the callback will be called with the value `restored`. If
the connection could definitively not be restored, it will be called with
`failed` (uncommon).

The [`lostConnectionTimeout`][] configuration option will determine how quickly
this event will fire after a connection loss (default: 5 seconds).

```ts
import { toast } from "my-preferred-toast-library";

const unsubscribe = room.subscribe("lost-connection", (event) => {
  switch (event) {
    case "lost":
      toast.warn("Still trying to reconnect...");
      break;

    case "restored":
      toast.success("Successfully reconnected again!");
      break;

    case "failed":
      toast.error("Could not restore the connection");
      break;
  }
});
```

### Room.subscribe("connection") [#Room.subscribe.connection]

<Banner title="Deprecated since 1.1" type="warning">

Support for this subscription overload will be removed in a future version. We
recommend switching to [`Room.subscribe("status")`][] instead.

</Banner>

Subscribe to our legacy WebSocket connection status updates.

Takes a callback that is called when the connection status changes.

Returns an unsubscribe function.

```ts
const unsubscribe = room.subscribe("connection", (status) => {
  // Do something
});
```

### Room.subscribe("error") [#Room.subscribe.error]

Subscribe to unrecoverable room connection errors. This event will be emitted
right before the client disconnects and won‚Äôt try reconnecting again.

Returns an unsubscribe function.

```ts
const unsubscribe = room.subscribe("error", (error) => {
  switch (error.code) {
    case -1:
      // Authentication error
      break;

    case 4001:
      // Could not connect because you don't have access to this room
      break;

    case 4005:
      // Could not connect because room was full
      break;

    case 4006:
      // The room ID has changed, get the new room ID (use this for redirecting)
      const newRoomId = error.message;
      break;

    default:
      // Unexpected error
      break;
  }
});
```

You can use this event to trigger a ‚ÄúNot allowed‚Äù screen/dialog. If you‚Äôd like
to retry connecting, call `room.reconnect()`.

### Room.subscribe("history") [#Room.subscribe.history]

Subscribe to the current user‚Äôs history changes.

Returns an unsubscribe function.

```ts
const unsubscribe = room.subscribe("history", ({ canUndo, canRedo }) => {
  // Do something
});
```

### Room.subscribe("storage-status") [#Room.subscribe.storage-status]

Subscribe to storage status changes.

Returns an unsubscribe function.

```typescript
const unsubscribe = room.subscribe("storage-status", (status) => {
  switch (status) {
    case "not-loaded":
      break;
    case "loading":
      break;
    case "synchronizing":
      break;
    case "synchronized":
      break;
    default:
      break;
  }
});
```

### Room.batch

Batches Storage and Presence modifications made during the given function. Each
modification is grouped together, which means that other clients receive the
changes as a single message after the batch function has run. Every modification
made during the batch is merged into a single history item (undo/redo).

```ts
const { root } = await room.getStorage();
room.batch(() => {
  root.set("x", 0);
  room.updatePresence({ cursor: { x: 100, y: 100 } });
});
```

Note that `room.batch` cannot take an `async` function.

```tsx
// ‚ùå Won't work
room.batch(async () => /* ... */);

// ‚úÖ Will work
room.batch(() => /*... */);
```

### Room.history

Room‚Äôs history contains functions that let you undo and redo operation made on
by the current client on the presence and storage.

```ts
const { undo, redo, pause, resume } = room.history;
```

### Room.history.undo

Undoes the last operation executed by the current client. It does not impact
operations made by other clients.

```ts
room.updatePresence({ selectedId: "xxx" }, { addToHistory: true });
room.updatePresence({ selectedId: "yyy" }, { addToHistory: true });
room.history.undo();
// room.getPresence() equals { selectedId: "xxx" }
```

### Room.history.redo

Redoes the last operation executed by the current client. It does not impact
operations made by other clients.

```ts
room.updatePresence({ selectedId: "xxx" }, { addToHistory: true });
room.updatePresence({ selectedId: "yyy" }, { addToHistory: true });
room.history.undo();
// room.getPresence() equals { selectedId: "xxx" }
room.history.redo();
// room.getPresence() equals { selectedId: "yyy" }
```

### Room.history.canUndo

Returns whether there are any operations to undo.

```ts
room.updatePresence({ selectedId: "xx" }, { addToHistory: true });
// room.history.canUndo() is true
room.history.undo();
// room.history.canUndo() is false
```

### Room.history.canRedo

Returns whether there are any operations to redo.

```ts
room.updatePresence({ selectedId: "xx" }, { addToHistory: true });
room.history.undo();
// room.history.canRedo() is true
room.history.redo();
// room.history.canRedo() is false
```

### Room.history.clear

Clears the undo and redo stacks for the current client. Explicitly clearing
history resets the ability to undo beyond the current document state. Other
clients‚Äô histories are unaffected.

```ts
room.updatePresence({ selectedId: "xx" }, { addToHistory: true });
// room.history.canUndo() is true
room.history.clear();
// room.history.canUndo() is false
```

### Room.history.pause

All future modifications made on the Room will be merged together to create a
single history item until resume is called.

```ts
room.updatePresence({ cursor: { x: 0, y: 0 } }, { addToHistory: true });
room.history.pause();
room.updatePresence({ cursor: { x: 1, y: 1 } }, { addToHistory: true });
room.updatePresence({ cursor: { x: 2, y: 2 } }, { addToHistory: true });
room.history.resume();
room.history.undo();
// room.getPresence() equals { cursor: { x: 0, y: 0 } }
```

### Room.history.resume

Resumes history. Modifications made on the Room are not merged into a single
history item anymore.

```ts
room.updatePresence({ cursor: { x: 0, y: 0 } }, { addToHistory: true });
room.history.pause();
room.updatePresence({ cursor: { x: 1, y: 1 } }, { addToHistory: true });
room.updatePresence({ cursor: { x: 2, y: 2 } }, { addToHistory: true });
room.history.resume();
room.history.undo();
// room.getPresence() equals { cursor: { x: 0, y: 0 } }
```

### Room.getStorageStatus

Get the storage status.

- `not-loaded`: Initial state when entering the room.
- `loading`: Once the storage has been requested via room.getStorage().
- `synchronizing`: When some local updates have not been acknowledged by
  Liveblocks servers.
- `synchronized`: Storage is in sync with Liveblocks servers.

```ts
const status = room.getStorageStatus();
```

### Room.connect

Connect the local room instance to the Liveblocks server. Does nothing if the
room is already connecting, reconnecting or connected.

```ts
room.connect();
```

We don‚Äôt recommend using this API directly.

### Room.reconnect

Reconnect the local room instance to the Liveblocks server, using a new
WebSocket connection.

```ts
room.reconnect();
```

### Room.disconnect

Disconnect the local room instance from the Liveblocks server. The room instance
will remain functional (for example, it will still allow local presence or
storage mutations), but since it‚Äôs no longer connected, changes will not be
persisted or synchronized until the room instance is reconnected again.

```ts
room.disconnect();
```

We don‚Äôt recommend using this API directly.

## Storage

<Banner title="Need help troubleshooting storage?">

Try the [Liveblocks DevTools extension](/devtools) to visualize your
collaborative experiences as you build them, in real-time.

</Banner>

The room‚Äôs storage is a conflicts-free state that multiple users can edit at the
same time. It persists even after everyone leaves the room. Liveblocks provides
3 data structures that can be nested to create the state that you want.

- [`LiveObject`][] - Similar to JavaScript object. Use this for storing records
  with fixed key names and where the values don‚Äôt necessarily have the same
  types. For example, a `Person` with a `name` (string) and an `age` (number)
  field.

  If multiple clients update the same property simultaneously, the last
  modification received by the Liveblocks servers is the winner.

- [`LiveList`][] - An ordered collection of items synchronized across clients.
  Even if multiple users add/remove/move elements simultaneously, LiveList will
  solve the conflicts to ensure everyone sees the same collection of items.

- [`LiveMap`][] - Similar to a JavaScript Map. Use this for indexing values that
  all have the same structure. For example, to store an index of `Person` values
  by their name. If multiple users update the same property simultaneously, the
  last modification received by the Liveblocks servers is the winner.

### Room.getStorage

Get the room‚Äôs storage asynchronously (returns a Promise). The promise will
resolve once the storage‚Äôs root is loaded and available.

The storage‚Äôs root will always be a [`LiveObject`][].

```ts
const { root } = await room.getStorage();
```

## LiveObject

The `LiveObject` class is similar to a JavaScript object that is synchronized on
all clients. Use this for storing records with fixed key names and where the
values don‚Äôt necessarily have the same types. For example, a Person with a
`name` (string) and an `age` (number) field.

Keys should be strings, and values should be serializable to JSON.

If multiple clients update the same property simultaneously, the last
modification received by the Liveblocks servers is the winner.

### new LiveObject [#LiveObject.constructor]

Create an empty `LiveObject`

```ts
const object = new LiveObject();
```

Create a `LiveObject` with initial data.

```ts
const object = new LiveObject({ firstName: "Margaret", lastName: "Hamilton" });
```

### delete [#LiveObject.delete]

Delete a property from the `LiveObject`

```ts
const object = new LiveObject({ firstName: "Ada", lastName: "Lovelace" });
object.delete("lastName");
object.toObject(); // equals to { firstName: "Ada" }
```

### get [#LiveObject.get]

Get a property from the `LiveObject`

```ts
const object = new LiveObject({ firstName: "Ada", lastName: "Lovelace" });
object.get("firstName"); // equals to "Ada"
```

### set [#LiveObject.set]

Adds or updates a property with the specified key and a value.

```ts
const object = new LiveObject({ firstName: "Marie" });
object.set("lastName", "Curie");
```

### update [#LiveObject.update]

Adds or updates multiple properties at once.

```ts
const object = new LiveObject({ firstName: "Grace", lastName: "Hopper" });
object.update({ job: "Computer Scientist", birthDate: "December 9, 1906" });
```

### toObject [#LiveObject.toObject]

<Banner title="Will be deprecated in the future">

Starting with 0.18, we recommend [`toImmutable`][] instead. It‚Äôs faster, cached,
and leads to fewer surprises.

</Banner>

Transform the `LiveObject` into a normal JavaScript object.

```ts
const liveObject = new LiveObject({ firstName: "Grace", lastName: "Hopper" });
liveObject.toObject();
// { firstName: "Grace", lastName: "Hopper" }
```

Please note that this method won‚Äôt recursively convert Live structures, which
may be surprising:

```ts
const liveObject = new LiveObject({
  animals: new LiveList(["ü¶Å", "ü¶ä", "üêµ"]),
});
liveObject.toObject();
// { animals: <LiveList instance> } // ‚ùóÔ∏è
```

### toImmutable [#LiveObject.toImmutable]

Returns an immutable JavaScript object that is equivalent to the `LiveObject`.
Nested values will also be immutable.

```ts
const liveObject = new LiveObject({
  firstName: "Grace",
  lastName: "Hopper",
  hobbies: new LiveList(["needlepoint", "reading", "playing piano"]),
});
liveObject.toImmutable();
// {
//   firstName: "Grace",
//   lastName: "Hopper",
//   hobbies: ["needlepoint", "reading", "playing piano"]
// }
```

### clone [#LiveObject.clone]

Returns a deep copy of the `LiveObject` that can be inserted elsewhere in the
Storage tree.

```ts
const obj = new LiveObject(/* ... */);
root.set("a", obj);
root.set("b", obj.clone());
```

## LiveMap

The `LiveMap` class is similar to a
[JavaScript Map](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Map)
that is synchronized on all clients.

Use this for indexing values that all have the same structure. For example, to
store an index of `Person` values by their name. Keys should be strings, and
values should be serializable to JSON. If multiple clients update the same
property simultaneously, the last modification received by the Liveblocks
servers is the winner.

### new LiveMap [#LiveMap.constructor]

Create an empty `LiveMap`.

```ts
const map = new LiveMap();
```

Create a `LiveMap` with initial data.

```ts
const map = new LiveMap([
  ["keyA", "valueA"],
  ["keyB", "valueB"],
]);
```

### delete [#LiveMap.delete]

Removes the specified element by key. Returns true if an element existed and has
been removed, or false if the element does not exist.

```ts
const map = new LiveMap([
  ["keyA", "valueA"],
  ["keyB", "valueB"],
]);
map.delete("keyA"); // equals true
map.get("keyA"); // equals undefined
map.delete("unknownKey"); // equals false
```

### entries [#LiveMap.entries]

Returns a new
[Iterator](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Guide/Iterators_and_Generators)
object that contains the `[key, value]` pairs for each element.

```ts
for (const [key, value] of map.entries()) {
  // Iterate over all the keys and values of the map
}
```

<Banner title="Iteration with TypeScript">

If your TypeScript project targets <code>es5</code> or lower, you‚Äôll need to
enable the <code>--downlevelIteration</code> option to use this API.

</Banner>

### forEach [#LiveMap.forEach]

Executes a provided function once per each key/value pair in the Map object.

```ts
const map = new LiveMap([
  ["keyA", "valueA"],
  ["keyB", "valueB"],
]);
map.forEach((value, key) => console.log(value));
// prints to the console "valueA", "valueB"
```

### get [#LiveMap.get]

Returns a specified element from the LiveMap or undefined if the key can‚Äôt be
found.

```ts
const map = new LiveMap([
  ["keyA", "valueA"],
  ["keyB", "valueB"],
]);
map.get("keyA"); // equals "valueA"
map.get("unknownKey"); // equals undefined
```

### has [#LiveMap.has]

Returns a boolean indicating whether an element with the specified key exists or
not.

```ts
const map = new LiveMap([
  ["keyA", "valueA"],
  ["keyB", "valueB"],
]);
map.has("keyA"); // equals true
map.has("unknownKey"); // equals false
```

### keys [#LiveMap.keys]

Returns a new
[Iterator](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Guide/Iterators_and_Generators)
object that contains the keys for each element.

```ts
for (const key of map.keys()) {
  // Iterate over all the keys and values of the map
}
```

<Banner title="Iteration with TypeScript">

If your TypeScript project targets <code>es5</code> or lower, you‚Äôll need to
enable the <code>--downlevelIteration</code> option to use this API.

</Banner>

### set [#LiveMap.set]

Adds or updates an element with a specified key and a value.

```ts
const map = new LiveMap();
map.set("keyA", "valueA");
```

### size [#LiveMap.size]

Returns the number of elements in the `LiveMap`.

```ts
const map = new LiveMap([
  ["keyA", "valueA"],
  ["keyB", "valueB"],
]);
map.size; // equals 2
```

### values [#LiveMap.values]

Returns a new
[Iterator](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Guide/Iterators_and_Generators)
object that contains the the values for each element.

```ts
for (const value of map.values()) {
  // Iterate over all the values of the map
}
```

<Banner title="Iteration with TypeScript">

If your TypeScript project targets <code>es5</code> or lower, you‚Äôll need to
enable the <code>--downlevelIteration</code> option to use this API.

</Banner>

### toImmutable [#LiveMap.toImmutable]

Returns an immutable ES6 Map that is equivalent to the `LiveMap`. Nested values
will also be immutable.

```ts
const map = new LiveMap([
  ["abc", new LiveObject({ firstName: "Grace", lastName: "Hopper" })],
  ["pqr", new LiveObject({ firstName: "Ada", lastName: "Lovelace" })],
]);
map.toImmutable();
// equal to:
// Map(2) {
//   'abc' => { firstName: 'Grace', lastName: 'Hopper' },
//   'pqr' => { firstName: 'Ada', lastName: 'Lovelace' }
// }
```

### clone [#LiveMap.clone]

Returns a deep copy of the `LiveMap` that can be inserted elsewhere in the
Storage tree.

```ts
const map = new LiveMap(/* ... */);
root.set("a", map);
root.set("b", map.clone());
```

## LiveList

The `LiveList` class represents an ordered collection of items that is
synchorinized across clients. Items should be serializable to JSON or another
Live data type.

### new LiveList [#LiveList.constructor]

Create an empty `LiveList`.

```ts
const list = new LiveList();
```

Create a `LiveList` with initial data.

```ts
const list = new LiveList(["ü¶Å", "ü¶ä", "üêµ"]);
```

### clear [#LiveList.clear]

Removes all the elements.

```ts
const list = new LiveList(["ü¶Å", "ü¶ä", "üêµ"]);
list.clear();
list.toArray(); // equals []
```

### delete [#LiveList.delete]

Deletes an element at the specified index.

```ts
const list = new LiveList(["ü¶Å", "ü¶ä", "üêµ"]);
list.delete(1);
list.toArray(); // equals ["ü¶Å", "üêµ"]
```

### every [#LiveList.every]

Tests whether all elements pass the test implemented by the provided function.
Returns true if the predicate function returns a truthy value for every element.
Otherwise, false.

```ts
const list = new LiveList([0, 2, 4]);
list.every((i) => i % 2 === 0); // equals true
list.push(5);
list.every((i) => i % 2 === 0); // equals false
```

### filter [#LiveList.filter]

Creates an array with all elements that pass the test implemented by the
provided function.

```ts
const list = new LiveList([0, 1, 2, 3, 4]);
list.filter((i) => i % 2 === 0); // equals [0, 2, 4]
```

### find [#LiveList.find]

Returns the first element that satisfies the provided testing function.

```ts
const list = new LiveList(["apple", "lemon", "tomato"]);
list.find((fruit) => fruit.startsWith("l")); // equals "lemon"
```

### findIndex [#LiveList.findIndex]

Returns the index of the first element in the `LiveList` that satisfies the
provided testing function.

```ts
const list = new LiveList(["apple", "lemon", "tomato"]);
list.findIndex((fruit) => fruit.startsWith("l")); // equals 1
```

### forEach [#LiveList.forEach]

Executes a provided function once for each element.

```ts
const list = new LiveList(["ü¶Å", "ü¶ä", "üêµ"]);
list.forEach((item) => console.log(item)); // prints to the console "ü¶Å", "ü¶ä", "üêµ"
```

### get [#LiveList.get]

Get the element at the specified index.

```ts
const list = new LiveList(["ü¶Å", "ü¶ä", "üêµ"]);
list.get(2); // equals "üêµ"
```

### indexOf [#LiveList.indexOf]

Returns the first index at which a given element can be found in the `LiveList`,
or -1 if it is not present.

```ts
const list = new LiveList(["ü¶Å", "ü¶ä", "üêµ"]);
list.indexOf("üêµ"); // equals 2
list.indexOf("üê∫"); // equals -1
```

### insert [#LiveList.insert]

Inserts one element at a specified index.

```ts
const list = new LiveList(["ü¶Å", "ü¶ä", "üêµ"]);
list.insert("üê∫", 1);
list.toArray(); // equals ["ü¶Å", "üê∫", "ü¶ä", "üêµ"]
```

### lastIndexOf [#LiveList.lastIndexOf]

Returns the last index at which a given element can be found in the `LiveList`,
or -1 if it is not present. The `LiveList` is searched backwards, starting at
fromIndex.

```ts
const list = new LiveList(["ü¶Å", "ü¶ä", "üêµ", "ü¶ä"]);
list.lastIndexOf("ü¶ä"); // equals 3
list.lastIndexOf("üê∫"); // equals -1
```

### length [#LiveList.length]

Returns the number of elements.

```ts
const list = new LiveList(["ü¶Å", "ü¶ä", "üêµ"]);
list.length; // equals 3
```

### map [#LiveList.map]

Creates an array populated with the results of calling a provided function on
every element.

```ts
const list = new LiveList(["apple", "lemon", "tomato"]);
list.map((fruit) => fruit.toUpperCase()); // equals ["APPLE", "LEMON", "TOMATO"]
```

### move [#LiveList.move]

Moves one element at a specified index.

```ts
const list = new LiveList(["ü¶Å", "ü¶ä", "üêµ"]);
list.move(2, 0); // move the "üêµ" at index 0
list.toArray(); // equals ["üêµ", "ü¶Å", "ü¶ä"]
```

### push [#LiveList.push]

Adds one element to the end of the `LiveList`.

```ts
const list = new LiveList(["ü¶Å", "ü¶ä", "üêµ"]);
list.push("üê∫");
list.toArray(); // equals ["ü¶Å", "ü¶ä", "üêµ", "üê∫"]
```

### set [#LiveList.set]

Replace one element at the specified index.

```ts
const list = new LiveList(["ü¶Å", "ü¶ä", "üêµ"]);
list.set(1, "üê∫");
list.toArray(); // equals ["ü¶Å", "üê∫", "üêµ"]
```

### some [#LiveList.some]

Tests whether at least one element in the `LiveList` passes the test implemented
by the provided function.

```ts
const list = new LiveList(["apple", "lemon", "tomato"]);
list.some((fruit) => fruit.startsWith("l")); // equals true
list.some((fruit) => fruit.startsWith("x")); // equals false
```

### toArray [#LiveList.toArray]

<Banner title="Will be deprecated in the future">

Starting with 0.18, we recommend [`toImmutable`][] instead. It‚Äôs faster, cached,
and leads to fewer surprises.

</Banner>

Transforms the `LiveList` into a normal JavaScript array.

```ts
const list = new LiveList(["ü¶Å", "ü¶ä", "üêµ"]);
list.toArray();
// ["ü¶Å", "ü¶ä", "üêµ"]
```

Please note that this method won‚Äôt recursively convert Live structures, which
may be surprising:

```ts
const list = new LiveList([
  new LiveObject({ firstName: "Grace", lastName: "Hopper" }),
]);
list.toArray();
// [ <LiveObject instance> ]  // ‚ùóÔ∏è
```

### toImmutable [#LiveList.toImmutable]

Returns an immutable JavaScript array that is equivalent to the `LiveList`.
Nested values will also be immutable.

```ts
const list = new LiveList([
  new LiveObject({ firstName: "Grace", lastName: "Hopper" }),
]);
list.toImmutable();
// [ { firstName: "Grace", lastName: "Hopper" } ]
```

### clone [#LiveList.clone]

Returns a deep copy of the `LiveList` that can be inserted elsewhere in the
Storage tree.

```ts
const list = new LiveList(/* ... */);
root.set("a", list);
root.set("b", list.clone());
```

## Utilities

### getMentionedIdsFromCommentBody [#get-mentioned-ids-from-comment-body]

Returns an array of each user‚Äôs ID that has been mentioned in a `CommentBody`
(found under `comment.body`).

```ts
import { getMentionedIdsFromCommentBody } from "@liveblocks/client";

const mentionedIds = getMentionedIdsFromCommentBody(comment.body);
```

Here‚Äôs an example with a custom `CommentBody`.

```ts
import {
  CommentBody,
  getMentionedIdsFromCommentBody,
} from "@liveblocks/client";

// Create a custom `CommentBody`
const commentBody: CommentBody = {
  version: 1,
  content: [
    {
      type: "paragraph",
      children: [
        { text: "Hello " },
        { type: "mention", id: "chris@example.com" },
      ],
    },
  ],
};

// Get the mentions inside the comment's body
const mentionedIds = getMentionedIdsFromCommentBody(commentBody);

// ["chris@example.com"]
console.log(mentionedIds);
```

<Banner title="Also available from @liveblocks/node">

If you‚Äôd like to use this on the server side, it's also available from
[`@liveblocks/node`](/docs/api-reference/liveblocks-node#get-mentioned-ids-from-comment-body).

</Banner>

### stringifyCommentBody [#stringify-comment-body]

Used to convert a `CommentBody` (found under `comment.body`) into either a plain
string, Markdown, HTML, or a custom format.

```ts
import { stringifyCommentBody } from "@liveblocks/client";

const stringComment = await stringifyCommentBody(comment.body);

// "Hello marc@example.com from https://liveblocks.io"
console.log(stringComment);
```

A number of options are available.

```ts
import { stringifyCommentBody } from "@liveblocks/client";

const stringComment = await stringifyCommentBody(comment.body, {
  // Optional, convert to specific format, "plain" (default) | "markdown" | "html"
  format: "markdown",

  // Optional, supply a separator to be used between paragraphs
  separator: `\n\n`,

  // Optional, override any elements in the CommentBody with a custom string
  elements: {
    // Optional, override the `paragraph` element
    paragraph: ({ element, children }) => `<p>${children}</p>`,

    // Optional, override the `text` element
    text: ({ element }) =>
      element.bold ? `<strong>${element.text}</strong>` : `${element.text}`,

    // Optional, override the `link` element
    link: ({ element, href }) =>
      `<a href="${href}" target="_blank">${element.url}</a>`,

    // Optional, override the `mention` element. `user` available if `resolveUsers` supplied
    mention: ({ element, user }) =>
      `<a href="${user.profileUrl}">${element.id}</a>`,
  },

  // Optional, get your user's names and info from their ID to be displayed in mentions
  async resolveUsers({ userIds }) {
    const usersData = await __getUsersFromDB__(userIds);

    return usersData.map((userData) => ({
      // Name is inserted into the output instead of a user's ID
      name: userData.name,

      // Custom formatting in `elements.mention` allows custom properties to be used
      profileUrl: userData.profileUrl,
    }));
  },
});
```

<Banner title="Also available from @liveblocks/node">

If you‚Äôd like to use this on the server side, it's also available from
[`@liveblocks/node`](/docs/api-reference/liveblocks-node#stringify-comment-body).

</Banner>

#### Formatting examples

Here are a number of different formatting examples derived from the same
`CommentBody`.

```ts
// "Hello marc@example.com from https://liveblocks.io"
await stringifyCommentBody(comment.body);

// "Hello @Marc from https://liveblocks.io"
await stringifyCommentBody(comment.body, {
  resolveUsers({ userIds }) {
    return [{ name: "Marc" }];
  },
});

// "**Hello** @Marc from [https://liveblocks.io](https://liveblocks.io)"
await stringifyCommentBody(comment.body, {
  format: "markdown",

  resolveUsers() {
    return [{ name: "Marc" }];
  },
});

// "<b>Hello</b> <span data-mention>@Marc</span> from
// <a href="https://liveblocks.io">https://liveblocks.io</a>"
await stringifyCommentBody(comment.body, {
  format: "html",

  resolveUsers() {
    return [{ name: "Marc" }];
  },
});

// "<b>Hello</b> <a href="https://example.com" data-id="marc@example.com">@Marc</a> from
// <a href="https://liveblocks.io">https://liveblocks.io</a>"
await stringifyCommentBody(comment.body, {
  format: "html",

  mention: ({ element, user }) =>
    `<a href="${user.profileUrl}" data-id="${element.id}">${user.name}</a>`,

  resolveUsers() {
    return [{ name: "Marc", profileUrl: "https://example.com" }];
  },
});
```

## TypeScript

### Typing your room [#typing-your-room]

By passing Presence, Storage, UserMeta, and RoomEvents types to
[`client.enterRoom`][], you can enable type hints on your room. Here are some
example values.

```ts
import { LiveList } from "@/liveblocks/client";

// Each user‚Äôs Presence
type Presence = {
  cursor: { x: number; y: number };
};

// The Storage tree for the room
type Storage = {
  animals: LiveList<string>;
};

// User information set when authenticating with a secret key
type UserMeta = {
  id: string;
  info: {
    // Custom properties, corresponds with userInfo
  };
};

// Custom events that can be broadcast, use a union for multiple events
type RoomEvent = {
  type: "REACTION";
  emoji: "üî•";
};

const { room, leave } = client.enterRoom<
  Presence,
  Storage,
  UserMeta,
  RoomEvent
>("my-room-id", { initialPresence: {} });
```

You can also pass types to
[`client.getRoom`](/docs/api-reference/liveblocks-client#Client.getRoom).

```ts
const { room, leave } = client.getRoom<Presence, Storage, UserMeta, RoomEvent>(
  "my-room-id"
);
```

### User [#user-type]

`User` is a type that‚Äôs returned by [`room.getSelf`][], [`room.getOthers`][],
and other functions. Some of its values are set when
[typing your room](#typing-your-room), here are some example values:

```ts highlight="1-4,9-16,25-38"
// Each user‚Äôs Presence
type Presence = {
  cursor: { x: number: y: number }
}

type Storage = {}
type RoomEvent = {}

// User information set when authenticating with a secret key
type UserMeta = {
  id: string;
  info: {
    // Custom `userInfo` properties set when authenticating
    avatar: string;
  }
}

const { room, leave } = client.enterRoom<
  Presence,
  Storage,
  UserMeta,
  RoomEvent
>("my-room-id", { initialPresence: {} });

// {
//   connectionId: 52,
//   presence: {
//     cursor: { x: 263, y: 786 },
//   },
//   id: "mislav.abha@example.com",
//   info: {
//     avatar: "/mislav.png",
//   },
//   canWrite: true,
//   canComment: true,
//   isReadOnly: false,
// }
const user = room.getSelf();
```

<PropertiesList title="Properties">
  <PropertiesListItem name="connectionId" type="number">
    The connection ID of the User. It is unique and increments with every new
    connection.
  </PropertiesListItem>
  <PropertiesListItem name="id" type={`TUserMeta["id"]`}>
    The ID of the User that has been set in the authentication endpoint. Useful
    to get additional information about the connected user.
  </PropertiesListItem>
  <PropertiesListItem name="info" type={`TUserMeta["info"]`}>
    Additional user information that has been set in the authentication
    endpoint.
  </PropertiesListItem>
  <PropertiesListItem name="presence" type={`TPresence`}>
    The user‚Äôs Presence data.
  </PropertiesListItem>
  <PropertiesListItem name="canWrite" type="boolean">
    True if the user can mutate the Room‚Äôs Storage and/or YDoc, false if they
    can only read but not mutate it.
  </PropertiesListItem>
  <PropertiesListItem name="canComment" type="boolean">
    The ID of the User that has been set in the authentication endpoint. Useful
    to get additional information about the connected user.
  </PropertiesListItem>
  <PropertiesListItem name="isReadOnly" type="boolean" deprecated>
    Deprecated. False if the user can mutate the Room‚Äôs Storage and/or YDoc,
    true if they can only read but not mutate it.
  </PropertiesListItem>
</PropertiesList>

[`atob`]: https://developer.mozilla.org/en-US/docs/Web/API/atob
[`base-64`]: https://www.npmjs.com/package/base-64
[`client.enterRoom`]: /docs/api-reference/liveblocks-client#Client.enterRoom
[`client.getroom`]: /docs/api-reference/liveblocks-client#Client.getRoom
[`createclient`]: /docs/api-reference/liveblocks-client#createClient
[`fetch`]: https://developer.mozilla.org/en-US/docs/Web/API/Fetch_API
[`livelist`]: /docs/api-reference/liveblocks-client#LiveList
[`livemap`]: /docs/api-reference/liveblocks-client#LiveMap
[`liveobject`]: /docs/api-reference/liveblocks-client#LiveObject
[`lostconnectiontimeout`]:
  /docs/api-reference/liveblocks-client#createClientLostConnectionTimeout
[`toimmutable`]: /docs/api-reference/liveblocks-client#LiveObject.toImmutable
[`node-fetch`]: https://npmjs.com/package/node-fetch
[`room.broadcastevent`]:
  /docs/api-reference/liveblocks-client#Room.broadcastEvent
[`room.getstorage`]: /docs/api-reference/liveblocks-client#Room.getStorage
[`room.getSelf`]: /docs/api-reference/liveblocks-client#Room.getSelf
[`room.getOthers`]: /docs/api-reference/liveblocks-client#Room.getOthers
[`room.history`]: /docs/api-reference/liveblocks-client#Room.history
[`room.subscribe("event")`]:
  /docs/api-reference/liveblocks-client#Room.subscribe.event
[`room.subscribe("status")`]:
  /docs/api-reference/liveblocks-client#Room.subscribe.status
[`room.subscribe("lost-connection")`]:
  /docs/api-reference/liveblocks-client#Room.subscribe.lost-connection
[`room.subscribe("storage-status")`]:
  /docs/api-reference/liveblocks-client#Room.subscribe.storage-status
[`room.updatepresence`]:
  /docs/api-reference/liveblocks-client#Room.updatePresence
[`websocket`]: https://developer.mozilla.org/en-US/docs/Web/API/WebSocket
[`ws`]: https://www.npmjs.com/package/ws
[connection status example]:
  https://liveblocks.io/examples/connection-status/nextjs
