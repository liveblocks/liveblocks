---
meta:
  title: "Webhooks"
  parentTitle: "Guides"
  description: "Learn Liveblocks Webhooks concepts and implementation"
---

In this guide, we will explain how to use webhooks within your product so that
you can react to Liveblocks events as they happen. Now that our platform is
observable, you can use webhooks to reduce development time and the need for
polling.

## What is a webhook?

Webhooks make a platform observable. They let users subscribe to events on the
platform for them to react to. In this sense, webhooks streamline the collection
of data between two connected services.

Like an API, webhooks are a mechanism for a client to receive data. The main
difference between webhooks and APIs is that a webhook functions as an inverted
API. A traditional API receives requests and sends responses, whereas a webhook
is an endpoint that you provide where we send events.

The lifecycle of a webhook:

1. You create and provide a client endpoint, which listens to event messages
2. The Liveblocks server broadcasts a message (event) to the client endpoint
   when an event occurs
3. You verify the event message payload from the webhook service provider
   (Svix), and send a 200 response once the webhook has been verified
4. You use the message payload to trigger a task

Steps 2-4 will be repeated as long as you are subscribed to Liveblocks events.

In this way, webhooks provide a real-time connection between two services. While
APIs are useful for obtaining data on a scheduled basis, they are not efficient
for observing changes on a platform that has a high volume of activity.

## Concepts

### Messages

A message is generated for each event that happens within Liveblocks, as defined in the Event Catalog.  Messages contain a `type` along with data attached to it.  The message request contains headers used for security purposes.

### Events

An event occurs when a change is made to Liveblocks data. Updates to storage and rooms are common events that will trigger a message.   Each endpoint you provide in the webhooks dashboard listens to all events by default but can be easily
configured to only listen to a subset by updating the Message Filtering section.
As a new user, you may opt to listen to all events or subscribe to only the ones
that are relevant to your use case.

Alternatively, you can use the Event Catalog provided as a way to determine
which events make the most sense. The Event Catalog provides a list of events
available for subscription, along with their schema.

Events available for use include:
- UserEntered/UserLeft
- StorageUpdated
- RoomCreated/RoomDeleted
- MaxConnectionsReached

### Endpoints

An endpoint is a URL whose purpose is to receive event messages and trigger a
task based on the message payload. The only criterion for creating an endpoint
is that it must be one that you control.

### Use Cases
Before webhooks, if you wanted to update an internal data based on Liveblocks'
state, you would need to set up a cron job to poll the
[rooms API](https://development.liveblocks.io/docs/api-reference/rest-api-endpoints)
for recurrent updates. With webhooks, you can now subscribe to the events you
are interested in, and be alerted of the change when it happens. Powerful ways
to leverage webhooks with Liveblocks include:

- Storage Synchronization between room(s) and an internal database
- Alerting the client when a user leaves or enters a room
- Notifying the client if maximum concurrency has been reached

## Setup

### Creating an endpoint

Creating endpoints is simple, and is done from within the webhooks dashboard for
your project.

Before sending events, you should disable CSRF protection for the endpoint if it
is enabled by default, and use the steps outlined in the Security Section to
ensure the validity of the message.

<Figure>
  <video autoPlay loop muted playsInline>
    <source
      src="/images/docs/webhooks/create-endpoint.mp4"
      type="video/mp4"
    />
  </video>
</Figure>

### Subscribing to events

Each endpoint you provide in the webhooks dashboard listens to all events by
default but can be easily configured to only listen to a subset by updating the
Message Filtering section during endpoint creation. The subscribed events can be
edited later in the Endpoints Overview.

<Figure>
  <video autoPlay loop muted playsInline>
    <source
      src="/images/docs/webhooks/edit-events.mp4"
      type="video/mp4"
    />
  </video>
</Figure>

### Replaying events

If your service is unreachable, retries will automatically be attempted. If your
service incurs considerable downtime (over 10 hours), you can replay individual
messages from the Endpoints portion of the dashboard by clicking the kebab menu
on an individual message, or you can opt to bulk replay events by clicking the
main menu and selecting "Replay Failed Messages." For a list of the specific
retry intervals, see the
[Svix Documentation on Retries](https://docs.svix.com/retries)

<Figure>
  <video autoPlay loop muted playsInline>
    <source
      src="/images/docs/webhooks/replay-events.mp4"
      type="video/mp4"
    />
  </video>
</Figure>

## Security
Webhooks can generate security holes, but verification can mitigate this risk. When you verify your webhooks, you
protect against man-in-the-middle, CSRF, and replay attacks. Because of this, the
importance of verification cannot be understated and should be considered
paramount in your integration. If you are interested in a more comprehensive overview of why you should verify webhooks, the [Svix Documentation](https://docs.svix.com/receiving/verifying-payloads/why) is a great resource.

To validate a webhook run:

```
npm install svix
```

Then, inside your application where you call the webhook:

```typescript
import { Webhook } from "svix";

const secret = "xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx";
// the secret is provided in the Webhooks Dashboard under "Signing Secret"
// This is an example sent from server
const headers = {
  "webhook-id": "msg_p5jXN8AQM9LWM0D4loKWxJek",
  "webhook-timestamp": "1614265330",
  "webhook-signature": "v1,g0hM9SsE+OTPJTGt/tmIKtSyZlE3uFJELVlNIOLJ1OE=",
};
const payload = '{"test": 2432232314}';

const wh = new Webhook(secret);
// Throws on error, returns the verified content on success
const payload = wh.verify(payload, headers);
```

This snippet serves as an example of how to parse one incoming message. To
dynamically verify the authenticity of a webhook, you would programmatically
define the headers and payload as JSON objects and pass them as an argument to
the `verify` function. Though not recommended, manual verification is possible
and outlined
[here](https://docs.svix.com/receiving/verifying-payloads/how-manual)
