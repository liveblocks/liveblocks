---
meta:
  title: "Schema language"
  parentTitle: "Guides"
  description:
    "Learn how to use schemas to ensure data integrity in your application"
---

## Syntax

The list below is exhaustive of the supported feature that will be implemented
before the public beta.

We currently support the following schema types: `LiveObject`, `Object`, and
`Scalars` during the private beta.

We’re sharing our plans for other syntaxes so you can give us early feedback
[here](TODO).

### Storage root

Each schema must include the `Storage` type, a special type of “root” object.

```ts
type Storage {

}
```

### Scalars

Familiar scalar types are globally available when you create a schema. We
support:

- `String`
- `Int` (only whole numbers)
- `Float` (floats and whole numbers)
- `Boolean`

A sample schema using scalar types could look like this:

```ts
type Storage {
  name: String
  age: Int
  height: Float
  hasSiblings: Boolean
}
```

And here are some updates that would accepted and rejected by the schema:

```ts
// ✅ Valid storage updates
root.set("name", "Marie Curie");
root.set("age", 66);
root.set("height", 1.52);
root.set("hasSiblings", true);

// ❌ Invalid storage updates
root.set("name", true);
root.set("age", 66.5); // Invalid because `age` should be a whole number
root.set("height", "1.52");
root.set("hasSiblings", "???");
```

### Optionals

Each field inside an object type can be marked optional using the `?` operator.
An optional field means that it can be deleted.

For example, if your schema looked exactly like the example provided above,
except we changed the `age` field to optional:

```ts highlight="3"
type Storage {
  name: String
  age?: Int
  height: Float
  hasSiblings: Boolean
}
```

Accepted and rejected updates:

```ts
// ✅
root.delete("age");

// ❌
root.delete("name"); // `name` is not optional
```

<Banner title="Comparison with GraphQL">
  Notice that we made the decision to make every field mandatory by default, as
  opposed to GraphQL.
</Banner>

### Object types

Our language supports two different ways to declare types:

- Named type definition

```ts
type Scientist {
  name: String
  age: Int
}

type Storage {
  scientist: Scientist
}
```

- Anonymous type definition

```ts
type Storage  {
  scientist: { name: String, age: Int }
}
```

These definitions are equivalent. Accepted and rejected updates:

```ts
// ✅
root.set("scientist", { name: "Marie Curie", age: 66 });

// ❌
root.set("scientist", { name: "Marie Curie" }); // `age` is missing
```

### LiveObject

To turn an object type into a “live” object type, wrap it in the built-in
[`LiveObject`](/docs/api-reference/liveblocks-client#LiveObject) type like so:

```ts
`LiveObject<typeExpr>`; // where `typeExpr` must be an object type
```

We can convert an object type from the example above to a `LiveObject` type by
creating the following schema:

```ts
type Scientist {
  name: String
  age: Int
}

type Storage {
  scientist: LiveObject<Scientist>
}
```

Accepted and rejected updates:

```ts
// ✅
root.set("scientist", new LiveObject({ name: "Marie Curie"; age: 66 }));

// ❌ `scientist` should be a LiveObject
root.set("scientist", { name: "Marie Curie"; age: 66 });
```

### Array

`Array` can be defined like this:

```ts
type Storage {
  animals: String[]
}
```

Accepted and rejected updates:

```ts
// ✅
root.set("animals", ["🦁", "🦊", "🐵"]));

// ❌
root.set("animals", [1, 2, 2]);
```

### LiveList

To turn an `Array` into a “live” array, wrap it in the built-in
[`LiveList`](/docs/api-reference/liveblocks-client#LiveList) type when you
reference it like so:

```ts
`LiveObject<typeExpr>`; // where `typeExpr` must be an object type
```

We can convert an `Array` from the example above to a `LiveList` by creating the
following schema:

```ts
type Storage {
  animals: LiveList<string>
}
```

Accepted and rejected updates:

```ts
// ✅
root.set("animals", new LiveList(["🦁", "🦊", "🐵"]));

// ❌
root.set("animals", ["🦁", "🦊", "🐵"]); // `animals` should be a `LiveList`
```

### LiveMap

It’s also possible to define a
[`LiveMap`](/docs/api-reference/liveblocks-client#LiveMap) in your schema.

```ts
`LiveMap<String, typeExpr>`; // where the first argument must be a `String`
```

For example:

```ts
type Shape {
  x: Float
  y: Float
  fill: String
}

type Storage {
  shapes: LiveMap<string, Shape>
}
```

Accepted and rejected updates:

```ts
// ✅
root.set(
  "shapes",
  new LiveMap([["shapeId", { x: 100, y: 100, fill: "blue" }]])
);

// ❌
root.set("shapes", new LiveMap([["shapeId", { x: 100, y: 100 }]]));
```

## What’s to come

We’re also planning to support more language features. Discriminated unions,
regex, ranges, etc...

If you’re interested in a specific feature, please send your feedback on this
GitHub [discussion](TODO) so we can prioritize it appropriately!
