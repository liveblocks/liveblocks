---
meta:
  title: "Schema Validation"
  parentTitle: "Guides”
  description: "Learn how to use Schema Validation to ensure data integrity in your application”
---

## Why schema validation?
Schema validation is essential for future-proofing your application and ensuring that implementing new features or data structures into your app will keep the integration you have established with Liveblocks. Our storage block is flexible in that you can store different Type structures depending on your unique needs. 

Schema validation is a vital tool for production environments- it ensures that a mismatch between the items currently in storage and any new modifications to the storage structure does not introduce a client-side bug. 

We currently mitigate the risk of introducing client-side errors by allowing you to type your storage in `liveblocks.config.ts`. Still, we want to go one step further to help you protect your application by attaching a schema to a room that rejects invalid modifications. By including a schema, you will be able to trust any incoming storage modifications, and you will be able to synchronize our storage with your database more safely. Paring your schema validation with webhooks makes your application robust and allows you to synchronize your storage in real-time. 


## How schema validation works
As described above, the primary purpose of schema validation is to prevent corrupted data from being loaded from the server. Once you define the shape of your storage with a schema (similar to how you would describe the storage type in typescript), you can then attach your schema to a room. Once you attach a schema to a room, Liveblocks will reject any modifications to the storage that do not match the schema you provided.

<!-- Insert an animation here !-->


For example, imagine that a client performs an operation that updates the storage tree: regardless of whether or not this could introduce a bug, Liveblocks has no opinion on what this mutation represents and accepts the incoming operation and synchronizes it with other clients. There is no right or wrong way to mutate data. After the operation completes, the updated storage tree is forwarded to other users in the room. 

When a room enforces schema validation and the client updates values in the storage, the operation is sent to the Liveblocks server, verifying that the updated Storage Tree is consistent with the defined schema attached to the room. If the verification succeeds, the storage data gets updated and synchronized with other users (clients) in the room. If the schema validation fails, the mutation gets rejected: storage will not be updated, other clients will never see the change, and the client that made the mutation will throw an error. Situations like this should only happen in development mode, and the developer will fix the bug. This situation is similar to resolving a TypeScript error before publishing it to production.

## Create a schema
To create a schema, you will need to POST to the schemas endpoint:
```ts
POST https://api.liveblocks.io/v2/schemas
{
  "id": "some-id",
  "name": "Your schema name",
  "data": `{
    type Storage {
      // your data schema will go here
    }
  }`,
}

```
Note that the data type will be of type string because the schema will be parsed. For more information, see our [Schema Language documentation](xxx).
The operation above creates the schema, but no schema is attached to a room. To attach this schema to a room, you will POST to the rooms endpoint:
```ts
POST https://api.liveblocks.io/v2/rooms/{id}/schema
{
  "versionId": "some-id"
}
```
## The validation process in practice
If you would like to work through an example, you can follow along by using the [Multiplayer Form example](/examples/multiplayer-form/nextjs).

The schema we will define for the example is the following:
```ts
POST https://api.liveblocks.io/v2/schemas

{
  "id": "collaborative-form",
  "name": "Collaborative Form",
  "data": `
    type Logo {
      name: String
      theme: String
    }
    type storage {
      logo: LiveObject<Logo>
    }
  `
}
// 200 Response
{
   "versionId": "collaborative-form@1",
   "schemaId": "collaborative-form",
   "name": "Collaborative Form",
   "createdAt": "2023-01-22T15:10:25.225Z",
   "updatedAt": "2023-01-22T15:10:25.225Z"
}
```

To attach this schema to a room, you will POST to the rooms endpoint:

```ts
POST https://api.liveblocks.io/v2/rooms/{id}/schema
{
  "schema": "collaborative-form@1"
}
```

To simulate the importance of schema validation and also demonstrate how operations can fail, we will change the nested value of `name` to `organization`:

```tsx file="_app.tsx"
    <RoomProvider
      id={roomId}
      initialPresence={{ focusedId: null }}
      initialStorage={{
        logo: new LiveObject({
          organization: "Acme Inc.",
          theme: "light",
        }),
      }}
    >
```
In `index.tsx`, we will update all references from `name` to `organization`: this is a simple but common instance of updating variable names, which could easily break our integration. 
After updating and running locally, we should now see an error because our deployed schema and client code are out of sync.

<!----Insert sample failure message here, once this is released. You also mentioned demonstrating a refresh, but I have no way to record this currently !--->

When an instance like this occurs, it's indicative of a bug in your app, which you should fix in development, just like how you have to fix a TypeScript bug in your application before shipping it. 


<!----I believe the plan here was to insert some components that were used on the comments page --->

We’re opening up a private beta waitlist

CTA to sign up for it, and to let us know their use case for it 
<!--- -->

## What’s to come
The ability to add schema validation via API calls is powerful- but we’re not stopping there. In the future, we will expand the ability to add schema validation with the touch of a button. Our road map includes the ability to generate Typescript types from the schema. In addition, schema validation with Liveblocks will consist of online management and editing of your schemas from within the dashboard (and you can currently sign up for the waitlist here!). When you create a new schema, you may have noticed that it is versioned: our long-term goal is to run migrations with minimal effort by using schema versions coupled with webhooks.
For those with many rooms, the ability to add schema validation en masse will also be available shortly. 

How has schema validation helped you ensure the data integrity of your application? Is there a specific feature of schema validation you are most excited to use? 
