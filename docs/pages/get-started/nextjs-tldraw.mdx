---
meta:
  title:
    "Get started with a collaborative Tldraw canvas using Liveblocks and Next.js"
  parentTitle: "Quickstart"
  description:
    "Learn how to add a collaborative Tldraw canvas using Liveblocks and Next.js"
---

Liveblocks is a realtime collaboration infrastructure for building performant
collaborative experiences. Follow the following steps to start adding
collaboration to your Next.js and Tldraw app using hooks from
[`@liveblocks/react`](/docs/api-reference/liveblocks-react).

## Quickstart

<Steps>

  <Step>
    <StepTitle>Install Liveblocks</StepTitle>
    <StepContent>

      Every package should use the same version.

      ```bash trackEvent="install_liveblocks"
      npm install @liveblocks/client @liveblocks/react tldraw
      ```

    </StepContent>

  </Step>
  <Step>
    <StepTitle>Initialize the `liveblocks.config.ts` file</StepTitle>
    <StepContent>

      We can use this file later to [define types for our application](/docs/api-reference/liveblocks-react#Typing-your-data).

      ```bash
      npx create-liveblocks-app@latest --init --framework react
      ```

    </StepContent>

  </Step>

<Step>
    <StepTitle>Add Tldraw types to `liveblocks.config.ts`</StepTitle>
    <StepContent>

    Edit your new `liveblocks.config.ts` file to include the following types for Tldraw.

      ```ts file="liveblocks.config.ts"
      declare global {
        interface Liveblocks {
          Presence: {
            presence: any;
          };

          Storage: {
            records: LiveMap<string, any>;
          };

          UserMeta: {
            id: string;
            info: {
              name: string;
              color: string;
              avatar: string;
            };
          };
        }
      }
      ```

    </StepContent>

  </Step>

  <Step>
    <StepTitle>Create a Liveblocks room</StepTitle>
    <StepContent>

      Liveblocks uses the concept of rooms, separate virtual spaces where people
      collaborate, and to create a realtime experience, multiple users must
      be connected to the same room. When using Next.js’ `/app` router,
      we recommend creating your room in a `Room.tsx` file in the same directory
      as your current route.

      Set up a Liveblocks client with
      [`LiveblocksProvider`](/docs/api-reference/liveblocks-react#LiveblocksProvider),
      join a room with [`RoomProvider`](/docs/api-reference/liveblocks-react#RoomProvider),
      and use [`ClientSideSuspense`](/docs/api-reference/liveblocks-react#ClientSideSuspense)
      to add a loading spinner to your app.

      ```tsx file="app/Room.tsx" highlight="12-18"
      "use client";

      import { ReactNode } from "react";
      import {
        LiveblocksProvider,
        RoomProvider,
        ClientSideSuspense,
      } from "@liveblocks/react/suspense";

      export function Room({ children }: { children: ReactNode }) {
        return (
          <LiveblocksProvider publicApiKey={"{{PUBLIC_KEY}}"}>
            <RoomProvider id="my-room">
              <ClientSideSuspense fallback={<div>Loading…</div>}>
                {children}
              </ClientSideSuspense>
            </RoomProvider>
          </LiveblocksProvider>
        );
      }
      ```

    </StepContent>

  </Step>
  <Step>
    <StepTitle>Add the Liveblocks room to your page</StepTitle>
    <StepContent>

      After creating your room file, it’s time to join it. Import
      your room into your `page.tsx` file, and place
      your collaborative app components inside it.

      ```tsx file="app/page.tsx" highlight="6-8"
      import { Room } from "./Room";
      import { TldrawApp } from "./TldrawApp";

      export default function Page() {
        return (
          <Room>
            <TldrawApp />
          </Room>
        );
      }
      ```

    </StepContent>

  </Step>
  <Step>
    <StepTitle>Add the Tldraw component</StepTitle>
    <StepContent>

      Now that we’re connected to a room, add the `Tldraw` component, importing a custom `useStorageStore` hook.

      ```tsx file="app/TldrawApp.tsx"
      "use client";

      import { useStorageStore } from "./useStorageStore";

      function StorageTldraw() {
        const id = useSelf((me) => me.id);
        const info = useSelf((me) => me.info);

        const store = useStorageStore({
          user: { id, color: info?.color || "red", name: info?.name || "Guest" },
        });

        return (
          <div style={{ height: "100%", width: "100vw" }}>
            <Tldraw store={store} autoFocus />
          </div>
        );
      }
      ```

    </StepContent>

  </Step>

<Step>
    <StepTitle>Synchronize Tldraw with Liveblocks</StepTitle>
    <StepContent>

      Create the `useStorageStore` hook to synchronize Tldraw state with
      Liveblocks Storage, and your canvas should be synchronized.

      ```tsx file="app/useStorageStore.ts" isCollapsable isCollapsed
      import { useEffect, useState } from "react";
      import { useRoom } from "@liveblocks/react/suspense";
      import {
        computed,
        createPresenceStateDerivation,
        createTLStore,
        react,
        defaultShapeUtils,
        DocumentRecordType,
        InstancePresenceRecordType,
        PageRecordType,
        IndexKey,
        TLAnyShapeUtilConstructor,
        TLDocument,
        TLInstancePresence,
        TLPageId,
        TLRecord,
        TLStoreEventInfo,
        TLStoreWithStatus,
      } from "tldraw";

      export function useStorageStore({
        shapeUtils = [],
        user,
      }: Partial<{
        hostUrl: string;
        version: number;
        shapeUtils: TLAnyShapeUtilConstructor[];
        user: {
          id: string;
          color: string;
          name: string;
        };
      }>) {
        // Get Liveblocks room
        const room = useRoom();

        // Set up tldraw store and status
        const [store] = useState(() => {
          const store = createTLStore({
            shapeUtils: [...defaultShapeUtils, ...shapeUtils],
          });
          return store;
        });

        const [storeWithStatus, setStoreWithStatus] = useState<TLStoreWithStatus>({
          status: "loading",
        });

        useEffect(() => {
          const unsubs: (() => void)[] = [];
          // State is already initialized to "loading", no need to set it again

          async function setup() {
            // Get Liveblocks Storage values
            const { root } = await room.getStorage();
            const liveRecords = root.get("records");

            // Initialize tldraw with records from Storage
            store.clear();
            store.put(
              [
                DocumentRecordType.create({
                  id: "document:document" as TLDocument["id"],
                }),
                PageRecordType.create({
                  id: "page:page" as TLPageId,
                  name: "Page 1",
                  index: "a1" as IndexKey,
                }),
                ...[...liveRecords.values()],
              ],
              "initialize"
            );

            // Sync tldraw changes with Storage
            unsubs.push(
              store.listen(
                ({ changes }: TLStoreEventInfo) => {
                  room.batch(() => {
                    Object.values(changes.added).forEach((record) => {
                      liveRecords.set(record.id, record);
                    });

                    Object.values(changes.updated).forEach(([_, record]) => {
                      liveRecords.set(record.id, record);
                    });

                    Object.values(changes.removed).forEach((record) => {
                      liveRecords.delete(record.id);
                    });
                  });
                },
                { source: "user", scope: "document" }
              )
            );

            // Sync tldraw changes with Presence
            function syncStoreWithPresence({ changes }: TLStoreEventInfo) {
              room.batch(() => {
                Object.values(changes.added).forEach((record) => {
                  room.updatePresence({ [record.id]: record });
                });

                Object.values(changes.updated).forEach(([_, record]) => {
                  room.updatePresence({ [record.id]: record });
                });

                Object.values(changes.removed).forEach((record) => {
                  room.updatePresence({ [record.id]: null });
                });
              });
            }

            unsubs.push(
              store.listen(syncStoreWithPresence, {
                source: "user",
                scope: "session",
              })
            );

            unsubs.push(
              store.listen(syncStoreWithPresence, {
                source: "user",
                scope: "presence",
              })
            );

            // Update tldraw when Storage changes
            unsubs.push(
              room.subscribe(
                liveRecords,
                (storageChanges) => {
                  const toRemove: TLRecord["id"][] = [];
                  const toPut: TLRecord[] = [];

                  for (const update of storageChanges) {
                    if (update.type !== "LiveMap") {
                      return;
                    }

                    for (const [id, { type }] of Object.entries(update.updates)) {
                      switch (type) {
                        // Object deleted from Liveblocks, remove from tldraw
                        case "delete": {
                          toRemove.push(id as TLRecord["id"]);
                          break;
                        }

                        // Object updated on Liveblocks, update tldraw
                        case "update": {
                          const curr = update.node.get(id);
                          if (curr) {
                            toPut.push(curr as any as TLRecord);
                          }
                          break;
                        }
                      }
                    }
                  }

                  // Update tldraw with changes
                  store.mergeRemoteChanges(() => {
                    if (toRemove.length) {
                      store.remove(toRemove);
                    }
                    if (toPut.length) {
                      store.put(toPut);
                    }
                  });
                },
                { isDeep: true }
              )
            );

            // Set user's info
            const userPreferences = computed<{
              id: string;
              color: string;
              name: string;
            }>("userPreferences", () => {
              if (!user) {
                throw new Error("Failed to get user");
              }
              return {
                id: user.id,
                color: user.color,
                name: user.name,
              };
            });

            // Unique ID for this session is their connectionId
            const connectionIdString = "" + (room.getSelf()?.connectionId || 0);

            // Set both
            const presenceDerivation = createPresenceStateDerivation(
              userPreferences,
              InstancePresenceRecordType.createId(connectionIdString)
            )(store);

            // Update presence with tldraw values
            room.updatePresence({
              presence: presenceDerivation.get() ?? null,
            });

            // Update Liveblocks when tldraw presence changes
            unsubs.push(
              react("when presence changes", () => {
                const presence = presenceDerivation.get() ?? null;
                requestAnimationFrame(() => {
                  room.updatePresence({ presence });
                });
              })
            );

            // Sync Liveblocks presence with tldraw
            unsubs.push(
              room.subscribe("others", (others, event) => {
                const toRemove: TLInstancePresence["id"][] = [];
                const toPut: TLInstancePresence[] = [];

                switch (event.type) {
                  // A user disconnected from Liveblocks
                  case "leave": {
                    if (event.user.connectionId) {
                      toRemove.push(
                        InstancePresenceRecordType.createId(
                          `${event.user.connectionId}`
                        )
                      );
                    }
                    break;
                  }

                  // Others was reset, e.g. after losing connection and returning
                  case "reset": {
                    others.forEach((other) => {
                      toRemove.push(
                        InstancePresenceRecordType.createId(`${other.connectionId}`)
                      );
                    });
                    break;
                  }

                  // A user entered or their presence updated
                  case "enter":
                  case "update": {
                    const presence = event?.user?.presence;
                    if (presence?.presence) {
                      toPut.push(event.user.presence.presence);
                    }
                  }
                }

                // Update tldraw with changes
                store.mergeRemoteChanges(() => {
                  if (toRemove.length) {
                    store.remove(toRemove);
                  }
                  if (toPut.length) {
                    store.put(toPut);
                  }
                });
              })
            );

            setStoreWithStatus({
              store,
              status: "synced-remote",
              connectionStatus: "online",
            });
          }

          setup();

          return () => {
            unsubs.forEach((fn) => fn());
            unsubs.length = 0;
          };
        }, [room, store, user]);

        return storeWithStatus;
      }
      ```
    </StepContent>

  </Step>

  <Step lastStep>
    <StepTitle>Next: set up authentication</StepTitle>
    <StepContent>

      By default, Liveblocks is configured to work without an authentication endpoint
      where everyone automatically has access to rooms. This approach is great for
      prototyping and marketing pages where setting up your own security isn’t always
      required. If you want to limit access to a room for certain users, you’ll need
      to set up an authentication endpoint to enable permissions.

      <Button asChild className="not-markdown">
        <a href="/docs/authentication">
          Set up authentication
        </a>
      </Button>
    </StepContent>

  </Step>
</Steps>

## What to read next

Congratulations! You now have set up the foundation to start building
collaborative experiences for your React application.

- [@liveblocks/react API Reference](/docs/api-reference/liveblocks-react)
- [Next.js and React guides](/docs/guides?technologies=nextjs%2Creact)
- [How to use Liveblocks Presence with React](/docs/guides/how-to-use-liveblocks-presence-with-react)
- [How to use Liveblocks Storage with React](/docs/guides/how-to-use-liveblocks-storage-with-react)

---

## Examples using Next.js

<ListGrid columns={2}>
  <ExampleCard
    example={{
      title: "Collaborative To-do List",
      slug: "collaborative-todo-list/nextjs-todo-list",
      image: "/images/examples/thumbnails/collaborative-todo-list.jpg",
    }}
    technologies={["nextjs", "vuejs", "sveltekit", "solidjs", "javascript"]}
    openInNewWindow
  />
  <ExampleCard
    example={{
      title: "Live Avatar Stack",
      slug: "live-avatar-stack/nextjs-live-avatars",
      image: "/images/examples/thumbnails/live-avatar-stack.jpg",
    }}
    technologies={["nextjs", "nuxtjs", "vuejs", "sveltekit", "solidjs"]}
    openInNewWindow
  />
  <ExampleCard
    example={{
      title: "Collaborative Spreadsheet",
      slug: "collaborative-spreadsheet-advanced/nextjs-spreadsheet-advanced",
      image:
        "/images/examples/thumbnails/collaborative-spreadsheet-advanced.jpg",
      advanced: true,
    }}
    technologies={["nextjs"]}
    openInNewWindow
  />
  <ExampleCard
    example={{
      title: "Collaborative Whiteboard",
      slug: "collaborative-whiteboard-advanced/nextjs-whiteboard-advanced",
      image:
        "/images/examples/thumbnails/collaborative-whiteboard-advanced.jpg",
      advanced: true,
    }}
    technologies={["nextjs"]}
    openInNewWindow
  />
</ListGrid>
