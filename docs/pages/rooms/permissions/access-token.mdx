---
meta:
  title: "Manage permissions with access tokens"
  parentTitle: "Permissions"
  description: "Learn more about access token permissions"
---

Managing permissions by issuing access tokens follows the analogy of a “hotel
room key card”. Anyone that has that key card can open the doors that the card
gives access to. It’s easy to give out those key cards right from your backend.

To set up your authentication endpoint with access token permissions, make sure
to [follow these quick steps](/docs/rooms/authentication/id-token-permissions).

## Authentication patterns

### Full access to just one room

```ts
import { Liveblocks } from "@liveblocks/node";

const liveblocks = new Liveblocks({
  secret: "{{SECRET_KEY}}",
});

export default async function authEndpoint(req, res) {
  // You'll need to get the user from your
  // authentication provider here.
  const user = __getUserFromDB__(req);

  const session = liveblocks.prepareSession(
    user.id,
    { userInfo: user.metadata } // Optional
  );
  // You'll need to implement your own security here.
  if (req.body.room && __shouldUserHaveAccess__(user, req.body.room)) {
    session.allow(req.body.room, session.FULL_ACCESS);
  }

  const { status, body } = await session.authorize();
  return res.status(status).end(body);
}
```

### Full access to all rooms from a team

```ts
import { Liveblocks } from "@liveblocks/node";

const liveblocks = new Liveblocks({
  secret: "{{SECRET_KEY}}",
});

export default async function authEndpoint(req, res) {
  // You'll need to get the user from your
  // authentication provider here.
  const user = __getUserFromDB__(req);

  const session = liveblocks.prepareSession(
    user.id,
    { userInfo: user.metadata } // Optional
  );
  if (req.body.room) {
    // Suppose this application organizes their Liveblocks rooms by keys
    // structured like `<team>:<room>`.
    // We can then use the passed-in requested room to infer which team to
    // check membership for.
    const [team, _] = req.body.room.split(":");
    if (__isMemberOfTeam__(user, team)) {
      // If the user is a member of this team, don't just grant full access to
      // the request room, but to _all_ of the team's rooms, using a prefix
      // pattern.
      session.allow(`${team}:*`, session.FULL_ACCESS);
    }
  }

  const { status, body } = await session.authorize();
  return res.status(status).end(body);
}
```

### Full access to all rooms from a team, but read-only access to rooms from the organization level

```ts
import { Liveblocks } from "@liveblocks/node";

const liveblocks = new Liveblocks({
  secret: "{{SECRET_KEY}}",
});

export default async function authEndpoint(req, res) {
  // You'll need to get the user from your
  // authentication provider here.
  const user = __getUserFromDB__(req);

  const session = liveblocks.prepareSession(user.id);
  if (req.body.room) {
    // Suppose this application organizes their Liveblocks rooms by keys
    // structured like `<org>:<team>:<room>`.
    // We can then use the passed-in requested room to infer which team to
    // check membership for.
    const [org, team, _] = req.body.room.split(":");
    if (__isMemberOfOrg__(user, org)) {
      session.allow(`${org}:*`, READ_ACCESS);
    }
    if (__isMemberOfTeam__(user, team)) {
      session.allow(`${org}:${team}:*`, FULL_ACCESS);
    }
  }

  const { status, body } = await session.authorize();
  return res.status(status).end(body);
}
```
