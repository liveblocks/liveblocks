---
meta:
  title: "Self-hosted permissions"
  parentTitle: "Permissions"
  description: "Learn more about self-hosted permissions"
---

Self-hosted permissions follows the analogy of a "hotel room key card" through
an Access token. Anyone that has that key card can open the doors that the card
gives access to. Itâ€™s easy to give out those key cards right from your backend.

To set up your authentication endpoint with self-hosted permissions, make sure
to [follow these quick steps](/docs/rooms/authentication/id-token-permissions).

## Authentication patterns

### Full access to just one room

```ts
import { Liveblocks } from "@liveblocks/node";

const liveblocks = new Liveblocks({
  secret: "{{SECRET_KEY}}",
});

export default async function authEndpoint(req, res) {
  // You'll need to get the user from your
  // authentication provider here.
  const user = __getUserFromReq__(req);

  const session = liveblocks.prepareSession(
    user.id,
    { userInfo: user.metadata } // Optional
  );
  // You'll need to implement your own security here.
  if (req.body.room && __checkHasAccess__(user, req.body.room)) {
    session.allow(req.body.room, session.FULL_ACCESS);
  }

  const { status, body } = await session.authorize();
  return res.status(status).end(body);
}
```

### Full access to all rooms from a team

```ts
import { Liveblocks } from "@liveblocks/node";

const liveblocks = new Liveblocks({
  secret: "{{SECRET_KEY}}",
});

export default async function authEndpoint(req, res) {
  // You'll need to get the user from your
  // authentication provider here.
  const user = __getUserFromReq__(req);

  const session = liveblocks.prepareSession(
    user.id,
    { userInfo: user.metadata } // Optional
  );
  if (req.body.room) {
    // Suppose this application organizes their Liveblocks rooms by keys
    // structured like `<team>:<room>`.
    // We can then use the passed-in requested room to infer which team to
    // check membership for.
    const [team, _] = req.body.room.split(":");
    if (__checkIsMemberOfTeam__(user, team)) {
      // If the user is a member of this team, don't just grant full access to
      // the request room, but to _all_ of the team's rooms, using a prefix
      // pattern.
      session.allow(`${team}:*`, session.FULL_ACCESS);
    }
  }

  const { status, body } = await session.authorize();
  return res.status(status).end(body);
}
```

### Full access to all rooms from a team, but read-only access to rooms from the organization level

```ts
import { Liveblocks } from "@liveblocks/node";

const liveblocks = new Liveblocks({
  secret: "{{SECRET_KEY}}",
});

export default async function authEndpoint(req, res) {
  // You'll need to get the user from your
  // authentication provider here.
  const user = __getUserFromReq__(req);

  const session = liveblocks.prepareSession(user.id);
  if (req.body.room) {
    // Suppose this application organizes their Liveblocks rooms by keys
    // structured like `<org>:<team>:<room>`.
    // We can then use the passed-in requested room to infer which team to
    // check membership for.
    const [org, team, _] = req.body.room.split(":");
    if (__checkIsMemberOfOrg__(user, org)) {
      session.allow(`${org}:*`, READ_ACCESS);
    }
    if (__checkIsMemberOfTeam__(user, team)) {
      session.allow(`${org}:${team}:*`, FULL_ACCESS);
    }
  }

  const { status, body } = await session.authorize();
  return res.status(status).end(body);
}
```
