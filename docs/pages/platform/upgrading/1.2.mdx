---
meta:
  title: "Upgrading to 1.2"
  parentTitle: "Upgrading"
  description: "Guide to upgrade to Liveblocks version 1.2"
---

This update does not introduce any breaking changes. But are you calling
`createClient()` with the `authEndpoint` option? Read on! This update is for
you.

Liveblocks 1.2 brings support for new ways to let you specify who can access
which rooms, and with what permissions. Our new-style security tokens will bring
speed improvements, letting your client code connect to Liveblocks rooms even
faster, and let you reuse those authorization tokens between multiple rooms.

## Public key authentication changes [#public-auth-changes]

<Banner type="success" title="No changes required">
  If you’re using your Liveblocks **public key**, great! There is nothing you
  have to change.
</Banner>

Entering rooms using your public key should be noticably faster on 1.2.

Confused which keys you are using? You can find your keys
[in our dashboard](https://liveblocks.io/dashboard/apikeys). Please remember
that public key authentication is great for prototyping and for marketing pages,
but for more serious applications where security matters, do not use it!

## Private key authentication changes [#private-auth-changes]

<Banner type="warning" title="We recommend changing your auth backend">
  If you’re using your Liveblocks **private key**, there is nothing you _have_
  to change. But we **strongly recommend** you to upgrade your auth backend.
</Banner>

If you upgrade your existing auth backend, you opt-in to using our new-style
auth tokens which offer the following benefits:

- When you authorize a user, you can grant them permissions to access multiple
  rooms in one transaction. The client will then be able to join many rooms
  without having to reauthorize those requests every time.
- In most cases, it’s going to be faster to enter the first room
- It’s much faster to enter subsequent rooms
- Less pressure on your backend if you have many users
- You can use our upcoming features like [Comments](/comments) (currently in
  private beta)

## How to upgrade? [#how]

We’ll walk you through the necessary code changes below in a minute, but let’s
talk about the rollout plan first. We cannot “just change” the backend
implementation to use new-style tokens. If you have a running Liveblocks
application in production, then people may have old browser tabs open that are
still running an old Liveblocks client (< 1.2) which won’t expect or understand
our new-style auth tokens, causing them to crash. We don’t want that of course,
and we’ll responsibly replace the auth backend using the following steps:

1. Keep your existing backend endpoint (likely `/api/auth`).
1. Add a second auth backend endpoint, and only use the new auth APIs in there.
1. In your front-end, point `createClient()`’s `authEndpoint` URL to the new
   backend endpoint.
1. Done! You can deploy your application now.
1. Later, when all your application’s clients have been upgraded to the latest
   version, you can safely remove the old `/api/auth` endpoint.

## Deciding what to upgrade to [#deciding]

After you upgrade your backend’s `@liveblocks/node` dependency to 1.2, it now
offers three (instead of one) APIs to obtain an auth token:

|     | Token                                                     | API                                                     | Multi-room | Source of truth | Support in 1.1 | Support in 1.2 |
| :-- | :-------------------------------------------------------- | :------------------------------------------------------ | :--------- | :-------------- | :------------- | :------------- |
| 1.  | **Single-room token**                                     | <code><small>authorize()</small></code>                 | –          | Your backend    | ✅             | ⚠️             |
| 2.  | **Access token**<br /><small>✨&nbsp;Recommended!</small> | <code><small>liveblocks.prepareSession()</small></code> | ✅         | Your backend    | –              | ✅             |
| 3.  | **ID token**                                              | <code><small>liveblocks.identifyUser()</small></code>   | ✅         | Liveblocks      | –              | ✅             |

1. **Single-room tokens** are what you’re currently using.  
   ⚠️ <small>These tokens will be supported, but we will eventually deprecate
   and drop support for them.</small>
1. **Access tokens** is our new preferred/recommended way to to auth, because it
   is very easy to manage from your own backend.
1. **ID tokens** are best used if you create rooms from your backend before your
   clients enter them. You can specify who has access to those rooms using our
   [Permission REST APIs](/docs/rooms/permissions/id-token), and let the source
   of truth for those permissions be Liveblocks.

<Banner title="What's the difference?">

**Access tokens** follow the analogy of a “hotel room key card”. Anyone that has
that key card can enter any room that the card gives access to. It’s easy to
give out those key cards right from your backend.<br /><br />**ID tokens**
follow the analogy of a “membership card”. Anyone with that membership card can
try to enter a room, but your permissions will get checked at the door. This
approach to permissions is most powerful because it can be set up very
fine-grained and exactly, but it comes at the cost of having to keep those
permissions programmatically in sync with Liveblocks. We recommend it for
advanced use cases only, and only if Access Tokens don’t cut it for you.

</Banner>

Continue reading:

- [Upgrade to access tokens](#upgrade-to-access-tokens) (recommended)  
  or...
- [Upgrade to ID tokens](#upgrade-to-id-tokens)

## Upgrading to access tokens [#upgrade-to-access-tokens]

First, create a new endpoint in your backend, next to your existing `/api/auth`
endpoint. We recommend going with `/api/liveblocks-auth`.

Let’s first implement it to issue tokens that would be equivalent to your
current single-room token based setup:

```ts file="app/api/liveblocks-auth/route.ts"
import { Liveblocks } from "@liveblocks/node";

// Step 1️⃣
const liveblocks = new Liveblocks({
  secret: "sk_prod_xxxxxxxxxxxxxxxxxxxxxxxx",
});

export default async function myNewAuthEndpoint(req, res) {
  const user = __getUserFromDB__(req);

  // Step 2️⃣
  const session = liveblocks.prepareSession(
    user.id,
    { userInfo: user.metadata } // Optional
  );

  // Step 3️⃣
  if (req.body.room && __shouldUserHaveAccess__(user, req.body.room)) {
    // e.g. session.allow("my-room", ["room:write"])
    session.allow(req.body.room, session.FULL_ACCESS);
  }

  // Step 4️⃣
  const { status, body } = await session.authorize();
  return res.status(status).end(body);
}
```

Let’s break it down!

- In step 1️⃣, we’re setting up a `new Liveblocks()` client instance for your
  account once. This is a Node client to interact with the Liveblocks REST API,
  so it will run in your backend.
- In step 2️⃣, we’re starting a new auth session. Every session should have a
  unique user ID, which typically is just the ID of the user as it’s known in
  your own database.
- Step 3️⃣ is where we’re going to describe exactly what rooms this users should
  be allowed to enter, and what permissions they should have. In this case, we
  give the user access to exactly the room that this auth request was made for,
  using `session.allow(req.body.room, session.FULL_ACCESS)` which might be
  called at runtime as `session.allow("my-room", ["room:write"])`. Here,
  `FULL_ACCESS` is just a convenient preset that you can use to not have to
  write out the exact permissions yourself. There also exists a `READ_ACCESS`
  preset.
- Finally, in step 4️⃣, we hit the Liveblocks backend to get a token that can be
  used to enter any of the allowed rooms!

To make it all work end to end, update your client-side to use this new endpoint
like so:

```bash
npm install @liveblocks/client@latest
```

Then, configure your client:

```ts file="liveblocks.config.ts"
const client = createClient({
  secret,
  authEndpoint: "/api/liveblocks-auth",
  //            ^^^^^^^^^^^^^^^^^^^^^^ Point it to the newly created endpoint
});
```

That’s it! You’re migrated!

However, we’re still not utilizing our new multi-room support yet! Please read
on.

## Giving access to multiple rooms at once [#multi-room-access]

In the previous section, we set up our new auth backend to issue access tokens,
but we were only giving users access to a single room every time.

This means that if a user enters room `"my-room-1"`, and then subsequently tries
to enter `"my-room-2"`, the client will still have to authorize each such join
attempt separately, hitting your auth backend twice.

We can fix that now!

We’re allowed to make multiple `allow()` calls on the session. For example, you
could do:

```ts
session.allow("my-room-1", session.FULL_ACCESS);
session.allow("my-room-2", session.FULL_ACCESS);
session.allow("someone-elses-room-1", session.READ_ACCESS);
```

Or even give access to an inifinite number of rooms based on the room names, by
specifying prefix-based wildcard patterns:

```ts
session.allow("my-room-*", session.FULL_ACCESS);
session.allow("someone-elses-room-*", session.READ_ACCESS);
```

If you authorize the session like this, then the client would be able to reuse
the token when you leave `"my-room-1"`, and enter `"someone-elses-room-5"`,
without having to reauthorize against your backend, making joining those rooms a
lot faster.

<Banner type="success" title="Token size limitation">
  You can make maximally 10 `.allow()` calls per session.
</Banner>

If you want to adopt this pattern, you’ll have to structurally name your
Liveblocks rooms to follow a specific pattern. See
[authentication patterns](/docs/rooms/permissions/access-token#patterns) to
learn about common patterns you can use, or learn about our
[naming best practices](/docs/rooms/permissions/access-token#naming-best-practices).

## Upgrading to ID tokens [#upgrade-to-id-tokens]

Are you already using using our REST API to assign fine-grained permissions to
each room, via [Create room](/docs/api-reference/rest-api-endpoints#post-rooms)
or [Update room](/docs/api-reference/rest-api-endpoints#post-rooms-roomId) APIs?
If so, then read on. Otherwise, we would suggest to
[upgrade to access tokens](#upgrade-to-access-tokens) instead. It’s much simpler
to work with.

If you already did the work of setting up room permissions using our REST API,
great! Then the hard part is done already.

First, let’s create a new endpoint in your backend, next to your existing
`/api/auth` endpoint. We recommend going with `/api/liveblocks-auth`.

All you have to do now is implement it as follows:

```ts file="app/api/liveblocks-auth/route.ts"
import { Liveblocks } from "@liveblocks/node";

// Step 1️⃣
const liveblocks = new Liveblocks({
  secret: "sk_prod_xxxxxxxxxxxxxxxxxxxxxxxx",
});

export default async function myNewAuthEndpoint(req, res) {
  const user = __getUserFromDB__(req);

  // Step 2️⃣
  const { status, body } = await liveblocks.identifyUser({
    userId: user.id,
    groupIds, // Optional
  });
  return res.status(status).end(body);
}
```

Whatever user ID (or group IDs) you assign there will be the ones that will be
used to check the permissions you configured in your Liveblocks account already.

To make it all work end to end, update your client-side to use this new endpoint
like so:

```bash
npm install @liveblocks/client@latest
```

Then, configure your client:

```ts file="liveblocks.config.ts"
const client = createClient({
  secret,
  authEndpoint: "/api/liveblocks-auth",
  //            ^^^^^^^^^^^^^^^^^^^^^^ Point it to the newly created endpoint
});
```

That’s it! You’re migrated!

If you have issues with these new patterns and need help, please let us know
[by email](mailto:support@liveblocks.io) or by joining our
[Discord community](/discord)! We’re here to help!
