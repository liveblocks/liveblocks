/**
 * This file is AUTOMATICALLY GENERATED.
 * DO NOT edit this file manually.
 *
 * Instead, update the `ast.grammar` file, and re-run `npm run build-ast`
 */

const DEBUG = process.env.NODE_ENV !== "production";

function assert(condition: boolean, errmsg: string): asserts condition {
  if (condition) return;
  throw new Error(errmsg);
}

function assertRange(
  range: unknown,
  currentContext: string
): asserts range is Range {
  assert(
    isRange(range),
    `Invalid value for range in "${JSON.stringify(
      currentContext
    )}".\nExpected: Range\nGot: ${JSON.stringify(range)}`
  );
}

export function isBuiltInScalarType(node: Node): node is BuiltInScalarType {
  return (
    node._kind === "StringKeyword" ||
    node._kind === "IntKeyword" ||
    node._kind === "FloatKeyword" ||
    node._kind === "BooleanKeyword"
  );
}

export function isDefinition(node: Node): node is Definition {
  return node._kind === "ObjectTypeDef";
}

export function isLiveTypeExpr(node: Node): node is LiveTypeExpr {
  return node._kind === "LiveObjectTypeExpr";
}

export function isTypeExpr(node: Node): node is TypeExpr {
  return (
    node._kind === "ObjectLiteralExpr" ||
    node._kind === "TypeRef" ||
    isBuiltInScalarType(node) ||
    isLiveTypeExpr(node)
  );
}

export type BuiltInScalarType =
  | StringKeyword
  | IntKeyword
  | FloatKeyword
  | BooleanKeyword;

export type Definition = ObjectTypeDef;

export type LiveTypeExpr = LiveObjectTypeExpr;

export type TypeExpr =
  | BuiltInScalarType
  | LiveTypeExpr
  | ObjectLiteralExpr
  | TypeRef;

export type Range = [number, number];

export type Node =
  | BooleanKeyword
  | Document
  | FieldDef
  | FloatKeyword
  | Identifier
  | IntKeyword
  | LiveObjectTypeExpr
  | ObjectLiteralExpr
  | ObjectTypeDef
  | StringKeyword
  | TypeName
  | TypeRef;

export function isRange(thing: unknown): thing is Range {
  return (
    Array.isArray(thing) &&
    thing.length === 2 &&
    typeof thing[0] === "number" &&
    typeof thing[1] === "number"
  );
}

export function isNode(node: Node): node is Node {
  return (
    node._kind === "BooleanKeyword" ||
    node._kind === "Document" ||
    node._kind === "FieldDef" ||
    node._kind === "FloatKeyword" ||
    node._kind === "Identifier" ||
    node._kind === "IntKeyword" ||
    node._kind === "LiveObjectTypeExpr" ||
    node._kind === "ObjectLiteralExpr" ||
    node._kind === "ObjectTypeDef" ||
    node._kind === "StringKeyword" ||
    node._kind === "TypeName" ||
    node._kind === "TypeRef"
  );
}

export type BooleanKeyword = {
  _kind: "BooleanKeyword";
  dummy_: string | null;
  range: Range;
};

export type Document = {
  _kind: "Document";
  definitions: Definition[];
  range: Range;
};

export type FieldDef = {
  _kind: "FieldDef";
  name: Identifier;
  optional: boolean;
  type: TypeExpr;
  range: Range;
};

export type FloatKeyword = {
  _kind: "FloatKeyword";
  dummy_: string | null;
  range: Range;
};

export type Identifier = {
  _kind: "Identifier";
  name: string;
  range: Range;
};

export type IntKeyword = {
  _kind: "IntKeyword";
  dummy_: string | null;
  range: Range;
};

export type LiveObjectTypeExpr = {
  _kind: "LiveObjectTypeExpr";
  of: TypeRef;
  range: Range;
};

export type ObjectLiteralExpr = {
  _kind: "ObjectLiteralExpr";
  fields: FieldDef[];
  range: Range;
};

export type ObjectTypeDef = {
  _kind: "ObjectTypeDef";
  name: TypeName;
  obj: ObjectLiteralExpr;
  range: Range;
};

export type StringKeyword = {
  _kind: "StringKeyword";
  dummy_: string | null;
  range: Range;
};

export type TypeName = {
  _kind: "TypeName";
  name: string;
  range: Range;
};

export type TypeRef = {
  _kind: "TypeRef";
  name: TypeName;
  range: Range;
};

export function booleanKeyword(
  dummy_: string | null = null,
  range: Range = [0, 0]
): BooleanKeyword {
  DEBUG &&
    (() => {
      assert(
        dummy_ === null || typeof dummy_ === "string",
        `Invalid value for "dummy_" arg in "BooleanKeyword" call.\nExpected: string?\nGot:      ${JSON.stringify(
          dummy_
        )}`
      );
      assertRange(range, "BooleanKeyword");
    })();
  return {
    _kind: "BooleanKeyword",
    dummy_,
    range,
  };
}

export function document(
  definitions: Definition[],
  range: Range = [0, 0]
): Document {
  DEBUG &&
    (() => {
      assert(
        Array.isArray(definitions) &&
          definitions.length > 0 &&
          definitions.every((item) => isDefinition(item)),
        `Invalid value for "definitions" arg in "Document" call.\nExpected: @Definition+\nGot:      ${JSON.stringify(
          definitions
        )}`
      );
      assertRange(range, "Document");
    })();
  return {
    _kind: "Document",
    definitions,
    range,
  };
}

export function fieldDef(
  name: Identifier,
  optional: boolean,
  type: TypeExpr,
  range: Range = [0, 0]
): FieldDef {
  DEBUG &&
    (() => {
      assert(
        name._kind === "Identifier",
        `Invalid value for "name" arg in "FieldDef" call.\nExpected: Identifier\nGot:      ${JSON.stringify(
          name
        )}`
      );
      assert(
        typeof optional === "boolean",
        `Invalid value for "optional" arg in "FieldDef" call.\nExpected: boolean\nGot:      ${JSON.stringify(
          optional
        )}`
      );
      assert(
        isTypeExpr(type),
        `Invalid value for "type" arg in "FieldDef" call.\nExpected: @TypeExpr\nGot:      ${JSON.stringify(
          type
        )}`
      );
      assertRange(range, "FieldDef");
    })();
  return {
    _kind: "FieldDef",
    name,
    optional,
    type,
    range,
  };
}

export function floatKeyword(
  dummy_: string | null = null,
  range: Range = [0, 0]
): FloatKeyword {
  DEBUG &&
    (() => {
      assert(
        dummy_ === null || typeof dummy_ === "string",
        `Invalid value for "dummy_" arg in "FloatKeyword" call.\nExpected: string?\nGot:      ${JSON.stringify(
          dummy_
        )}`
      );
      assertRange(range, "FloatKeyword");
    })();
  return {
    _kind: "FloatKeyword",
    dummy_,
    range,
  };
}

export function identifier(name: string, range: Range = [0, 0]): Identifier {
  DEBUG &&
    (() => {
      assert(
        typeof name === "string",
        `Invalid value for "name" arg in "Identifier" call.\nExpected: string\nGot:      ${JSON.stringify(
          name
        )}`
      );
      assertRange(range, "Identifier");
    })();
  return {
    _kind: "Identifier",
    name,
    range,
  };
}

export function intKeyword(
  dummy_: string | null = null,
  range: Range = [0, 0]
): IntKeyword {
  DEBUG &&
    (() => {
      assert(
        dummy_ === null || typeof dummy_ === "string",
        `Invalid value for "dummy_" arg in "IntKeyword" call.\nExpected: string?\nGot:      ${JSON.stringify(
          dummy_
        )}`
      );
      assertRange(range, "IntKeyword");
    })();
  return {
    _kind: "IntKeyword",
    dummy_,
    range,
  };
}

export function liveObjectTypeExpr(
  of: TypeRef,
  range: Range = [0, 0]
): LiveObjectTypeExpr {
  DEBUG &&
    (() => {
      assert(
        of._kind === "TypeRef",
        `Invalid value for "of" arg in "LiveObjectTypeExpr" call.\nExpected: TypeRef\nGot:      ${JSON.stringify(
          of
        )}`
      );
      assertRange(range, "LiveObjectTypeExpr");
    })();
  return {
    _kind: "LiveObjectTypeExpr",
    of,
    range,
  };
}

export function objectLiteralExpr(
  fields: FieldDef[] = [],
  range: Range = [0, 0]
): ObjectLiteralExpr {
  DEBUG &&
    (() => {
      assert(
        Array.isArray(fields) &&
          fields.every((item) => item._kind === "FieldDef"),
        `Invalid value for "fields" arg in "ObjectLiteralExpr" call.\nExpected: FieldDef*\nGot:      ${JSON.stringify(
          fields
        )}`
      );
      assertRange(range, "ObjectLiteralExpr");
    })();
  return {
    _kind: "ObjectLiteralExpr",
    fields,
    range,
  };
}

export function objectTypeDef(
  name: TypeName,
  obj: ObjectLiteralExpr,
  range: Range = [0, 0]
): ObjectTypeDef {
  DEBUG &&
    (() => {
      assert(
        name._kind === "TypeName",
        `Invalid value for "name" arg in "ObjectTypeDef" call.\nExpected: TypeName\nGot:      ${JSON.stringify(
          name
        )}`
      );
      assert(
        obj._kind === "ObjectLiteralExpr",
        `Invalid value for "obj" arg in "ObjectTypeDef" call.\nExpected: ObjectLiteralExpr\nGot:      ${JSON.stringify(
          obj
        )}`
      );
      assertRange(range, "ObjectTypeDef");
    })();
  return {
    _kind: "ObjectTypeDef",
    name,
    obj,
    range,
  };
}

export function stringKeyword(
  dummy_: string | null = null,
  range: Range = [0, 0]
): StringKeyword {
  DEBUG &&
    (() => {
      assert(
        dummy_ === null || typeof dummy_ === "string",
        `Invalid value for "dummy_" arg in "StringKeyword" call.\nExpected: string?\nGot:      ${JSON.stringify(
          dummy_
        )}`
      );
      assertRange(range, "StringKeyword");
    })();
  return {
    _kind: "StringKeyword",
    dummy_,
    range,
  };
}

export function typeName(name: string, range: Range = [0, 0]): TypeName {
  DEBUG &&
    (() => {
      assert(
        typeof name === "string",
        `Invalid value for "name" arg in "TypeName" call.\nExpected: string\nGot:      ${JSON.stringify(
          name
        )}`
      );
      assertRange(range, "TypeName");
    })();
  return {
    _kind: "TypeName",
    name,
    range,
  };
}

export function typeRef(name: TypeName, range: Range = [0, 0]): TypeRef {
  DEBUG &&
    (() => {
      assert(
        name._kind === "TypeName",
        `Invalid value for "name" arg in "TypeRef" call.\nExpected: TypeName\nGot:      ${JSON.stringify(
          name
        )}`
      );
      assertRange(range, "TypeRef");
    })();
  return {
    _kind: "TypeRef",
    name,
    range,
  };
}

interface Visitor<TContext> {
  BooleanKeyword?(node: BooleanKeyword, context: TContext): void;
  Document?(node: Document, context: TContext): void;
  FieldDef?(node: FieldDef, context: TContext): void;
  FloatKeyword?(node: FloatKeyword, context: TContext): void;
  Identifier?(node: Identifier, context: TContext): void;
  IntKeyword?(node: IntKeyword, context: TContext): void;
  LiveObjectTypeExpr?(node: LiveObjectTypeExpr, context: TContext): void;
  ObjectLiteralExpr?(node: ObjectLiteralExpr, context: TContext): void;
  ObjectTypeDef?(node: ObjectTypeDef, context: TContext): void;
  StringKeyword?(node: StringKeyword, context: TContext): void;
  TypeName?(node: TypeName, context: TContext): void;
  TypeRef?(node: TypeRef, context: TContext): void;
}

export function visit<TNode extends Node>(
  node: TNode,
  visitor: Visitor<undefined>
): TNode;
export function visit<TNode extends Node, TContext>(
  node: TNode,
  visitor: Visitor<TContext>,
  context: TContext
): TNode;
export function visit<TNode extends Node, TContext>(
  node: TNode,
  visitor: Visitor<TContext | undefined>,
  context?: TContext
): TNode {
  switch (node._kind) {
    case "BooleanKeyword":
      visitor.BooleanKeyword?.(node, context);
      break;

    case "Document":
      visitor.Document?.(node, context);
      node.definitions.forEach((d) => visit(d, visitor, context));
      break;

    case "FieldDef":
      visitor.FieldDef?.(node, context);
      visit(node.name, visitor, context);
      visit(node.type, visitor, context);
      break;

    case "FloatKeyword":
      visitor.FloatKeyword?.(node, context);
      break;

    case "Identifier":
      visitor.Identifier?.(node, context);
      break;

    case "IntKeyword":
      visitor.IntKeyword?.(node, context);
      break;

    case "LiveObjectTypeExpr":
      visitor.LiveObjectTypeExpr?.(node, context);
      visit(node.of, visitor, context);
      break;

    case "ObjectLiteralExpr":
      visitor.ObjectLiteralExpr?.(node, context);
      node.fields.forEach((f) => visit(f, visitor, context));
      break;

    case "ObjectTypeDef":
      visitor.ObjectTypeDef?.(node, context);
      visit(node.name, visitor, context);
      visit(node.obj, visitor, context);
      break;

    case "StringKeyword":
      visitor.StringKeyword?.(node, context);
      break;

    case "TypeName":
      visitor.TypeName?.(node, context);
      break;

    case "TypeRef":
      visitor.TypeRef?.(node, context);
      visit(node.name, visitor, context);
      break;
  }

  return node;
}
