/**
 * This file is AUTOMATICALLY GENERATED.
 * DO NOT edit this file manually.
 *
 * Instead, update the `ast.grammar` file, and re-run `npm run build-ast`
 */

const DEBUG = process.env.NODE_ENV !== "production";

function assert(condition: boolean, errmsg: string): asserts condition {
  if (condition) return;
  throw new Error(errmsg);
}

function assertRange(
  range: unknown,
  currentContext: string
): asserts range is Range {
  assert(
    isRange(range),
    `Invalid value for range in "${JSON.stringify(
      currentContext
    )}".\nExpected: Range\nGot: ${JSON.stringify(range)}`
  );
}

export function isDefinition(node: Node): node is Definition {
  return node._kind === "ObjectTypeDefinition";
}

export function isLiveType(node: Node): node is LiveType {
  return node._kind === "LiveMapType" || node._kind === "LiveListType";
}

export function isNonUnionType(node: Node): node is NonUnionType {
  return (
    node._kind === "ArrayType" ||
    node._kind === "ObjectLiteralType" ||
    node._kind === "TypeRef" ||
    isScalarType(node) ||
    isLiveType(node)
  );
}

export function isScalarType(node: Node): node is ScalarType {
  return (
    node._kind === "StringType" ||
    node._kind === "NumberType" ||
    node._kind === "BooleanType" ||
    node._kind === "NullType" ||
    node._kind === "LiteralType"
  );
}

export function isType(node: Node): node is Type {
  return node._kind === "UnionType" || isNonUnionType(node);
}

export type Definition = ObjectTypeDefinition;

export type LiveType = LiveMapType | LiveListType;

export type NonUnionType =
  | ScalarType
  | ArrayType
  | ObjectLiteralType
  | LiveType
  | TypeRef;

export type ScalarType =
  | StringType
  | NumberType
  | BooleanType
  | NullType
  | LiteralType;

export type Type = NonUnionType | UnionType;

export type Range = [number, number];

export type Node =
  | ArrayType
  | BooleanType
  | Document
  | FieldDef
  | Identifier
  | LiteralType
  | LiveListType
  | LiveMapType
  | NullType
  | NumberType
  | ObjectLiteralType
  | ObjectTypeDefinition
  | StringType
  | TypeName
  | TypeRef
  | UnionType;

export function isRange(thing: unknown): thing is Range {
  return (
    Array.isArray(thing) &&
    thing.length === 2 &&
    typeof thing[0] === "number" &&
    typeof thing[1] === "number"
  );
}

export function isNode(node: Node): node is Node {
  return (
    node._kind === "ArrayType" ||
    node._kind === "BooleanType" ||
    node._kind === "Document" ||
    node._kind === "FieldDef" ||
    node._kind === "Identifier" ||
    node._kind === "LiteralType" ||
    node._kind === "LiveListType" ||
    node._kind === "LiveMapType" ||
    node._kind === "NullType" ||
    node._kind === "NumberType" ||
    node._kind === "ObjectLiteralType" ||
    node._kind === "ObjectTypeDefinition" ||
    node._kind === "StringType" ||
    node._kind === "TypeName" ||
    node._kind === "TypeRef" ||
    node._kind === "UnionType"
  );
}

export type ArrayType = {
  _kind: "ArrayType";
  ofType: Type;
  range: Range;
};

export type BooleanType = {
  _kind: "BooleanType";

  range: Range;
};

export type Document = {
  _kind: "Document";
  definitions: Definition[];
  range: Range;
};

export type FieldDef = {
  _kind: "FieldDef";
  name: Identifier;
  optional: boolean;
  type: Type;
  leadingComment: string | null;
  trailingComment: string | null;
  range: Range;
};

export type Identifier = {
  _kind: "Identifier";
  name: string;
  range: Range;
};

export type LiteralType = {
  _kind: "LiteralType";
  value: string | number | boolean;
  range: Range;
};

export type LiveListType = {
  _kind: "LiveListType";
  ofType: Type;
  range: Range;
};

export type LiveMapType = {
  _kind: "LiveMapType";
  keyType: Type;
  valueType: Type;
  range: Range;
};

export type NullType = {
  _kind: "NullType";

  range: Range;
};

export type NumberType = {
  _kind: "NumberType";

  range: Range;
};

export type ObjectLiteralType = {
  _kind: "ObjectLiteralType";
  fields: FieldDef[];
  range: Range;
};

export type ObjectTypeDefinition = {
  _kind: "ObjectTypeDefinition";
  name: TypeName;
  fields: FieldDef[];
  leadingComment: string | null;
  isStatic: boolean;
  range: Range;
};

export type StringType = {
  _kind: "StringType";

  range: Range;
};

export type TypeName = {
  _kind: "TypeName";
  name: string;
  range: Range;
};

export type TypeRef = {
  _kind: "TypeRef";
  ref: TypeName;
  asLiveObject: boolean;
  range: Range;
};

export type UnionType = {
  _kind: "UnionType";
  members: NonUnionType[];
  range: Range;
};

export function arrayType(ofType: Type, range: Range = [0, 0]): ArrayType {
  DEBUG &&
    (() => {
      assert(
        isType(ofType),
        `Invalid value for "ofType" arg in "ArrayType" call.\nExpected: @Type\nGot:      ${JSON.stringify(
          ofType
        )}`
      );
      assertRange(range, "ArrayType");
    })();
  return {
    _kind: "ArrayType",
    ofType,
    range,
  };
}

export function booleanType(range: Range = [0, 0]): BooleanType {
  DEBUG &&
    (() => {
      assertRange(range, "BooleanType");
    })();
  return {
    _kind: "BooleanType",
    range,
  };
}

export function document(
  definitions: Definition[],
  range: Range = [0, 0]
): Document {
  DEBUG &&
    (() => {
      assert(
        Array.isArray(definitions) &&
          definitions.length > 0 &&
          definitions.every((item) => isDefinition(item)),
        `Invalid value for "definitions" arg in "Document" call.\nExpected: @Definition+\nGot:      ${JSON.stringify(
          definitions
        )}`
      );
      assertRange(range, "Document");
    })();
  return {
    _kind: "Document",
    definitions,
    range,
  };
}

export function fieldDef(
  name: Identifier,
  optional: boolean,
  type: Type,
  leadingComment: string | null = null,
  trailingComment: string | null = null,
  range: Range = [0, 0]
): FieldDef {
  DEBUG &&
    (() => {
      assert(
        name._kind === "Identifier",
        `Invalid value for "name" arg in "FieldDef" call.\nExpected: Identifier\nGot:      ${JSON.stringify(
          name
        )}`
      );
      assert(
        typeof optional === "boolean",
        `Invalid value for "optional" arg in "FieldDef" call.\nExpected: boolean\nGot:      ${JSON.stringify(
          optional
        )}`
      );
      assert(
        isType(type),
        `Invalid value for "type" arg in "FieldDef" call.\nExpected: @Type\nGot:      ${JSON.stringify(
          type
        )}`
      );
      assert(
        leadingComment === null || typeof leadingComment === "string",
        `Invalid value for "leadingComment" arg in "FieldDef" call.\nExpected: string?\nGot:      ${JSON.stringify(
          leadingComment
        )}`
      );
      assert(
        trailingComment === null || typeof trailingComment === "string",
        `Invalid value for "trailingComment" arg in "FieldDef" call.\nExpected: string?\nGot:      ${JSON.stringify(
          trailingComment
        )}`
      );
      assertRange(range, "FieldDef");
    })();
  return {
    _kind: "FieldDef",
    name,
    optional,
    type,
    leadingComment,
    trailingComment,
    range,
  };
}

export function identifier(name: string, range: Range = [0, 0]): Identifier {
  DEBUG &&
    (() => {
      assert(
        typeof name === "string",
        `Invalid value for "name" arg in "Identifier" call.\nExpected: string\nGot:      ${JSON.stringify(
          name
        )}`
      );
      assertRange(range, "Identifier");
    })();
  return {
    _kind: "Identifier",
    name,
    range,
  };
}

export function literalType(
  value: string | number | boolean,
  range: Range = [0, 0]
): LiteralType {
  DEBUG &&
    (() => {
      assert(
        typeof value === "string" ||
          typeof value === "number" ||
          typeof value === "boolean",
        `Invalid value for "value" arg in "LiteralType" call.\nExpected: string | number | boolean\nGot:      ${JSON.stringify(
          value
        )}`
      );
      assertRange(range, "LiteralType");
    })();
  return {
    _kind: "LiteralType",
    value,
    range,
  };
}

export function liveListType(
  ofType: Type,
  range: Range = [0, 0]
): LiveListType {
  DEBUG &&
    (() => {
      assert(
        isType(ofType),
        `Invalid value for "ofType" arg in "LiveListType" call.\nExpected: @Type\nGot:      ${JSON.stringify(
          ofType
        )}`
      );
      assertRange(range, "LiveListType");
    })();
  return {
    _kind: "LiveListType",
    ofType,
    range,
  };
}

export function liveMapType(
  keyType: Type,
  valueType: Type,
  range: Range = [0, 0]
): LiveMapType {
  DEBUG &&
    (() => {
      assert(
        isType(keyType),
        `Invalid value for "keyType" arg in "LiveMapType" call.\nExpected: @Type\nGot:      ${JSON.stringify(
          keyType
        )}`
      );
      assert(
        isType(valueType),
        `Invalid value for "valueType" arg in "LiveMapType" call.\nExpected: @Type\nGot:      ${JSON.stringify(
          valueType
        )}`
      );
      assertRange(range, "LiveMapType");
    })();
  return {
    _kind: "LiveMapType",
    keyType,
    valueType,
    range,
  };
}

export function nullType(range: Range = [0, 0]): NullType {
  DEBUG &&
    (() => {
      assertRange(range, "NullType");
    })();
  return {
    _kind: "NullType",
    range,
  };
}

export function numberType(range: Range = [0, 0]): NumberType {
  DEBUG &&
    (() => {
      assertRange(range, "NumberType");
    })();
  return {
    _kind: "NumberType",
    range,
  };
}

export function objectLiteralType(
  fields: FieldDef[] = [],
  range: Range = [0, 0]
): ObjectLiteralType {
  DEBUG &&
    (() => {
      assert(
        Array.isArray(fields) &&
          fields.every((item) => item._kind === "FieldDef"),
        `Invalid value for "fields" arg in "ObjectLiteralType" call.\nExpected: FieldDef*\nGot:      ${JSON.stringify(
          fields
        )}`
      );
      assertRange(range, "ObjectLiteralType");
    })();
  return {
    _kind: "ObjectLiteralType",
    fields,
    range,
  };
}

export function objectTypeDefinition(
  name: TypeName,
  fields: FieldDef[],
  leadingComment: string | null,
  isStatic: boolean,
  range: Range = [0, 0]
): ObjectTypeDefinition {
  DEBUG &&
    (() => {
      assert(
        name._kind === "TypeName",
        `Invalid value for "name" arg in "ObjectTypeDefinition" call.\nExpected: TypeName\nGot:      ${JSON.stringify(
          name
        )}`
      );
      assert(
        Array.isArray(fields) &&
          fields.every((item) => item._kind === "FieldDef"),
        `Invalid value for "fields" arg in "ObjectTypeDefinition" call.\nExpected: FieldDef*\nGot:      ${JSON.stringify(
          fields
        )}`
      );
      assert(
        leadingComment === null || typeof leadingComment === "string",
        `Invalid value for "leadingComment" arg in "ObjectTypeDefinition" call.\nExpected: string?\nGot:      ${JSON.stringify(
          leadingComment
        )}`
      );
      assert(
        typeof isStatic === "boolean",
        `Invalid value for "isStatic" arg in "ObjectTypeDefinition" call.\nExpected: boolean\nGot:      ${JSON.stringify(
          isStatic
        )}`
      );
      assertRange(range, "ObjectTypeDefinition");
    })();
  return {
    _kind: "ObjectTypeDefinition",
    name,
    fields,
    leadingComment,
    isStatic,
    range,
  };
}

export function stringType(range: Range = [0, 0]): StringType {
  DEBUG &&
    (() => {
      assertRange(range, "StringType");
    })();
  return {
    _kind: "StringType",
    range,
  };
}

export function typeName(name: string, range: Range = [0, 0]): TypeName {
  DEBUG &&
    (() => {
      assert(
        typeof name === "string",
        `Invalid value for "name" arg in "TypeName" call.\nExpected: string\nGot:      ${JSON.stringify(
          name
        )}`
      );
      assertRange(range, "TypeName");
    })();
  return {
    _kind: "TypeName",
    name,
    range,
  };
}

export function typeRef(
  ref: TypeName,
  asLiveObject: boolean,
  range: Range = [0, 0]
): TypeRef {
  DEBUG &&
    (() => {
      assert(
        ref._kind === "TypeName",
        `Invalid value for "ref" arg in "TypeRef" call.\nExpected: TypeName\nGot:      ${JSON.stringify(
          ref
        )}`
      );
      assert(
        typeof asLiveObject === "boolean",
        `Invalid value for "asLiveObject" arg in "TypeRef" call.\nExpected: boolean\nGot:      ${JSON.stringify(
          asLiveObject
        )}`
      );
      assertRange(range, "TypeRef");
    })();
  return {
    _kind: "TypeRef",
    ref,
    asLiveObject,
    range,
  };
}

export function unionType(
  members: NonUnionType[],
  range: Range = [0, 0]
): UnionType {
  DEBUG &&
    (() => {
      assert(
        Array.isArray(members) &&
          members.length > 0 &&
          members.every((item) => isNonUnionType(item)),
        `Invalid value for "members" arg in "UnionType" call.\nExpected: @NonUnionType+\nGot:      ${JSON.stringify(
          members
        )}`
      );
      assertRange(range, "UnionType");
    })();
  return {
    _kind: "UnionType",
    members,
    range,
  };
}

interface Visitor<TContext> {
  ArrayType?(node: ArrayType, context: TContext): void;
  BooleanType?(node: BooleanType, context: TContext): void;
  Document?(node: Document, context: TContext): void;
  FieldDef?(node: FieldDef, context: TContext): void;
  Identifier?(node: Identifier, context: TContext): void;
  LiteralType?(node: LiteralType, context: TContext): void;
  LiveListType?(node: LiveListType, context: TContext): void;
  LiveMapType?(node: LiveMapType, context: TContext): void;
  NullType?(node: NullType, context: TContext): void;
  NumberType?(node: NumberType, context: TContext): void;
  ObjectLiteralType?(node: ObjectLiteralType, context: TContext): void;
  ObjectTypeDefinition?(node: ObjectTypeDefinition, context: TContext): void;
  StringType?(node: StringType, context: TContext): void;
  TypeName?(node: TypeName, context: TContext): void;
  TypeRef?(node: TypeRef, context: TContext): void;
  UnionType?(node: UnionType, context: TContext): void;
}

export function visit<TNode extends Node>(
  node: TNode,
  visitor: Visitor<undefined>
): TNode;
export function visit<TNode extends Node, TContext>(
  node: TNode,
  visitor: Visitor<TContext>,
  context: TContext
): TNode;
export function visit<TNode extends Node, TContext>(
  node: TNode,
  visitor: Visitor<TContext | undefined>,
  context?: TContext
): TNode {
  switch (node._kind) {
    case "ArrayType":
      visitor.ArrayType?.(node, context);
      visit(node.ofType, visitor, context);
      break;

    case "BooleanType":
      visitor.BooleanType?.(node, context);
      break;

    case "Document":
      visitor.Document?.(node, context);
      node.definitions.forEach((d) => visit(d, visitor, context));
      break;

    case "FieldDef":
      visitor.FieldDef?.(node, context);
      visit(node.name, visitor, context);
      visit(node.type, visitor, context);
      break;

    case "Identifier":
      visitor.Identifier?.(node, context);
      break;

    case "LiteralType":
      visitor.LiteralType?.(node, context);
      break;

    case "LiveListType":
      visitor.LiveListType?.(node, context);
      visit(node.ofType, visitor, context);
      break;

    case "LiveMapType":
      visitor.LiveMapType?.(node, context);
      visit(node.keyType, visitor, context);
      visit(node.valueType, visitor, context);
      break;

    case "NullType":
      visitor.NullType?.(node, context);
      break;

    case "NumberType":
      visitor.NumberType?.(node, context);
      break;

    case "ObjectLiteralType":
      visitor.ObjectLiteralType?.(node, context);
      node.fields.forEach((f) => visit(f, visitor, context));
      break;

    case "ObjectTypeDefinition":
      visitor.ObjectTypeDefinition?.(node, context);
      visit(node.name, visitor, context);
      node.fields.forEach((f) => visit(f, visitor, context));
      break;

    case "StringType":
      visitor.StringType?.(node, context);
      break;

    case "TypeName":
      visitor.TypeName?.(node, context);
      break;

    case "TypeRef":
      visitor.TypeRef?.(node, context);
      visit(node.ref, visitor, context);
      break;

    case "UnionType":
      visitor.UnionType?.(node, context);
      node.members.forEach((m) => visit(m, visitor, context));
      break;
  }

  return node;
}
