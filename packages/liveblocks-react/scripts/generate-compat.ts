import { readFileSync, writeFileSync } from "fs";
import {
  BlockLike,
  FunctionDeclaration,
  ScriptTarget,
  createSourceFile,
  TypeParameterDeclaration,
  Identifier,
  isFunctionDeclaration,
  isIdentifier,
  isObjectLiteralExpression,
  isReturnStatement,
  isShorthandPropertyAssignment,
  isTypeNode,
} from "typescript";

const SRC_FILE = "src/factory.tsx";
const TARGET_FILE = "src/compat.tsx";

const PREAMBLE = `
/**
 * NOTE:
 * This file is AUTOGENERATED!
 *
 * Do not update it manually.
 */
`;

function getDeprecationMessage(hookName: string): string {
  return `
    /**
     * @deprecated Importing \`${hookName}\` from \`@liveblocks/react\`
     * directly is deprecated, and support for it will get removed in 0.18.
     * Please instantiate your hooks using the \`configureRoom()\` factory
     * function instead. See
     * https://gist.github.com/nvie/5e718902c51ea7dad93cd6952fe1af03 for
     * details.
     */
  `;
}

function getFunctionDeclarations(block: BlockLike): FunctionDeclaration[] {
  return block.statements.filter(isFunctionDeclaration);
}

function findFunctionDeclaration(
  block: BlockLike,
  name: string
): FunctionDeclaration {
  const decl = getFunctionDeclarations(block).find(
    (f) => f.name?.text === name
  );
  if (!decl) {
    throw new Error(`Couldn't find function declaration for "${name}"`);
  }
  return decl;
}

const srcFile = createSourceFile(
  TARGET_FILE,
  readFileSync(SRC_FILE, "utf8"),
  ScriptTarget.ESNext,
  /* setParentNodes */ true
);

/**
 * Reads the src/factory.tsx source file, and returns the list of
 * function declarations to wrap, e.g. the AST nodes for the definitions of
 * `useList`, `useHistory`, etc.
 */
function getLiveblocksHookDefintions() {
  const liveblocksFactoryFn = findFunctionDeclaration(srcFile, "configureRoom");

  // Get all of the things returned by this function. These represent the
  // "exports".
  const exportStm =
    liveblocksFactoryFn.body?.statements?.find(isReturnStatement);
  if (!exportStm) {
    throw new Error("Couldn't find return statement in `configureRoom()`");
  }

  const exportedObj = exportStm.expression;
  if (!exportedObj || !isObjectLiteralExpression(exportedObj)) {
    throw new Error("Expected `configureRoom()` to return an object literal");
  }

  const exportedNames: string[] = exportedObj.properties.map((p) => {
    if (!isShorthandPropertyAssignment(p)) {
      throw new Error(
        `Exported object expected to only contain shorthand identifiers, but found: "${p.getText()}"`
      );
    }
    return p.name.text;
  });

  // Grab all of the inner function declarations
  const decls: FunctionDeclaration[] = liveblocksFactoryFn.body
    ? getFunctionDeclarations(liveblocksFactoryFn.body)
    : [];

  const fns: (FunctionDeclaration & { name: Identifier })[] = [];
  for (const name of exportedNames) {
    const found = decls.filter(
      (d): d is FunctionDeclaration & { name: Identifier } =>
        d.name?.text === name
    );
    if (found.length === 0) {
      throw new Error("Declaration of " + name + " not found!");
    }
    fns.push(...found);
  }
  return fns;
}

/**
 * Take a Liveblocks hook declaration, and returns the source code to wrap it.
 */
function wrapHookDeclaration(
  decl: FunctionDeclaration & { name: Identifier },
  isOverload: boolean,
  hasOverloads: boolean
): string {
  const name = decl.name.text;

  // Extract function parameter names and their type annotations
  const paramDecls = decl.parameters.map((p) => {
    if (!isIdentifier(p.name)) {
      throw new Error("Cannot handle destructuring in arguments");
    }
    if (!p.type || !isTypeNode(p.type)) {
      throw new Error("Param " + p.name.text + " has no type annotation!");
    }
    return { name: p.name, type: p.type, optional: !!p.questionToken };
  });

  function doesReturnTypeNeed(ref: "TPresence" | "TStorage"): boolean {
    return !!decl.type && decl.type.getText().includes(ref);
  }

  function doInputParamsNeed(ref: "TPresence" | "TStorage"): boolean {
    return paramDecls.some(({ type }) => type.getText().includes(ref));
  }

  const extraTPresence =
    doesReturnTypeNeed("TPresence") || doInputParamsNeed("TPresence")
      ? "TPresence extends JsonObject"
      : "";

  const extraTStorage =
    doesReturnTypeNeed("TStorage") || doInputParamsNeed("TStorage")
      ? "TStorage extends LsonObject"
      : "";

  const jsDocComment = getDeprecationMessage(name).trim();

  const optionalTypeParams: string =
    decl.typeParameters || extraTPresence || extraTStorage
      ? `<${[
          ...[extraTPresence, extraTStorage].filter(Boolean),
          ...(decl.typeParameters ?? []).map(
            (tparam: TypeParameterDeclaration) => tparam.getText()
          ),
        ].join(", ")}>`
      : "";

  const params = paramDecls
    .map(
      ({ name, type, optional }) =>
        `${name.text}${optional ? "?" : ""}: ${type.getText()}`
    )
    .join(", ");

  const optionalReturnType = decl.type ? `: ${decl.type.getText()}` : "";

  // If this is a real function with a body, generate a function with a body
  // here too. Otherwise, it's an overload definition, and we should generate
  // that instead.
  if (!isOverload) {
    const args = paramDecls
      .map(({ name }) => name.text)
      .map((arg) => (hasOverloads ? `${arg} as any` : arg))
      .join(", ");

    const optionalCast =
      decl.type &&
      (doesReturnTypeNeed("TPresence") || doesReturnTypeNeed("TStorage"))
        ? ` as unknown as ${decl.type.getText()}`
        : "";

    const body = `
      deprecate("Importing \`${name}\` from \`@liveblocks/react\` directly is deprecated, and support for it will get removed in 0.18. Please instantiate your hooks using the \`configureRoom()\` factory function instead. See https://gist.github.com/nvie/5e718902c51ea7dad93cd6952fe1af03 for details.");
      return _hooks.${name}(${args})${optionalCast};
    `;

    // Put together the final source code
    return `
      ${jsDocComment}
      export function ${name}${optionalTypeParams}(${params})${optionalReturnType} {
        ${body}
      }
    `;
  } else {
    return `
      ${jsDocComment}
      export function ${name}${optionalTypeParams}(${params})${optionalReturnType};
    `;
  }
}

let output = "";

output += PREAMBLE;
output += "\n";
output += `
import type { BroadcastOptions, History, Json, JsonObject, LiveList, LiveMap, LiveObject, Lson, LsonObject, Others, Room, User } from "@liveblocks/client";
import type { RoomProviderProps } from "./factory";
import { configureRoom } from "./factory";
import { deprecate } from "@liveblocks/client/internal";

const _hooks = configureRoom();
`;
output += "\n";

const liveblocksHooks = getLiveblocksHookDefintions();
for (const decl of liveblocksHooks) {
  const isOverload = !decl.body;
  const hasOverloads =
    !isOverload &&
    liveblocksHooks.filter((hook) => hook.name.text === decl.name.text).length >
      1;
  output += "\n";
  output += wrapHookDeclaration(decl, isOverload, hasOverloads);
  output += "\n";
}

writeFileSync("src/compat.tsx", output, { encoding: "utf-8" });
