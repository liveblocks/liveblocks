import { readFileSync, writeFileSync } from "fs";
import {
  BlockLike,
  FunctionDeclaration,
  ScriptTarget,
  createSourceFile,
  TypeParameterDeclaration,
  Identifier,
  isFunctionDeclaration,
  isIdentifier,
  isObjectLiteralExpression,
  isReturnStatement,
  isShorthandPropertyAssignment,
  isTypeNode,
} from "typescript";

const migrationGuideLink =
  "https://liveblocks.io/docs/guides/upgrading#upgrading-from-0-16-to-0-17";

const SRC_FILE = "src/factory.tsx";
const TARGET_FILE = "src/compat.tsx";

const PREAMBLE = `
/**
 * NOTE:
 * This file is AUTOGENERATED!
 *
 * Do not update it manually.
 */
`;

function getDeprecationMessage(hookName: string): string {
  return `
    /**
     * @deprecated Please use \`createRoomContext()\` instead of importing
     * \`${hookName}\` from \`@liveblocks/react\` directly. See
     * ${migrationGuideLink} for details.
     */
  `;
}

function getFunctionDeclarations(block: BlockLike): FunctionDeclaration[] {
  return block.statements.filter(isFunctionDeclaration);
}

function findFunctionDeclaration(
  block: BlockLike,
  name: string
): FunctionDeclaration {
  const decl = getFunctionDeclarations(block).find(
    (f) => f.name?.text === name
  );
  if (!decl) {
    throw new Error(`Couldn't find function declaration for "${name}"`);
  }
  return decl;
}

const srcFile = createSourceFile(
  TARGET_FILE,
  readFileSync(SRC_FILE, "utf8"),
  ScriptTarget.ESNext,
  /* setParentNodes */ true
);

/**
 * Reads the src/factory.tsx source file, and returns the list of
 * function declarations to wrap, e.g. the AST nodes for the definitions of
 * `useList`, `useHistory`, etc.
 */
function getLiveblocksHookDefintions() {
  const liveblocksFactoryFn = findFunctionDeclaration(
    srcFile,
    "createRoomContext"
  );

  // Get all of the things returned by this function. These represent the
  // "exports".
  const exportStm =
    liveblocksFactoryFn.body?.statements?.find(isReturnStatement);
  if (!exportStm) {
    throw new Error("Couldn't find return statement in `createRoomContext()`");
  }

  const exportedObj = exportStm.expression;
  if (!exportedObj || !isObjectLiteralExpression(exportedObj)) {
    throw new Error(
      "Expected `createRoomContext()` to return an object literal"
    );
  }

  const exportedNames: string[] = exportedObj.properties.map((p) => {
    if (!isShorthandPropertyAssignment(p)) {
      throw new Error(
        `Exported object expected to only contain shorthand identifiers, but found: "${p.getText()}"`
      );
    }
    return p.name.text;
  });

  // Grab all of the inner function declarations
  const decls: FunctionDeclaration[] = liveblocksFactoryFn.body
    ? getFunctionDeclarations(liveblocksFactoryFn.body)
    : [];

  const fns: (FunctionDeclaration & { name: Identifier })[] = [];
  for (const name of exportedNames) {
    const found = decls.filter(
      (d): d is FunctionDeclaration & { name: Identifier } =>
        d.name?.text === name
    );
    if (found.length === 0) {
      throw new Error("Declaration of " + name + " not found!");
    }
    fns.push(...found);
  }
  return fns;
}

/**
 * Take a Liveblocks hook declaration, and returns the source code to wrap it.
 */
function wrapHookDeclaration(
  decl: FunctionDeclaration & { name: Identifier },
  isOverload: boolean,
  hasOverloads: boolean
): string {
  const internalName = decl.name.text;
  const name = decl.name.text.startsWith("deprecated_")
    ? decl.name.text.slice("deprecated_".length)
    : decl.name.text;

  // Extract function parameter names and their type annotations
  const paramDecls = decl.parameters.map((p) => {
    if (!isIdentifier(p.name)) {
      throw new Error("Cannot handle destructuring in arguments");
    }
    if (!p.type || !isTypeNode(p.type)) {
      throw new Error("Param " + p.name.text + " has no type annotation!");
    }
    return { name: p.name, type: p.type, optional: !!p.questionToken };
  });

  function doesReturnTypeNeed(
    ref: "TPresence" | "TStorage" | "TUserMeta" | "TRoomEvent"
  ): boolean {
    return !!decl.type && decl.type.getText().includes(ref);
  }

  function doInputParamsNeed(
    ref: "TPresence" | "TStorage" | "TUserMeta" | "TRoomEvent"
  ): boolean {
    return paramDecls.some(({ type }) => type.getText().includes(ref));
  }

  const extraTPresence =
    doesReturnTypeNeed("TPresence") || doInputParamsNeed("TPresence")
      ? "TPresence extends JsonObject"
      : "";

  const extraTStorage =
    doesReturnTypeNeed("TStorage") || doInputParamsNeed("TStorage")
      ? "TStorage extends LsonObject"
      : "";

  const extraTUserMeta =
    doesReturnTypeNeed("TUserMeta") || doInputParamsNeed("TUserMeta")
      ? "TUserMeta extends BaseUserMeta"
      : "";

  const extraTRoomEvent =
    doesReturnTypeNeed("TRoomEvent") || doInputParamsNeed("TRoomEvent")
      ? "TRoomEvent extends Json"
      : "";

  const jsDocComment = getDeprecationMessage(name).trim();

  const optionalTypeParams: string =
    decl.typeParameters ||
    extraTPresence ||
    extraTStorage ||
    extraTUserMeta ||
    extraTRoomEvent
      ? `<${[
          ...[
            extraTPresence,
            extraTStorage,
            extraTUserMeta,
            extraTRoomEvent,
          ].filter(Boolean),
          ...(decl.typeParameters ?? []).map(
            (tparam: TypeParameterDeclaration) => tparam.getText()
          ),
        ].join(", ")}>`
      : "";

  const params = paramDecls
    .map(
      ({ name, type, optional }) =>
        `${name.text}${optional ? "?" : ""}: ${type.getText()}`
    )
    .join(", ");

  const optionalReturnType = decl.type ? `: ${decl.type.getText()}` : "";

  // If this is a real function with a body, generate a function with a body
  // here too. Otherwise, it's an overload definition, and we should generate
  // that instead.
  if (!isOverload) {
    const args = paramDecls
      .map(({ name }) => name.text)
      .map((arg) =>
        hasOverloads ||
        // This condition should not be checking the name of the hook, of
        // course! Really it should be checking whether the injected type
        // argument is used in a contravariant type position (for example,
        // a function argument to a callback function). Currently, that's only
        // the case in the `useEventListener` callback, though. So YOLO.
        // (This script only has to live one release anyway.)
        name === "useEventListener"
          ? `${arg} as any`
          : arg
      )
      .join(", ");

    const optionalCast =
      decl.type &&
      (doesReturnTypeNeed("TPresence") ||
        doesReturnTypeNeed("TStorage") ||
        doesReturnTypeNeed("TUserMeta") ||
        doesReturnTypeNeed("TRoomEvent"))
        ? ` as unknown as ${decl.type.getText()}`
        : "";

    const body = `
      deprecate(\`Please use \\\`createRoomContext()\\\` instead of importing \\\`${name}\\\` from \\\`@liveblocks/react\\\` directly. See ${migrationGuideLink} for details.\`);
      return _hooks.${internalName}(${args})${optionalCast};
    `;

    // Put together the final source code
    return `
      ${jsDocComment}
      export function ${name}${optionalTypeParams}(${params})${optionalReturnType} {
        ${body}
      }
    `;
  } else {
    return `
      ${jsDocComment}
      export function ${name}${optionalTypeParams}(${params})${optionalReturnType};
    `;
  }
}

let output = "";

output += PREAMBLE;
output += "\n";
output += `
import type { BroadcastOptions, History, Json, JsonObject, LiveList, LiveMap, LiveObject, Lson, LsonObject, Others, Room, User, BaseUserMeta } from "@liveblocks/client";
import type { RoomProviderProps } from "./factory";
import { createRoomContext } from "./factory";
import { deprecate } from "@liveblocks/client/internal";

const _hooks = createRoomContext("__legacy" as any);
`;
output += "\n";

const liveblocksHooks = getLiveblocksHookDefintions();
for (const decl of liveblocksHooks) {
  const isDeprecatedVersion = decl.name.text.startsWith("deprecated_");

  if (
    !isDeprecatedVersion &&
    liveblocksHooks.filter(
      (hook) => hook.name.text === "deprecated_" + decl.name.text
    ).length >= 1
  ) {
    // Skip over APIs that have a deprecated version - we'll be using those in
    // the compat layer!
    continue;
  }

  const isOverload = !decl.body;
  const hasOverloads =
    !isOverload &&
    liveblocksHooks.filter((hook) => hook.name.text === decl.name.text).length >
      1;

  output += "\n";
  output += wrapHookDeclaration(decl, isOverload, hasOverloads);
  output += "\n";
}

writeFileSync("src/compat.tsx", output, { encoding: "utf-8" });
